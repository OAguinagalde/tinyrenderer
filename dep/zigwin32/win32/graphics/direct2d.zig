//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (69)
//--------------------------------------------------------------------------------
pub const D2D1_DEFAULT_FLATTENING_TOLERANCE = @as(f32, 2.5e-01);
pub const CLSID_D2D12DAffineTransform = Guid.initString("6aa97485-6354-4cfc-908c-e4a74f62c96c");
pub const CLSID_D2D13DPerspectiveTransform = Guid.initString("c2844d0b-3d86-46e7-85ba-526c9240f3fb");
pub const CLSID_D2D13DTransform = Guid.initString("e8467b04-ec61-4b8a-b5de-d4d73debea5a");
pub const CLSID_D2D1ArithmeticComposite = Guid.initString("fc151437-049a-4784-a24a-f1c4daf20987");
pub const CLSID_D2D1Atlas = Guid.initString("913e2be4-fdcf-4fe2-a5f0-2454f14ff408");
pub const CLSID_D2D1BitmapSource = Guid.initString("5fb6c24d-c6dd-4231-9404-50f4d5c3252d");
pub const CLSID_D2D1Blend = Guid.initString("81c5b77b-13f8-4cdd-ad20-c890547ac65d");
pub const CLSID_D2D1Border = Guid.initString("2a2d49c0-4acf-43c7-8c6a-7c4a27874d27");
pub const CLSID_D2D1Brightness = Guid.initString("8cea8d1e-77b0-4986-b3b9-2f0c0eae7887");
pub const CLSID_D2D1ColorManagement = Guid.initString("1a28524c-fdd6-4aa4-ae8f-837eb8267b37");
pub const CLSID_D2D1ColorMatrix = Guid.initString("921f03d6-641c-47df-852d-b4bb6153ae11");
pub const CLSID_D2D1Composite = Guid.initString("48fc9f51-f6ac-48f1-8b58-3b28ac46f76d");
pub const CLSID_D2D1ConvolveMatrix = Guid.initString("407f8c08-5533-4331-a341-23cc3877843e");
pub const CLSID_D2D1Crop = Guid.initString("e23f7110-0e9a-4324-af47-6a2c0c46f35b");
pub const CLSID_D2D1DirectionalBlur = Guid.initString("174319a6-58e9-49b2-bb63-caf2c811a3db");
pub const CLSID_D2D1DiscreteTransfer = Guid.initString("90866fcd-488e-454b-af06-e5041b66c36c");
pub const CLSID_D2D1DisplacementMap = Guid.initString("edc48364-0417-4111-9450-43845fa9f890");
pub const CLSID_D2D1DistantDiffuse = Guid.initString("3e7efd62-a32d-46d4-a83c-5278889ac954");
pub const CLSID_D2D1DistantSpecular = Guid.initString("428c1ee5-77b8-4450-8ab5-72219c21abda");
pub const CLSID_D2D1DpiCompensation = Guid.initString("6c26c5c7-34e0-46fc-9cfd-e5823706e228");
pub const CLSID_D2D1Flood = Guid.initString("61c23c20-ae69-4d8e-94cf-50078df638f2");
pub const CLSID_D2D1GammaTransfer = Guid.initString("409444c4-c419-41a0-b0c1-8cd0c0a18e42");
pub const CLSID_D2D1GaussianBlur = Guid.initString("1feb6d69-2fe6-4ac9-8c58-1d7f93e7a6a5");
pub const CLSID_D2D1Scale = Guid.initString("9daf9369-3846-4d0e-a44e-0c607934a5d7");
pub const CLSID_D2D1Histogram = Guid.initString("881db7d0-f7ee-4d4d-a6d2-4697acc66ee8");
pub const CLSID_D2D1HueRotation = Guid.initString("0f4458ec-4b32-491b-9e85-bd73f44d3eb6");
pub const CLSID_D2D1LinearTransfer = Guid.initString("ad47c8fd-63ef-4acc-9b51-67979c036c06");
pub const CLSID_D2D1LuminanceToAlpha = Guid.initString("41251ab7-0beb-46f8-9da7-59e93fcce5de");
pub const CLSID_D2D1Morphology = Guid.initString("eae6c40d-626a-4c2d-bfcb-391001abe202");
pub const CLSID_D2D1OpacityMetadata = Guid.initString("6c53006a-4450-4199-aa5b-ad1656fece5e");
pub const CLSID_D2D1PointDiffuse = Guid.initString("b9e303c3-c08c-4f91-8b7b-38656bc48c20");
pub const CLSID_D2D1PointSpecular = Guid.initString("09c3ca26-3ae2-4f09-9ebc-ed3865d53f22");
pub const CLSID_D2D1Premultiply = Guid.initString("06eab419-deed-4018-80d2-3e1d471adeb2");
pub const CLSID_D2D1Saturation = Guid.initString("5cb2d9cf-327d-459f-a0ce-40c0b2086bf7");
pub const CLSID_D2D1Shadow = Guid.initString("c67ea361-1863-4e69-89db-695d3e9a5b6b");
pub const CLSID_D2D1SpotDiffuse = Guid.initString("818a1105-7932-44f4-aa86-08ae7b2f2c93");
pub const CLSID_D2D1SpotSpecular = Guid.initString("edae421e-7654-4a37-9db8-71acc1beb3c1");
pub const CLSID_D2D1TableTransfer = Guid.initString("5bf818c3-5e43-48cb-b631-868396d6a1d4");
pub const CLSID_D2D1Tile = Guid.initString("b0784138-3b76-4bc5-b13b-0fa2ad02659f");
pub const CLSID_D2D1Turbulence = Guid.initString("cf2bb6ae-889a-4ad7-ba29-a2fd732c9fc9");
pub const CLSID_D2D1UnPremultiply = Guid.initString("fb9ac489-ad8d-41ed-9999-bb6347d110f7");
pub const CLSID_D2D1YCbCr = Guid.initString("99503cc1-66c7-45c9-a875-8ad8a7914401");
pub const CLSID_D2D1Contrast = Guid.initString("b648a78a-0ed5-4f80-a94a-8e825aca6b77");
pub const CLSID_D2D1RgbToHue = Guid.initString("23f3e5ec-91e8-4d3d-ad0a-afadc1004aa1");
pub const CLSID_D2D1HueToRgb = Guid.initString("7b78a6bd-0141-4def-8a52-6356ee0cbdd5");
pub const CLSID_D2D1ChromaKey = Guid.initString("74c01f5b-2a0d-408c-88e2-c7a3c7197742");
pub const CLSID_D2D1Emboss = Guid.initString("b1c5eb2b-0348-43f0-8107-4957cacba2ae");
pub const CLSID_D2D1Exposure = Guid.initString("b56c8cfa-f634-41ee-bee0-ffa617106004");
pub const CLSID_D2D1Grayscale = Guid.initString("36dde0eb-3725-42e0-836d-52fb20aee644");
pub const CLSID_D2D1Invert = Guid.initString("e0c3784d-cb39-4e84-b6fd-6b72f0810263");
pub const CLSID_D2D1Posterize = Guid.initString("2188945e-33a3-4366-b7bc-086bd02d0884");
pub const CLSID_D2D1Sepia = Guid.initString("3a1af410-5f1d-4dbe-84df-915da79b7153");
pub const CLSID_D2D1Sharpen = Guid.initString("c9b887cb-c5ff-4dc5-9779-273dcf417c7d");
pub const CLSID_D2D1Straighten = Guid.initString("4da47b12-79a3-4fb0-8237-bbc3b2a4de08");
pub const CLSID_D2D1TemperatureTint = Guid.initString("89176087-8af9-4a08-aeb1-895f38db1766");
pub const CLSID_D2D1Vignette = Guid.initString("c00c40be-5e67-4ca3-95b4-f4b02c115135");
pub const CLSID_D2D1EdgeDetection = Guid.initString("eff583ca-cb07-4aa9-ac5d-2cc44c76460f");
pub const CLSID_D2D1HighlightsShadows = Guid.initString("cadc8384-323f-4c7e-a361-2e2b24df6ee4");
pub const CLSID_D2D1LookupTable3D = Guid.initString("349e0eda-0088-4a79-9ca3-c7e300202020");
pub const CLSID_D2D1Opacity = Guid.initString("811d79a4-de28-4454-8094-c64685f8bd4c");
pub const CLSID_D2D1AlphaMask = Guid.initString("c80ecff0-3fd5-4f05-8328-c5d1724b4f0a");
pub const CLSID_D2D1CrossFade = Guid.initString("12f575e8-4db1-485f-9a84-03a07dd3829f");
pub const CLSID_D2D1Tint = Guid.initString("36312b17-f7dd-4014-915d-ffca768cf211");
pub const D2D1_SCENE_REFERRED_SDR_WHITE_LEVEL = @as(f32, 80);
pub const CLSID_D2D1WhiteLevelAdjustment = Guid.initString("44a1cadb-6cdd-4818-8ff4-26c1cfe95bdb");
pub const CLSID_D2D1HdrToneMap = Guid.initString("7b0b748d-4610-4486-a90c-999d9a2e2b11");
pub const D2D1_APPEND_ALIGNED_ELEMENT = @as(u32, 4294967295);
pub const FACILITY_D2D = @as(u32, 2201);

//--------------------------------------------------------------------------------
// Section: Types (330)
//--------------------------------------------------------------------------------
pub const D2D1_INTERPOLATION_MODE_DEFINITION = enum(i32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FANT = 6,
    MIPMAP_LINEAR = 7,
};
pub const D2D1_INTERPOLATION_MODE_DEFINITION_NEAREST_NEIGHBOR = D2D1_INTERPOLATION_MODE_DEFINITION.NEAREST_NEIGHBOR;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_LINEAR = D2D1_INTERPOLATION_MODE_DEFINITION.LINEAR;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_CUBIC = D2D1_INTERPOLATION_MODE_DEFINITION.CUBIC;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_MULTI_SAMPLE_LINEAR = D2D1_INTERPOLATION_MODE_DEFINITION.MULTI_SAMPLE_LINEAR;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_ANISOTROPIC = D2D1_INTERPOLATION_MODE_DEFINITION.ANISOTROPIC;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_HIGH_QUALITY_CUBIC = D2D1_INTERPOLATION_MODE_DEFINITION.HIGH_QUALITY_CUBIC;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_FANT = D2D1_INTERPOLATION_MODE_DEFINITION.FANT;
pub const D2D1_INTERPOLATION_MODE_DEFINITION_MIPMAP_LINEAR = D2D1_INTERPOLATION_MODE_DEFINITION.MIPMAP_LINEAR;

pub const D2D1_GAMMA = enum(u32) {
    @"2_2" = 0,
    @"1_0" = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GAMMA_2_2 = D2D1_GAMMA.@"2_2";
pub const D2D1_GAMMA_1_0 = D2D1_GAMMA.@"1_0";
pub const D2D1_GAMMA_FORCE_DWORD = D2D1_GAMMA.FORCE_DWORD;

pub const D2D1_OPACITY_MASK_CONTENT = enum(u32) {
    GRAPHICS = 0,
    TEXT_NATURAL = 1,
    TEXT_GDI_COMPATIBLE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_OPACITY_MASK_CONTENT_GRAPHICS = D2D1_OPACITY_MASK_CONTENT.GRAPHICS;
pub const D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL = D2D1_OPACITY_MASK_CONTENT.TEXT_NATURAL;
pub const D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE = D2D1_OPACITY_MASK_CONTENT.TEXT_GDI_COMPATIBLE;
pub const D2D1_OPACITY_MASK_CONTENT_FORCE_DWORD = D2D1_OPACITY_MASK_CONTENT.FORCE_DWORD;

pub const D2D1_EXTEND_MODE = enum(u32) {
    CLAMP = 0,
    WRAP = 1,
    MIRROR = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_EXTEND_MODE_CLAMP = D2D1_EXTEND_MODE.CLAMP;
pub const D2D1_EXTEND_MODE_WRAP = D2D1_EXTEND_MODE.WRAP;
pub const D2D1_EXTEND_MODE_MIRROR = D2D1_EXTEND_MODE.MIRROR;
pub const D2D1_EXTEND_MODE_FORCE_DWORD = D2D1_EXTEND_MODE.FORCE_DWORD;

pub const D2D1_ANTIALIAS_MODE = enum(u32) {
    PER_PRIMITIVE = 0,
    ALIASED = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_ANTIALIAS_MODE_PER_PRIMITIVE = D2D1_ANTIALIAS_MODE.PER_PRIMITIVE;
pub const D2D1_ANTIALIAS_MODE_ALIASED = D2D1_ANTIALIAS_MODE.ALIASED;
pub const D2D1_ANTIALIAS_MODE_FORCE_DWORD = D2D1_ANTIALIAS_MODE.FORCE_DWORD;

pub const D2D1_TEXT_ANTIALIAS_MODE = enum(u32) {
    DEFAULT = 0,
    CLEARTYPE = 1,
    GRAYSCALE = 2,
    ALIASED = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_TEXT_ANTIALIAS_MODE_DEFAULT = D2D1_TEXT_ANTIALIAS_MODE.DEFAULT;
pub const D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE = D2D1_TEXT_ANTIALIAS_MODE.CLEARTYPE;
pub const D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE = D2D1_TEXT_ANTIALIAS_MODE.GRAYSCALE;
pub const D2D1_TEXT_ANTIALIAS_MODE_ALIASED = D2D1_TEXT_ANTIALIAS_MODE.ALIASED;
pub const D2D1_TEXT_ANTIALIAS_MODE_FORCE_DWORD = D2D1_TEXT_ANTIALIAS_MODE.FORCE_DWORD;

pub const D2D1_BITMAP_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_BITMAP_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_BITMAP_INTERPOLATION_MODE_LINEAR = D2D1_BITMAP_INTERPOLATION_MODE.LINEAR;
pub const D2D1_BITMAP_INTERPOLATION_MODE_FORCE_DWORD = D2D1_BITMAP_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_DRAW_TEXT_OPTIONS = enum(u32) {
    NO_SNAP = 1,
    CLIP = 2,
    ENABLE_COLOR_FONT = 4,
    DISABLE_COLOR_BITMAP_SNAPPING = 8,
    NONE = 0,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NO_SNAP: u1 = 0,
        CLIP: u1 = 0,
        ENABLE_COLOR_FONT: u1 = 0,
        DISABLE_COLOR_BITMAP_SNAPPING: u1 = 0,
        NONE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_DRAW_TEXT_OPTIONS {
        return @as(D2D1_DRAW_TEXT_OPTIONS, @enumFromInt(
              (if (o.NO_SNAP == 1) @intFromEnum(D2D1_DRAW_TEXT_OPTIONS.NO_SNAP) else 0)
            | (if (o.CLIP == 1) @intFromEnum(D2D1_DRAW_TEXT_OPTIONS.CLIP) else 0)
            | (if (o.ENABLE_COLOR_FONT == 1) @intFromEnum(D2D1_DRAW_TEXT_OPTIONS.ENABLE_COLOR_FONT) else 0)
            | (if (o.DISABLE_COLOR_BITMAP_SNAPPING == 1) @intFromEnum(D2D1_DRAW_TEXT_OPTIONS.DISABLE_COLOR_BITMAP_SNAPPING) else 0)
            | (if (o.NONE == 1) @intFromEnum(D2D1_DRAW_TEXT_OPTIONS.NONE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_DRAW_TEXT_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_DRAW_TEXT_OPTIONS_NO_SNAP = D2D1_DRAW_TEXT_OPTIONS.NO_SNAP;
pub const D2D1_DRAW_TEXT_OPTIONS_CLIP = D2D1_DRAW_TEXT_OPTIONS.CLIP;
pub const D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT = D2D1_DRAW_TEXT_OPTIONS.ENABLE_COLOR_FONT;
pub const D2D1_DRAW_TEXT_OPTIONS_DISABLE_COLOR_BITMAP_SNAPPING = D2D1_DRAW_TEXT_OPTIONS.DISABLE_COLOR_BITMAP_SNAPPING;
pub const D2D1_DRAW_TEXT_OPTIONS_NONE = D2D1_DRAW_TEXT_OPTIONS.NONE;
pub const D2D1_DRAW_TEXT_OPTIONS_FORCE_DWORD = D2D1_DRAW_TEXT_OPTIONS.FORCE_DWORD;

pub const D2D1_BITMAP_PROPERTIES = extern struct {
    pixelFormat: D2D1_PIXEL_FORMAT,
    dpiX: f32,
    dpiY: f32,
};

pub const D2D1_GRADIENT_STOP = extern struct {
    position: f32,
    color: D2D1_COLOR_F,
};

pub const D2D1_BRUSH_PROPERTIES = extern struct {
    opacity: f32,
    transform: D2D_MATRIX_3X2_F,
};

pub const D2D1_BITMAP_BRUSH_PROPERTIES = extern struct {
    extendModeX: D2D1_EXTEND_MODE,
    extendModeY: D2D1_EXTEND_MODE,
    interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
};

pub const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES = extern struct {
    startPoint: D2D_POINT_2F,
    endPoint: D2D_POINT_2F,
};

pub const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES = extern struct {
    center: D2D_POINT_2F,
    gradientOriginOffset: D2D_POINT_2F,
    radiusX: f32,
    radiusY: f32,
};

pub const D2D1_ARC_SIZE = enum(u32) {
    SMALL = 0,
    LARGE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_ARC_SIZE_SMALL = D2D1_ARC_SIZE.SMALL;
pub const D2D1_ARC_SIZE_LARGE = D2D1_ARC_SIZE.LARGE;
pub const D2D1_ARC_SIZE_FORCE_DWORD = D2D1_ARC_SIZE.FORCE_DWORD;

pub const D2D1_CAP_STYLE = enum(u32) {
    FLAT = 0,
    SQUARE = 1,
    ROUND = 2,
    TRIANGLE = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CAP_STYLE_FLAT = D2D1_CAP_STYLE.FLAT;
pub const D2D1_CAP_STYLE_SQUARE = D2D1_CAP_STYLE.SQUARE;
pub const D2D1_CAP_STYLE_ROUND = D2D1_CAP_STYLE.ROUND;
pub const D2D1_CAP_STYLE_TRIANGLE = D2D1_CAP_STYLE.TRIANGLE;
pub const D2D1_CAP_STYLE_FORCE_DWORD = D2D1_CAP_STYLE.FORCE_DWORD;

pub const D2D1_DASH_STYLE = enum(u32) {
    SOLID = 0,
    DASH = 1,
    DOT = 2,
    DASH_DOT = 3,
    DASH_DOT_DOT = 4,
    CUSTOM = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DASH_STYLE_SOLID = D2D1_DASH_STYLE.SOLID;
pub const D2D1_DASH_STYLE_DASH = D2D1_DASH_STYLE.DASH;
pub const D2D1_DASH_STYLE_DOT = D2D1_DASH_STYLE.DOT;
pub const D2D1_DASH_STYLE_DASH_DOT = D2D1_DASH_STYLE.DASH_DOT;
pub const D2D1_DASH_STYLE_DASH_DOT_DOT = D2D1_DASH_STYLE.DASH_DOT_DOT;
pub const D2D1_DASH_STYLE_CUSTOM = D2D1_DASH_STYLE.CUSTOM;
pub const D2D1_DASH_STYLE_FORCE_DWORD = D2D1_DASH_STYLE.FORCE_DWORD;

pub const D2D1_LINE_JOIN = enum(u32) {
    MITER = 0,
    BEVEL = 1,
    ROUND = 2,
    MITER_OR_BEVEL = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_LINE_JOIN_MITER = D2D1_LINE_JOIN.MITER;
pub const D2D1_LINE_JOIN_BEVEL = D2D1_LINE_JOIN.BEVEL;
pub const D2D1_LINE_JOIN_ROUND = D2D1_LINE_JOIN.ROUND;
pub const D2D1_LINE_JOIN_MITER_OR_BEVEL = D2D1_LINE_JOIN.MITER_OR_BEVEL;
pub const D2D1_LINE_JOIN_FORCE_DWORD = D2D1_LINE_JOIN.FORCE_DWORD;

pub const D2D1_COMBINE_MODE = enum(u32) {
    UNION = 0,
    INTERSECT = 1,
    XOR = 2,
    EXCLUDE = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COMBINE_MODE_UNION = D2D1_COMBINE_MODE.UNION;
pub const D2D1_COMBINE_MODE_INTERSECT = D2D1_COMBINE_MODE.INTERSECT;
pub const D2D1_COMBINE_MODE_XOR = D2D1_COMBINE_MODE.XOR;
pub const D2D1_COMBINE_MODE_EXCLUDE = D2D1_COMBINE_MODE.EXCLUDE;
pub const D2D1_COMBINE_MODE_FORCE_DWORD = D2D1_COMBINE_MODE.FORCE_DWORD;

pub const D2D1_GEOMETRY_RELATION = enum(u32) {
    UNKNOWN = 0,
    DISJOINT = 1,
    IS_CONTAINED = 2,
    CONTAINS = 3,
    OVERLAP = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GEOMETRY_RELATION_UNKNOWN = D2D1_GEOMETRY_RELATION.UNKNOWN;
pub const D2D1_GEOMETRY_RELATION_DISJOINT = D2D1_GEOMETRY_RELATION.DISJOINT;
pub const D2D1_GEOMETRY_RELATION_IS_CONTAINED = D2D1_GEOMETRY_RELATION.IS_CONTAINED;
pub const D2D1_GEOMETRY_RELATION_CONTAINS = D2D1_GEOMETRY_RELATION.CONTAINS;
pub const D2D1_GEOMETRY_RELATION_OVERLAP = D2D1_GEOMETRY_RELATION.OVERLAP;
pub const D2D1_GEOMETRY_RELATION_FORCE_DWORD = D2D1_GEOMETRY_RELATION.FORCE_DWORD;

pub const D2D1_GEOMETRY_SIMPLIFICATION_OPTION = enum(u32) {
    CUBICS_AND_LINES = 0,
    LINES = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES = D2D1_GEOMETRY_SIMPLIFICATION_OPTION.CUBICS_AND_LINES;
pub const D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES = D2D1_GEOMETRY_SIMPLIFICATION_OPTION.LINES;
pub const D2D1_GEOMETRY_SIMPLIFICATION_OPTION_FORCE_DWORD = D2D1_GEOMETRY_SIMPLIFICATION_OPTION.FORCE_DWORD;

pub const D2D1_TRIANGLE = extern struct {
    point1: D2D_POINT_2F,
    point2: D2D_POINT_2F,
    point3: D2D_POINT_2F,
};

pub const D2D1_SWEEP_DIRECTION = enum(u32) {
    COUNTER_CLOCKWISE = 0,
    CLOCKWISE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE = D2D1_SWEEP_DIRECTION.COUNTER_CLOCKWISE;
pub const D2D1_SWEEP_DIRECTION_CLOCKWISE = D2D1_SWEEP_DIRECTION.CLOCKWISE;
pub const D2D1_SWEEP_DIRECTION_FORCE_DWORD = D2D1_SWEEP_DIRECTION.FORCE_DWORD;

pub const D2D1_ARC_SEGMENT = extern struct {
    point: D2D_POINT_2F,
    size: D2D_SIZE_F,
    rotationAngle: f32,
    sweepDirection: D2D1_SWEEP_DIRECTION,
    arcSize: D2D1_ARC_SIZE,
};

pub const D2D1_QUADRATIC_BEZIER_SEGMENT = extern struct {
    point1: D2D_POINT_2F,
    point2: D2D_POINT_2F,
};

pub const D2D1_ELLIPSE = extern struct {
    point: D2D_POINT_2F,
    radiusX: f32,
    radiusY: f32,
};

pub const D2D1_ROUNDED_RECT = extern struct {
    rect: D2D_RECT_F,
    radiusX: f32,
    radiusY: f32,
};

pub const D2D1_STROKE_STYLE_PROPERTIES = extern struct {
    startCap: D2D1_CAP_STYLE,
    endCap: D2D1_CAP_STYLE,
    dashCap: D2D1_CAP_STYLE,
    lineJoin: D2D1_LINE_JOIN,
    miterLimit: f32,
    dashStyle: D2D1_DASH_STYLE,
    dashOffset: f32,
};

pub const D2D1_LAYER_OPTIONS = enum(u32) {
    NONE = 0,
    INITIALIZE_FOR_CLEARTYPE = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        INITIALIZE_FOR_CLEARTYPE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_LAYER_OPTIONS {
        return @as(D2D1_LAYER_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_LAYER_OPTIONS.NONE) else 0)
            | (if (o.INITIALIZE_FOR_CLEARTYPE == 1) @intFromEnum(D2D1_LAYER_OPTIONS.INITIALIZE_FOR_CLEARTYPE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_LAYER_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_LAYER_OPTIONS_NONE = D2D1_LAYER_OPTIONS.NONE;
pub const D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE = D2D1_LAYER_OPTIONS.INITIALIZE_FOR_CLEARTYPE;
pub const D2D1_LAYER_OPTIONS_FORCE_DWORD = D2D1_LAYER_OPTIONS.FORCE_DWORD;

pub const D2D1_LAYER_PARAMETERS = extern struct {
    contentBounds: D2D_RECT_F,
    geometricMask: ?*ID2D1Geometry,
    maskAntialiasMode: D2D1_ANTIALIAS_MODE,
    maskTransform: D2D_MATRIX_3X2_F,
    opacity: f32,
    opacityBrush: ?*ID2D1Brush,
    layerOptions: D2D1_LAYER_OPTIONS,
};

pub const D2D1_WINDOW_STATE = enum(u32) {
    NONE = 0,
    OCCLUDED = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        OCCLUDED: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_WINDOW_STATE {
        return @as(D2D1_WINDOW_STATE, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_WINDOW_STATE.NONE) else 0)
            | (if (o.OCCLUDED == 1) @intFromEnum(D2D1_WINDOW_STATE.OCCLUDED) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_WINDOW_STATE.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_WINDOW_STATE_NONE = D2D1_WINDOW_STATE.NONE;
pub const D2D1_WINDOW_STATE_OCCLUDED = D2D1_WINDOW_STATE.OCCLUDED;
pub const D2D1_WINDOW_STATE_FORCE_DWORD = D2D1_WINDOW_STATE.FORCE_DWORD;

pub const D2D1_RENDER_TARGET_TYPE = enum(u32) {
    DEFAULT = 0,
    SOFTWARE = 1,
    HARDWARE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_RENDER_TARGET_TYPE_DEFAULT = D2D1_RENDER_TARGET_TYPE.DEFAULT;
pub const D2D1_RENDER_TARGET_TYPE_SOFTWARE = D2D1_RENDER_TARGET_TYPE.SOFTWARE;
pub const D2D1_RENDER_TARGET_TYPE_HARDWARE = D2D1_RENDER_TARGET_TYPE.HARDWARE;
pub const D2D1_RENDER_TARGET_TYPE_FORCE_DWORD = D2D1_RENDER_TARGET_TYPE.FORCE_DWORD;

pub const D2D1_FEATURE_LEVEL = enum(u32) {
    DEFAULT = 0,
    @"9" = 37120,
    @"10" = 40960,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_FEATURE_LEVEL_DEFAULT = D2D1_FEATURE_LEVEL.DEFAULT;
pub const D2D1_FEATURE_LEVEL_9 = D2D1_FEATURE_LEVEL.@"9";
pub const D2D1_FEATURE_LEVEL_10 = D2D1_FEATURE_LEVEL.@"10";
pub const D2D1_FEATURE_LEVEL_FORCE_DWORD = D2D1_FEATURE_LEVEL.FORCE_DWORD;

pub const D2D1_RENDER_TARGET_USAGE = enum(u32) {
    NONE = 0,
    FORCE_BITMAP_REMOTING = 1,
    GDI_COMPATIBLE = 2,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        FORCE_BITMAP_REMOTING: u1 = 0,
        GDI_COMPATIBLE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_RENDER_TARGET_USAGE {
        return @as(D2D1_RENDER_TARGET_USAGE, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_RENDER_TARGET_USAGE.NONE) else 0)
            | (if (o.FORCE_BITMAP_REMOTING == 1) @intFromEnum(D2D1_RENDER_TARGET_USAGE.FORCE_BITMAP_REMOTING) else 0)
            | (if (o.GDI_COMPATIBLE == 1) @intFromEnum(D2D1_RENDER_TARGET_USAGE.GDI_COMPATIBLE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_RENDER_TARGET_USAGE.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_RENDER_TARGET_USAGE_NONE = D2D1_RENDER_TARGET_USAGE.NONE;
pub const D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING = D2D1_RENDER_TARGET_USAGE.FORCE_BITMAP_REMOTING;
pub const D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE = D2D1_RENDER_TARGET_USAGE.GDI_COMPATIBLE;
pub const D2D1_RENDER_TARGET_USAGE_FORCE_DWORD = D2D1_RENDER_TARGET_USAGE.FORCE_DWORD;

pub const D2D1_PRESENT_OPTIONS = enum(u32) {
    NONE = 0,
    RETAIN_CONTENTS = 1,
    IMMEDIATELY = 2,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        RETAIN_CONTENTS: u1 = 0,
        IMMEDIATELY: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_PRESENT_OPTIONS {
        return @as(D2D1_PRESENT_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_PRESENT_OPTIONS.NONE) else 0)
            | (if (o.RETAIN_CONTENTS == 1) @intFromEnum(D2D1_PRESENT_OPTIONS.RETAIN_CONTENTS) else 0)
            | (if (o.IMMEDIATELY == 1) @intFromEnum(D2D1_PRESENT_OPTIONS.IMMEDIATELY) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_PRESENT_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_PRESENT_OPTIONS_NONE = D2D1_PRESENT_OPTIONS.NONE;
pub const D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS = D2D1_PRESENT_OPTIONS.RETAIN_CONTENTS;
pub const D2D1_PRESENT_OPTIONS_IMMEDIATELY = D2D1_PRESENT_OPTIONS.IMMEDIATELY;
pub const D2D1_PRESENT_OPTIONS_FORCE_DWORD = D2D1_PRESENT_OPTIONS.FORCE_DWORD;

pub const D2D1_RENDER_TARGET_PROPERTIES = extern struct {
    type: D2D1_RENDER_TARGET_TYPE,
    pixelFormat: D2D1_PIXEL_FORMAT,
    dpiX: f32,
    dpiY: f32,
    usage: D2D1_RENDER_TARGET_USAGE,
    minLevel: D2D1_FEATURE_LEVEL,
};

pub const D2D1_HWND_RENDER_TARGET_PROPERTIES = extern struct {
    hwnd: ?HWND,
    pixelSize: D2D_SIZE_U,
    presentOptions: D2D1_PRESENT_OPTIONS,
};

pub const D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS = enum(u32) {
    NONE = 0,
    GDI_COMPATIBLE = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        GDI_COMPATIBLE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS {
        return @as(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS.NONE) else 0)
            | (if (o.GDI_COMPATIBLE == 1) @intFromEnum(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS.GDI_COMPATIBLE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE = D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS.NONE;
pub const D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE = D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS.GDI_COMPATIBLE;
pub const D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_FORCE_DWORD = D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS.FORCE_DWORD;

pub const D2D1_DRAWING_STATE_DESCRIPTION = extern struct {
    antialiasMode: D2D1_ANTIALIAS_MODE,
    textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE,
    tag1: u64,
    tag2: u64,
    transform: D2D_MATRIX_3X2_F,
};

pub const D2D1_DC_INITIALIZE_MODE = enum(u32) {
    COPY = 0,
    CLEAR = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DC_INITIALIZE_MODE_COPY = D2D1_DC_INITIALIZE_MODE.COPY;
pub const D2D1_DC_INITIALIZE_MODE_CLEAR = D2D1_DC_INITIALIZE_MODE.CLEAR;
pub const D2D1_DC_INITIALIZE_MODE_FORCE_DWORD = D2D1_DC_INITIALIZE_MODE.FORCE_DWORD;

pub const D2D1_DEBUG_LEVEL = enum(u32) {
    NONE = 0,
    ERROR = 1,
    WARNING = 2,
    INFORMATION = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DEBUG_LEVEL_NONE = D2D1_DEBUG_LEVEL.NONE;
pub const D2D1_DEBUG_LEVEL_ERROR = D2D1_DEBUG_LEVEL.ERROR;
pub const D2D1_DEBUG_LEVEL_WARNING = D2D1_DEBUG_LEVEL.WARNING;
pub const D2D1_DEBUG_LEVEL_INFORMATION = D2D1_DEBUG_LEVEL.INFORMATION;
pub const D2D1_DEBUG_LEVEL_FORCE_DWORD = D2D1_DEBUG_LEVEL.FORCE_DWORD;

pub const D2D1_FACTORY_TYPE = enum(u32) {
    SINGLE_THREADED = 0,
    MULTI_THREADED = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_FACTORY_TYPE_SINGLE_THREADED = D2D1_FACTORY_TYPE.SINGLE_THREADED;
pub const D2D1_FACTORY_TYPE_MULTI_THREADED = D2D1_FACTORY_TYPE.MULTI_THREADED;
pub const D2D1_FACTORY_TYPE_FORCE_DWORD = D2D1_FACTORY_TYPE.FORCE_DWORD;

pub const D2D1_FACTORY_OPTIONS = extern struct {
    debugLevel: D2D1_DEBUG_LEVEL,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Resource_Value = Guid.initString("2cd90691-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1Resource = &IID_ID2D1Resource_Value;
pub const ID2D1Resource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFactory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Resource,
                factory: ?*?*ID2D1Factory,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Resource,
                factory: ?*?*ID2D1Factory,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Resource_GetFactory(self: *const T, factory: ?*?*ID2D1Factory) callconv(.Inline) void {
            return @as(*const ID2D1Resource.VTable, @ptrCast(self.vtable)).GetFactory(@as(*const ID2D1Resource, @ptrCast(self)), factory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Image_Value = Guid.initString("65019f75-8da2-497c-b32c-dfa34e48ede6");
pub const IID_ID2D1Image = &IID_ID2D1Image_Value;
pub const ID2D1Image = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Bitmap_Value = Guid.initString("a2296057-ea42-4099-983b-539fb6505426");
pub const IID_ID2D1Bitmap = &IID_ID2D1Bitmap_Value;
pub const ID2D1Bitmap = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Image.VTable,
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
            else => *const fn(
                self: *const ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
        },
        GetPixelSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_U,
            else => *const fn(
                self: *const ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_U,
        },
        GetPixelFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PIXEL_FORMAT,
            else => *const fn(
                self: *const ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PIXEL_FORMAT,
        },
        GetDpi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Bitmap,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CopyFromBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
                destPoint: ?*const D2D_POINT_2U,
                bitmap: ?*ID2D1Bitmap,
                srcRect: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Bitmap,
                destPoint: ?*const D2D_POINT_2U,
                bitmap: ?*ID2D1Bitmap,
                srcRect: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyFromRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
                destPoint: ?*const D2D_POINT_2U,
                renderTarget: ?*ID2D1RenderTarget,
                srcRect: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Bitmap,
                destPoint: ?*const D2D_POINT_2U,
                renderTarget: ?*ID2D1RenderTarget,
                srcRect: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyFromMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap,
                dstRect: ?*const D2D_RECT_U,
                srcData: ?*const anyopaque,
                pitch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Bitmap,
                dstRect: ?*const D2D_RECT_U,
                srcData: ?*const anyopaque,
                pitch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Image.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_GetSize(self: *const T) callconv(.Inline) D2D_SIZE_F {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).GetSize(@as(*const ID2D1Bitmap, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_GetPixelSize(self: *const T) callconv(.Inline) D2D_SIZE_U {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).GetPixelSize(@as(*const ID2D1Bitmap, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_GetPixelFormat(self: *const T) callconv(.Inline) D2D1_PIXEL_FORMAT {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).GetPixelFormat(@as(*const ID2D1Bitmap, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_GetDpi(self: *const T, dpiX: ?*f32, dpiY: ?*f32) callconv(.Inline) void {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).GetDpi(@as(*const ID2D1Bitmap, @ptrCast(self)), dpiX, dpiY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_CopyFromBitmap(self: *const T, destPoint: ?*const D2D_POINT_2U, bitmap: ?*ID2D1Bitmap, srcRect: ?*const D2D_RECT_U) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).CopyFromBitmap(@as(*const ID2D1Bitmap, @ptrCast(self)), destPoint, bitmap, srcRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_CopyFromRenderTarget(self: *const T, destPoint: ?*const D2D_POINT_2U, renderTarget: ?*ID2D1RenderTarget, srcRect: ?*const D2D_RECT_U) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).CopyFromRenderTarget(@as(*const ID2D1Bitmap, @ptrCast(self)), destPoint, renderTarget, srcRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap_CopyFromMemory(self: *const T, dstRect: ?*const D2D_RECT_U, srcData: ?*const anyopaque, pitch: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Bitmap.VTable, @ptrCast(self.vtable)).CopyFromMemory(@as(*const ID2D1Bitmap, @ptrCast(self)), dstRect, srcData, pitch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1GradientStopCollection_Value = Guid.initString("2cd906a7-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1GradientStopCollection = &IID_ID2D1GradientStopCollection_Value;
pub const ID2D1GradientStopCollection = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetGradientStopCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetGradientStops: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection,
                gradientStops: [*]D2D1_GRADIENT_STOP,
                gradientStopsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GradientStopCollection,
                gradientStops: [*]D2D1_GRADIENT_STOP,
                gradientStopsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetColorInterpolationGamma: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_GAMMA,
            else => *const fn(
                self: *const ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_GAMMA,
        },
        GetExtendMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection_GetGradientStopCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1GradientStopCollection.VTable, @ptrCast(self.vtable)).GetGradientStopCount(@as(*const ID2D1GradientStopCollection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection_GetGradientStops(self: *const T, gradientStops: [*]D2D1_GRADIENT_STOP, gradientStopsCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1GradientStopCollection.VTable, @ptrCast(self.vtable)).GetGradientStops(@as(*const ID2D1GradientStopCollection, @ptrCast(self)), gradientStops, gradientStopsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection_GetColorInterpolationGamma(self: *const T) callconv(.Inline) D2D1_GAMMA {
            return @as(*const ID2D1GradientStopCollection.VTable, @ptrCast(self.vtable)).GetColorInterpolationGamma(@as(*const ID2D1GradientStopCollection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection_GetExtendMode(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1GradientStopCollection.VTable, @ptrCast(self.vtable)).GetExtendMode(@as(*const ID2D1GradientStopCollection, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Brush_Value = Guid.initString("2cd906a8-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1Brush = &IID_ID2D1Brush_Value;
pub const ID2D1Brush = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        SetOpacity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Brush,
                opacity: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Brush,
                opacity: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Brush,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Brush,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetOpacity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) f32,
            else => *const fn(
                self: *const ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) f32,
        },
        GetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Brush,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Brush,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Brush_SetOpacity(self: *const T, opacity: f32) callconv(.Inline) void {
            return @as(*const ID2D1Brush.VTable, @ptrCast(self.vtable)).SetOpacity(@as(*const ID2D1Brush, @ptrCast(self)), opacity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Brush_SetTransform(self: *const T, transform: ?*const D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1Brush.VTable, @ptrCast(self.vtable)).SetTransform(@as(*const ID2D1Brush, @ptrCast(self)), transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Brush_GetOpacity(self: *const T) callconv(.Inline) f32 {
            return @as(*const ID2D1Brush.VTable, @ptrCast(self.vtable)).GetOpacity(@as(*const ID2D1Brush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Brush_GetTransform(self: *const T, transform: ?*D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1Brush.VTable, @ptrCast(self.vtable)).GetTransform(@as(*const ID2D1Brush, @ptrCast(self)), transform);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1BitmapBrush_Value = Guid.initString("2cd906aa-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1BitmapBrush = &IID_ID2D1BitmapBrush_Value;
pub const ID2D1BitmapBrush = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Brush.VTable,
        SetExtendModeX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
                extendModeX: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
                extendModeX: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetExtendModeY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
                extendModeY: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
                extendModeY: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetInterpolationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
                bitmap: ?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
                bitmap: ?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetExtendModeX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
        GetExtendModeY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
        GetInterpolationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_BITMAP_INTERPOLATION_MODE,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_BITMAP_INTERPOLATION_MODE,
        },
        GetBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BitmapBrush,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Brush.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_SetExtendModeX(self: *const T, extendModeX: D2D1_EXTEND_MODE) callconv(.Inline) void {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).SetExtendModeX(@as(*const ID2D1BitmapBrush, @ptrCast(self)), extendModeX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_SetExtendModeY(self: *const T, extendModeY: D2D1_EXTEND_MODE) callconv(.Inline) void {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).SetExtendModeY(@as(*const ID2D1BitmapBrush, @ptrCast(self)), extendModeY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_SetInterpolationMode(self: *const T, interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE) callconv(.Inline) void {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).SetInterpolationMode(@as(*const ID2D1BitmapBrush, @ptrCast(self)), interpolationMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_SetBitmap(self: *const T, bitmap: ?*ID2D1Bitmap) callconv(.Inline) void {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).SetBitmap(@as(*const ID2D1BitmapBrush, @ptrCast(self)), bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_GetExtendModeX(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).GetExtendModeX(@as(*const ID2D1BitmapBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_GetExtendModeY(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).GetExtendModeY(@as(*const ID2D1BitmapBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_GetInterpolationMode(self: *const T) callconv(.Inline) D2D1_BITMAP_INTERPOLATION_MODE {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).GetInterpolationMode(@as(*const ID2D1BitmapBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush_GetBitmap(self: *const T, bitmap: ?*?*ID2D1Bitmap) callconv(.Inline) void {
            return @as(*const ID2D1BitmapBrush.VTable, @ptrCast(self.vtable)).GetBitmap(@as(*const ID2D1BitmapBrush, @ptrCast(self)), bitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1SolidColorBrush_Value = Guid.initString("2cd906a9-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1SolidColorBrush = &IID_ID2D1SolidColorBrush_Value;
pub const ID2D1SolidColorBrush = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Brush.VTable,
        SetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SolidColorBrush,
                color: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SolidColorBrush,
                color: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SolidColorBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_F,
            else => *const fn(
                self: *const ID2D1SolidColorBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_F,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Brush.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SolidColorBrush_SetColor(self: *const T, color: ?*const D2D1_COLOR_F) callconv(.Inline) void {
            return @as(*const ID2D1SolidColorBrush.VTable, @ptrCast(self.vtable)).SetColor(@as(*const ID2D1SolidColorBrush, @ptrCast(self)), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SolidColorBrush_GetColor(self: *const T) callconv(.Inline) D2D1_COLOR_F {
            return @as(*const ID2D1SolidColorBrush.VTable, @ptrCast(self.vtable)).GetColor(@as(*const ID2D1SolidColorBrush, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1LinearGradientBrush_Value = Guid.initString("2cd906ab-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1LinearGradientBrush = &IID_ID2D1LinearGradientBrush_Value;
pub const ID2D1LinearGradientBrush = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Brush.VTable,
        SetStartPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1LinearGradientBrush,
                startPoint: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1LinearGradientBrush,
                startPoint: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetEndPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1LinearGradientBrush,
                endPoint: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1LinearGradientBrush,
                endPoint: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetStartPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1LinearGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
            else => *const fn(
                self: *const ID2D1LinearGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
        },
        GetEndPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1LinearGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
            else => *const fn(
                self: *const ID2D1LinearGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
        },
        GetGradientStopCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1LinearGradientBrush,
                gradientStopCollection: ?*?*ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1LinearGradientBrush,
                gradientStopCollection: ?*?*ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Brush.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1LinearGradientBrush_SetStartPoint(self: *const T, startPoint: D2D_POINT_2F) callconv(.Inline) void {
            return @as(*const ID2D1LinearGradientBrush.VTable, @ptrCast(self.vtable)).SetStartPoint(@as(*const ID2D1LinearGradientBrush, @ptrCast(self)), startPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1LinearGradientBrush_SetEndPoint(self: *const T, endPoint: D2D_POINT_2F) callconv(.Inline) void {
            return @as(*const ID2D1LinearGradientBrush.VTable, @ptrCast(self.vtable)).SetEndPoint(@as(*const ID2D1LinearGradientBrush, @ptrCast(self)), endPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1LinearGradientBrush_GetStartPoint(self: *const T) callconv(.Inline) D2D_POINT_2F {
            return @as(*const ID2D1LinearGradientBrush.VTable, @ptrCast(self.vtable)).GetStartPoint(@as(*const ID2D1LinearGradientBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1LinearGradientBrush_GetEndPoint(self: *const T) callconv(.Inline) D2D_POINT_2F {
            return @as(*const ID2D1LinearGradientBrush.VTable, @ptrCast(self.vtable)).GetEndPoint(@as(*const ID2D1LinearGradientBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1LinearGradientBrush_GetGradientStopCollection(self: *const T, gradientStopCollection: ?*?*ID2D1GradientStopCollection) callconv(.Inline) void {
            return @as(*const ID2D1LinearGradientBrush.VTable, @ptrCast(self.vtable)).GetGradientStopCollection(@as(*const ID2D1LinearGradientBrush, @ptrCast(self)), gradientStopCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1RadialGradientBrush_Value = Guid.initString("2cd906ac-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1RadialGradientBrush = &IID_ID2D1RadialGradientBrush_Value;
pub const ID2D1RadialGradientBrush = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Brush.VTable,
        SetCenter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
                center: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
                center: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetGradientOriginOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
                gradientOriginOffset: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
                gradientOriginOffset: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetRadiusX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
                radiusX: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
                radiusX: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetRadiusY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
                radiusY: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
                radiusY: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetCenter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
        },
        GetGradientOriginOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D_POINT_2F,
        },
        GetRadiusX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) f32,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) f32,
        },
        GetRadiusY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) f32,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) f32,
        },
        GetGradientStopCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RadialGradientBrush,
                gradientStopCollection: ?*?*ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RadialGradientBrush,
                gradientStopCollection: ?*?*ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Brush.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_SetCenter(self: *const T, center: D2D_POINT_2F) callconv(.Inline) void {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).SetCenter(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)), center);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_SetGradientOriginOffset(self: *const T, gradientOriginOffset: D2D_POINT_2F) callconv(.Inline) void {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).SetGradientOriginOffset(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)), gradientOriginOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_SetRadiusX(self: *const T, radiusX: f32) callconv(.Inline) void {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).SetRadiusX(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)), radiusX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_SetRadiusY(self: *const T, radiusY: f32) callconv(.Inline) void {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).SetRadiusY(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)), radiusY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_GetCenter(self: *const T) callconv(.Inline) D2D_POINT_2F {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).GetCenter(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_GetGradientOriginOffset(self: *const T) callconv(.Inline) D2D_POINT_2F {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).GetGradientOriginOffset(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_GetRadiusX(self: *const T) callconv(.Inline) f32 {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).GetRadiusX(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_GetRadiusY(self: *const T) callconv(.Inline) f32 {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).GetRadiusY(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RadialGradientBrush_GetGradientStopCollection(self: *const T, gradientStopCollection: ?*?*ID2D1GradientStopCollection) callconv(.Inline) void {
            return @as(*const ID2D1RadialGradientBrush.VTable, @ptrCast(self.vtable)).GetGradientStopCollection(@as(*const ID2D1RadialGradientBrush, @ptrCast(self)), gradientStopCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1StrokeStyle_Value = Guid.initString("2cd9069d-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1StrokeStyle = &IID_ID2D1StrokeStyle_Value;
pub const ID2D1StrokeStyle = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetStartCap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_CAP_STYLE,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_CAP_STYLE,
        },
        GetEndCap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_CAP_STYLE,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_CAP_STYLE,
        },
        GetDashCap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_CAP_STYLE,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_CAP_STYLE,
        },
        GetMiterLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) f32,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) f32,
        },
        GetLineJoin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_LINE_JOIN,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_LINE_JOIN,
        },
        GetDashOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) f32,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) f32,
        },
        GetDashStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_DASH_STYLE,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_DASH_STYLE,
        },
        GetDashesCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetDashes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle,
                dashes: [*]f32,
                dashesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1StrokeStyle,
                dashes: [*]f32,
                dashesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetStartCap(self: *const T) callconv(.Inline) D2D1_CAP_STYLE {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetStartCap(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetEndCap(self: *const T) callconv(.Inline) D2D1_CAP_STYLE {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetEndCap(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetDashCap(self: *const T) callconv(.Inline) D2D1_CAP_STYLE {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetDashCap(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetMiterLimit(self: *const T) callconv(.Inline) f32 {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetMiterLimit(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetLineJoin(self: *const T) callconv(.Inline) D2D1_LINE_JOIN {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetLineJoin(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetDashOffset(self: *const T) callconv(.Inline) f32 {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetDashOffset(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetDashStyle(self: *const T) callconv(.Inline) D2D1_DASH_STYLE {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetDashStyle(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetDashesCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetDashesCount(@as(*const ID2D1StrokeStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle_GetDashes(self: *const T, dashes: [*]f32, dashesCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1StrokeStyle.VTable, @ptrCast(self.vtable)).GetDashes(@as(*const ID2D1StrokeStyle, @ptrCast(self)), dashes, dashesCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Geometry_Value = Guid.initString("2cd906a1-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1Geometry = &IID_ID2D1Geometry_Value;
pub const ID2D1Geometry = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWidenedBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrokeContainsPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                point: D2D_POINT_2F,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                contains: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                point: D2D_POINT_2F,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                contains: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillContainsPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                point: D2D_POINT_2F,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                contains: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                point: D2D_POINT_2F,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                contains: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareWithGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                inputGeometry: ?*ID2D1Geometry,
                inputGeometryTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                relation: ?*D2D1_GEOMETRY_RELATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                inputGeometry: ?*ID2D1Geometry,
                inputGeometryTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                relation: ?*D2D1_GEOMETRY_RELATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Simplify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                simplificationOption: D2D1_GEOMETRY_SIMPLIFICATION_OPTION,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                simplificationOption: D2D1_GEOMETRY_SIMPLIFICATION_OPTION,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Tessellate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                tessellationSink: ?*ID2D1TessellationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                tessellationSink: ?*ID2D1TessellationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CombineWithGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                inputGeometry: ?*ID2D1Geometry,
                combineMode: D2D1_COMBINE_MODE,
                inputGeometryTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                inputGeometry: ?*ID2D1Geometry,
                combineMode: D2D1_COMBINE_MODE,
                inputGeometryTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Outline: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComputeArea: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                area: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                area: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComputeLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                length: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                length: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComputePointAtLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                length: f32,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                point: ?*D2D_POINT_2F,
                unitTangentVector: ?*D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                length: f32,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                point: ?*D2D_POINT_2F,
                unitTangentVector: ?*D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Widen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Geometry,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Geometry,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_GetBounds(self: *const T, worldTransform: ?*const D2D_MATRIX_3X2_F, bounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).GetBounds(@as(*const ID2D1Geometry, @ptrCast(self)), worldTransform, bounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_GetWidenedBounds(self: *const T, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, bounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).GetWidenedBounds(@as(*const ID2D1Geometry, @ptrCast(self)), strokeWidth, strokeStyle, worldTransform, flatteningTolerance, bounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_StrokeContainsPoint(self: *const T, point: D2D_POINT_2F, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, contains: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).StrokeContainsPoint(@as(*const ID2D1Geometry, @ptrCast(self)), point, strokeWidth, strokeStyle, worldTransform, flatteningTolerance, contains);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_FillContainsPoint(self: *const T, point: D2D_POINT_2F, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, contains: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).FillContainsPoint(@as(*const ID2D1Geometry, @ptrCast(self)), point, worldTransform, flatteningTolerance, contains);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_CompareWithGeometry(self: *const T, inputGeometry: ?*ID2D1Geometry, inputGeometryTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, relation: ?*D2D1_GEOMETRY_RELATION) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).CompareWithGeometry(@as(*const ID2D1Geometry, @ptrCast(self)), inputGeometry, inputGeometryTransform, flatteningTolerance, relation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_Simplify(self: *const T, simplificationOption: D2D1_GEOMETRY_SIMPLIFICATION_OPTION, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, geometrySink: ?*ID2D1SimplifiedGeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).Simplify(@as(*const ID2D1Geometry, @ptrCast(self)), simplificationOption, worldTransform, flatteningTolerance, geometrySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_Tessellate(self: *const T, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, tessellationSink: ?*ID2D1TessellationSink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).Tessellate(@as(*const ID2D1Geometry, @ptrCast(self)), worldTransform, flatteningTolerance, tessellationSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_CombineWithGeometry(self: *const T, inputGeometry: ?*ID2D1Geometry, combineMode: D2D1_COMBINE_MODE, inputGeometryTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, geometrySink: ?*ID2D1SimplifiedGeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).CombineWithGeometry(@as(*const ID2D1Geometry, @ptrCast(self)), inputGeometry, combineMode, inputGeometryTransform, flatteningTolerance, geometrySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_Outline(self: *const T, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, geometrySink: ?*ID2D1SimplifiedGeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).Outline(@as(*const ID2D1Geometry, @ptrCast(self)), worldTransform, flatteningTolerance, geometrySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_ComputeArea(self: *const T, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, area: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).ComputeArea(@as(*const ID2D1Geometry, @ptrCast(self)), worldTransform, flatteningTolerance, area);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_ComputeLength(self: *const T, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, length: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).ComputeLength(@as(*const ID2D1Geometry, @ptrCast(self)), worldTransform, flatteningTolerance, length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_ComputePointAtLength(self: *const T, length: f32, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, point: ?*D2D_POINT_2F, unitTangentVector: ?*D2D_POINT_2F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).ComputePointAtLength(@as(*const ID2D1Geometry, @ptrCast(self)), length, worldTransform, flatteningTolerance, point, unitTangentVector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Geometry_Widen(self: *const T, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, geometrySink: ?*ID2D1SimplifiedGeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Geometry.VTable, @ptrCast(self.vtable)).Widen(@as(*const ID2D1Geometry, @ptrCast(self)), strokeWidth, strokeStyle, worldTransform, flatteningTolerance, geometrySink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1RectangleGeometry_Value = Guid.initString("2cd906a2-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1RectangleGeometry = &IID_ID2D1RectangleGeometry_Value;
pub const ID2D1RectangleGeometry = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Geometry.VTable,
        GetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RectangleGeometry,
                rect: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RectangleGeometry,
                rect: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Geometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RectangleGeometry_GetRect(self: *const T, rect: ?*D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1RectangleGeometry.VTable, @ptrCast(self.vtable)).GetRect(@as(*const ID2D1RectangleGeometry, @ptrCast(self)), rect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1RoundedRectangleGeometry_Value = Guid.initString("2cd906a3-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1RoundedRectangleGeometry = &IID_ID2D1RoundedRectangleGeometry_Value;
pub const ID2D1RoundedRectangleGeometry = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Geometry.VTable,
        GetRoundedRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RoundedRectangleGeometry,
                roundedRect: ?*D2D1_ROUNDED_RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RoundedRectangleGeometry,
                roundedRect: ?*D2D1_ROUNDED_RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Geometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RoundedRectangleGeometry_GetRoundedRect(self: *const T, roundedRect: ?*D2D1_ROUNDED_RECT) callconv(.Inline) void {
            return @as(*const ID2D1RoundedRectangleGeometry.VTable, @ptrCast(self.vtable)).GetRoundedRect(@as(*const ID2D1RoundedRectangleGeometry, @ptrCast(self)), roundedRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1EllipseGeometry_Value = Guid.initString("2cd906a4-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1EllipseGeometry = &IID_ID2D1EllipseGeometry_Value;
pub const ID2D1EllipseGeometry = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Geometry.VTable,
        GetEllipse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EllipseGeometry,
                ellipse: ?*D2D1_ELLIPSE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1EllipseGeometry,
                ellipse: ?*D2D1_ELLIPSE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Geometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EllipseGeometry_GetEllipse(self: *const T, ellipse: ?*D2D1_ELLIPSE) callconv(.Inline) void {
            return @as(*const ID2D1EllipseGeometry.VTable, @ptrCast(self.vtable)).GetEllipse(@as(*const ID2D1EllipseGeometry, @ptrCast(self)), ellipse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1GeometryGroup_Value = Guid.initString("2cd906a6-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1GeometryGroup = &IID_ID2D1GeometryGroup_Value;
pub const ID2D1GeometryGroup = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Geometry.VTable,
        GetFillMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometryGroup,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_FILL_MODE,
            else => *const fn(
                self: *const ID2D1GeometryGroup,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_FILL_MODE,
        },
        GetSourceGeometryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometryGroup,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1GeometryGroup,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetSourceGeometries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometryGroup,
                geometries: [*]?*ID2D1Geometry,
                geometriesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GeometryGroup,
                geometries: [*]?*ID2D1Geometry,
                geometriesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Geometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometryGroup_GetFillMode(self: *const T) callconv(.Inline) D2D1_FILL_MODE {
            return @as(*const ID2D1GeometryGroup.VTable, @ptrCast(self.vtable)).GetFillMode(@as(*const ID2D1GeometryGroup, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometryGroup_GetSourceGeometryCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1GeometryGroup.VTable, @ptrCast(self.vtable)).GetSourceGeometryCount(@as(*const ID2D1GeometryGroup, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometryGroup_GetSourceGeometries(self: *const T, geometries: [*]?*ID2D1Geometry, geometriesCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1GeometryGroup.VTable, @ptrCast(self.vtable)).GetSourceGeometries(@as(*const ID2D1GeometryGroup, @ptrCast(self)), geometries, geometriesCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1TransformedGeometry_Value = Guid.initString("2cd906bb-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1TransformedGeometry = &IID_ID2D1TransformedGeometry_Value;
pub const ID2D1TransformedGeometry = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Geometry.VTable,
        GetSourceGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformedGeometry,
                sourceGeometry: ?*?*ID2D1Geometry,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1TransformedGeometry,
                sourceGeometry: ?*?*ID2D1Geometry,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformedGeometry,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1TransformedGeometry,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Geometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformedGeometry_GetSourceGeometry(self: *const T, sourceGeometry: ?*?*ID2D1Geometry) callconv(.Inline) void {
            return @as(*const ID2D1TransformedGeometry.VTable, @ptrCast(self.vtable)).GetSourceGeometry(@as(*const ID2D1TransformedGeometry, @ptrCast(self)), sourceGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformedGeometry_GetTransform(self: *const T, transform: ?*D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1TransformedGeometry.VTable, @ptrCast(self.vtable)).GetTransform(@as(*const ID2D1TransformedGeometry, @ptrCast(self)), transform);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1GeometrySink_Value = Guid.initString("2cd9069f-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1GeometrySink = &IID_ID2D1GeometrySink_Value;
pub const ID2D1GeometrySink = extern struct {
    pub const VTable = extern struct {
        base: ID2D1SimplifiedGeometrySink.VTable,
        AddLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometrySink,
                point: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GeometrySink,
                point: D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        AddBezier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometrySink,
                bezier: ?*const D2D1_BEZIER_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GeometrySink,
                bezier: ?*const D2D1_BEZIER_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        AddQuadraticBezier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometrySink,
                bezier: ?*const D2D1_QUADRATIC_BEZIER_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GeometrySink,
                bezier: ?*const D2D1_QUADRATIC_BEZIER_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        AddQuadraticBeziers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometrySink,
                beziers: [*]const D2D1_QUADRATIC_BEZIER_SEGMENT,
                beziersCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GeometrySink,
                beziers: [*]const D2D1_QUADRATIC_BEZIER_SEGMENT,
                beziersCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        AddArc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GeometrySink,
                arc: ?*const D2D1_ARC_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GeometrySink,
                arc: ?*const D2D1_ARC_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1SimplifiedGeometrySink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometrySink_AddLine(self: *const T, point: D2D_POINT_2F) callconv(.Inline) void {
            return @as(*const ID2D1GeometrySink.VTable, @ptrCast(self.vtable)).AddLine(@as(*const ID2D1GeometrySink, @ptrCast(self)), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometrySink_AddBezier(self: *const T, bezier: ?*const D2D1_BEZIER_SEGMENT) callconv(.Inline) void {
            return @as(*const ID2D1GeometrySink.VTable, @ptrCast(self.vtable)).AddBezier(@as(*const ID2D1GeometrySink, @ptrCast(self)), bezier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometrySink_AddQuadraticBezier(self: *const T, bezier: ?*const D2D1_QUADRATIC_BEZIER_SEGMENT) callconv(.Inline) void {
            return @as(*const ID2D1GeometrySink.VTable, @ptrCast(self.vtable)).AddQuadraticBezier(@as(*const ID2D1GeometrySink, @ptrCast(self)), bezier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometrySink_AddQuadraticBeziers(self: *const T, beziers: [*]const D2D1_QUADRATIC_BEZIER_SEGMENT, beziersCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1GeometrySink.VTable, @ptrCast(self.vtable)).AddQuadraticBeziers(@as(*const ID2D1GeometrySink, @ptrCast(self)), beziers, beziersCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GeometrySink_AddArc(self: *const T, arc: ?*const D2D1_ARC_SEGMENT) callconv(.Inline) void {
            return @as(*const ID2D1GeometrySink.VTable, @ptrCast(self.vtable)).AddArc(@as(*const ID2D1GeometrySink, @ptrCast(self)), arc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1TessellationSink_Value = Guid.initString("2cd906c1-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1TessellationSink = &IID_ID2D1TessellationSink_Value;
pub const ID2D1TessellationSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTriangles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TessellationSink,
                triangles: [*]const D2D1_TRIANGLE,
                trianglesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1TessellationSink,
                triangles: [*]const D2D1_TRIANGLE,
                trianglesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TessellationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TessellationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TessellationSink_AddTriangles(self: *const T, triangles: [*]const D2D1_TRIANGLE, trianglesCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1TessellationSink.VTable, @ptrCast(self.vtable)).AddTriangles(@as(*const ID2D1TessellationSink, @ptrCast(self)), triangles, trianglesCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TessellationSink_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TessellationSink.VTable, @ptrCast(self.vtable)).Close(@as(*const ID2D1TessellationSink, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1PathGeometry_Value = Guid.initString("2cd906a5-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1PathGeometry = &IID_ID2D1PathGeometry_Value;
pub const ID2D1PathGeometry = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Geometry.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PathGeometry,
                geometrySink: ?*?*ID2D1GeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PathGeometry,
                geometrySink: ?*?*ID2D1GeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PathGeometry,
                geometrySink: ?*ID2D1GeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PathGeometry,
                geometrySink: ?*ID2D1GeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSegmentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PathGeometry,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PathGeometry,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFigureCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PathGeometry,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PathGeometry,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Geometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PathGeometry_Open(self: *const T, geometrySink: ?*?*ID2D1GeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PathGeometry.VTable, @ptrCast(self.vtable)).Open(@as(*const ID2D1PathGeometry, @ptrCast(self)), geometrySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PathGeometry_Stream(self: *const T, geometrySink: ?*ID2D1GeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PathGeometry.VTable, @ptrCast(self.vtable)).Stream(@as(*const ID2D1PathGeometry, @ptrCast(self)), geometrySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PathGeometry_GetSegmentCount(self: *const T, count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PathGeometry.VTable, @ptrCast(self.vtable)).GetSegmentCount(@as(*const ID2D1PathGeometry, @ptrCast(self)), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PathGeometry_GetFigureCount(self: *const T, count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PathGeometry.VTable, @ptrCast(self.vtable)).GetFigureCount(@as(*const ID2D1PathGeometry, @ptrCast(self)), count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Mesh_Value = Guid.initString("2cd906c2-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1Mesh = &IID_ID2D1Mesh_Value;
pub const ID2D1Mesh = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Mesh,
                tessellationSink: ?*?*ID2D1TessellationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Mesh,
                tessellationSink: ?*?*ID2D1TessellationSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Mesh_Open(self: *const T, tessellationSink: ?*?*ID2D1TessellationSink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Mesh.VTable, @ptrCast(self.vtable)).Open(@as(*const ID2D1Mesh, @ptrCast(self)), tessellationSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Layer_Value = Guid.initString("2cd9069b-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1Layer = &IID_ID2D1Layer_Value;
pub const ID2D1Layer = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
            else => *const fn(
                self: *const ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Layer_GetSize(self: *const T) callconv(.Inline) D2D_SIZE_F {
            return @as(*const ID2D1Layer.VTable, @ptrCast(self.vtable)).GetSize(@as(*const ID2D1Layer, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1DrawingStateBlock_Value = Guid.initString("28506e39-ebf6-46a1-bb47-fd85565ab957");
pub const IID_ID2D1DrawingStateBlock = &IID_ID2D1DrawingStateBlock_Value;
pub const ID2D1DrawingStateBlock = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawingStateBlock,
                stateDescription: ?*D2D1_DRAWING_STATE_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DrawingStateBlock,
                stateDescription: ?*D2D1_DRAWING_STATE_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawingStateBlock,
                stateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DrawingStateBlock,
                stateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetTextRenderingParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawingStateBlock,
                textRenderingParams: ?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DrawingStateBlock,
                textRenderingParams: ?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTextRenderingParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawingStateBlock,
                textRenderingParams: ?*?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DrawingStateBlock,
                textRenderingParams: ?*?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawingStateBlock_GetDescription(self: *const T, stateDescription: ?*D2D1_DRAWING_STATE_DESCRIPTION) callconv(.Inline) void {
            return @as(*const ID2D1DrawingStateBlock.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ID2D1DrawingStateBlock, @ptrCast(self)), stateDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawingStateBlock_SetDescription(self: *const T, stateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION) callconv(.Inline) void {
            return @as(*const ID2D1DrawingStateBlock.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const ID2D1DrawingStateBlock, @ptrCast(self)), stateDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawingStateBlock_SetTextRenderingParams(self: *const T, textRenderingParams: ?*IDWriteRenderingParams) callconv(.Inline) void {
            return @as(*const ID2D1DrawingStateBlock.VTable, @ptrCast(self.vtable)).SetTextRenderingParams(@as(*const ID2D1DrawingStateBlock, @ptrCast(self)), textRenderingParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawingStateBlock_GetTextRenderingParams(self: *const T, textRenderingParams: ?*?*IDWriteRenderingParams) callconv(.Inline) void {
            return @as(*const ID2D1DrawingStateBlock.VTable, @ptrCast(self.vtable)).GetTextRenderingParams(@as(*const ID2D1DrawingStateBlock, @ptrCast(self)), textRenderingParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1RenderTarget_Value = Guid.initString("2cd90694-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1RenderTarget = &IID_ID2D1RenderTarget_Value;
pub const ID2D1RenderTarget = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        CreateBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                size: D2D_SIZE_U,
                srcData: ?*const anyopaque,
                pitch: u32,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                size: D2D_SIZE_U,
                srcData: ?*const anyopaque,
                pitch: u32,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBitmapFromWicBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                wicBitmapSource: ?*IWICBitmapSource,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                wicBitmapSource: ?*IWICBitmapSource,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSharedBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                riid: ?*const Guid,
                data: ?*anyopaque,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                riid: ?*const Guid,
                data: ?*anyopaque,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBitmapBrush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                bitmap: ?*ID2D1Bitmap,
                bitmapBrushProperties: ?*const D2D1_BITMAP_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                bitmapBrush: ?*?*ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                bitmap: ?*ID2D1Bitmap,
                bitmapBrushProperties: ?*const D2D1_BITMAP_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                bitmapBrush: ?*?*ID2D1BitmapBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSolidColorBrush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                color: ?*const D2D1_COLOR_F,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                solidColorBrush: ?*?*ID2D1SolidColorBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                color: ?*const D2D1_COLOR_F,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                solidColorBrush: ?*?*ID2D1SolidColorBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGradientStopCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                gradientStops: [*]const D2D1_GRADIENT_STOP,
                gradientStopsCount: u32,
                colorInterpolationGamma: D2D1_GAMMA,
                extendMode: D2D1_EXTEND_MODE,
                gradientStopCollection: ?*?*ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                gradientStops: [*]const D2D1_GRADIENT_STOP,
                gradientStopsCount: u32,
                colorInterpolationGamma: D2D1_GAMMA,
                extendMode: D2D1_EXTEND_MODE,
                gradientStopCollection: ?*?*ID2D1GradientStopCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLinearGradientBrush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                linearGradientBrushProperties: ?*const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                gradientStopCollection: ?*ID2D1GradientStopCollection,
                linearGradientBrush: ?*?*ID2D1LinearGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                linearGradientBrushProperties: ?*const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                gradientStopCollection: ?*ID2D1GradientStopCollection,
                linearGradientBrush: ?*?*ID2D1LinearGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRadialGradientBrush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                radialGradientBrushProperties: ?*const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                gradientStopCollection: ?*ID2D1GradientStopCollection,
                radialGradientBrush: ?*?*ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                radialGradientBrushProperties: ?*const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                gradientStopCollection: ?*ID2D1GradientStopCollection,
                radialGradientBrush: ?*?*ID2D1RadialGradientBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCompatibleRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                desiredSize: ?*const D2D_SIZE_F,
                desiredPixelSize: ?*const D2D_SIZE_U,
                desiredFormat: ?*const D2D1_PIXEL_FORMAT,
                options: D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS,
                bitmapRenderTarget: ?*?*ID2D1BitmapRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                desiredSize: ?*const D2D_SIZE_F,
                desiredPixelSize: ?*const D2D_SIZE_U,
                desiredFormat: ?*const D2D1_PIXEL_FORMAT,
                options: D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS,
                bitmapRenderTarget: ?*?*ID2D1BitmapRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                size: ?*const D2D_SIZE_F,
                layer: ?*?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                size: ?*const D2D_SIZE_F,
                layer: ?*?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMesh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                mesh: ?*?*ID2D1Mesh,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                mesh: ?*?*ID2D1Mesh,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                point0: D2D_POINT_2F,
                point1: D2D_POINT_2F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                point0: D2D_POINT_2F,
                point1: D2D_POINT_2F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FillRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawRoundedRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                roundedRect: ?*const D2D1_ROUNDED_RECT,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                roundedRect: ?*const D2D1_ROUNDED_RECT,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FillRoundedRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                roundedRect: ?*const D2D1_ROUNDED_RECT,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                roundedRect: ?*const D2D1_ROUNDED_RECT,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawEllipse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                ellipse: ?*const D2D1_ELLIPSE,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                ellipse: ?*const D2D1_ELLIPSE,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FillEllipse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                ellipse: ?*const D2D1_ELLIPSE,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                ellipse: ?*const D2D1_ELLIPSE,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FillGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                opacityBrush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                opacityBrush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FillMesh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                mesh: ?*ID2D1Mesh,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                mesh: ?*ID2D1Mesh,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FillOpacityMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                opacityMask: ?*ID2D1Bitmap,
                brush: ?*ID2D1Brush,
                content: D2D1_OPACITY_MASK_CONTENT,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                opacityMask: ?*ID2D1Bitmap,
                brush: ?*ID2D1Brush,
                content: D2D1_OPACITY_MASK_CONTENT,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                bitmap: ?*ID2D1Bitmap,
                destinationRectangle: ?*const D2D_RECT_F,
                opacity: f32,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                bitmap: ?*ID2D1Bitmap,
                destinationRectangle: ?*const D2D_RECT_F,
                opacity: f32,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                string: [*:0]const u16,
                stringLength: u32,
                textFormat: ?*IDWriteTextFormat,
                layoutRect: ?*const D2D_RECT_F,
                defaultFillBrush: ?*ID2D1Brush,
                options: D2D1_DRAW_TEXT_OPTIONS,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                string: [*:0]const u16,
                stringLength: u32,
                textFormat: ?*IDWriteTextFormat,
                layoutRect: ?*const D2D_RECT_F,
                defaultFillBrush: ?*ID2D1Brush,
                options: D2D1_DRAW_TEXT_OPTIONS,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawTextLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                origin: D2D_POINT_2F,
                textLayout: ?*IDWriteTextLayout,
                defaultFillBrush: ?*ID2D1Brush,
                options: D2D1_DRAW_TEXT_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                origin: D2D_POINT_2F,
                textLayout: ?*IDWriteTextLayout,
                defaultFillBrush: ?*ID2D1Brush,
                options: D2D1_DRAW_TEXT_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawGlyphRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                foregroundBrush: ?*ID2D1Brush,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                foregroundBrush: ?*ID2D1Brush,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetAntialiasMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetAntialiasMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_ANTIALIAS_MODE,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_ANTIALIAS_MODE,
        },
        SetTextAntialiasMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTextAntialiasMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_TEXT_ANTIALIAS_MODE,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_TEXT_ANTIALIAS_MODE,
        },
        SetTextRenderingParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                textRenderingParams: ?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                textRenderingParams: ?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTextRenderingParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                textRenderingParams: ?*?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                textRenderingParams: ?*?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetTags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                tag1: u64,
                tag2: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                tag1: u64,
                tag2: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushLayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                layerParameters: ?*const D2D1_LAYER_PARAMETERS,
                layer: ?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                layerParameters: ?*const D2D1_LAYER_PARAMETERS,
                layer: ?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PopLayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveDrawingState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                drawingStateBlock: ?*ID2D1DrawingStateBlock,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                drawingStateBlock: ?*ID2D1DrawingStateBlock,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RestoreDrawingState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                drawingStateBlock: ?*ID2D1DrawingStateBlock,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                drawingStateBlock: ?*ID2D1DrawingStateBlock,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushAxisAlignedClip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                clipRect: ?*const D2D_RECT_F,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                clipRect: ?*const D2D_RECT_F,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PopAxisAlignedClip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                clearColor: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                clearColor: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPixelFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PIXEL_FORMAT,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PIXEL_FORMAT,
        },
        SetDpi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                dpiX: f32,
                dpiY: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                dpiX: f32,
                dpiY: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDpi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
        },
        GetPixelSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_U,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_U,
        },
        GetMaximumBitmapSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        IsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderTarget,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1RenderTarget,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateBitmap(self: *const T, size: D2D_SIZE_U, srcData: ?*const anyopaque, pitch: u32, bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES, bitmap: ?*?*ID2D1Bitmap) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateBitmap(@as(*const ID2D1RenderTarget, @ptrCast(self)), size, srcData, pitch, bitmapProperties, bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateBitmapFromWicBitmap(self: *const T, wicBitmapSource: ?*IWICBitmapSource, bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES, bitmap: ?*?*ID2D1Bitmap) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateBitmapFromWicBitmap(@as(*const ID2D1RenderTarget, @ptrCast(self)), wicBitmapSource, bitmapProperties, bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateSharedBitmap(self: *const T, riid: ?*const Guid, data: ?*anyopaque, bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES, bitmap: ?*?*ID2D1Bitmap) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateSharedBitmap(@as(*const ID2D1RenderTarget, @ptrCast(self)), riid, data, bitmapProperties, bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateBitmapBrush(self: *const T, bitmap: ?*ID2D1Bitmap, bitmapBrushProperties: ?*const D2D1_BITMAP_BRUSH_PROPERTIES, brushProperties: ?*const D2D1_BRUSH_PROPERTIES, bitmapBrush: ?*?*ID2D1BitmapBrush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateBitmapBrush(@as(*const ID2D1RenderTarget, @ptrCast(self)), bitmap, bitmapBrushProperties, brushProperties, bitmapBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateSolidColorBrush(self: *const T, color: ?*const D2D1_COLOR_F, brushProperties: ?*const D2D1_BRUSH_PROPERTIES, solidColorBrush: ?*?*ID2D1SolidColorBrush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateSolidColorBrush(@as(*const ID2D1RenderTarget, @ptrCast(self)), color, brushProperties, solidColorBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateGradientStopCollection(self: *const T, gradientStops: [*]const D2D1_GRADIENT_STOP, gradientStopsCount: u32, colorInterpolationGamma: D2D1_GAMMA, extendMode: D2D1_EXTEND_MODE, gradientStopCollection: ?*?*ID2D1GradientStopCollection) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateGradientStopCollection(@as(*const ID2D1RenderTarget, @ptrCast(self)), gradientStops, gradientStopsCount, colorInterpolationGamma, extendMode, gradientStopCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateLinearGradientBrush(self: *const T, linearGradientBrushProperties: ?*const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES, brushProperties: ?*const D2D1_BRUSH_PROPERTIES, gradientStopCollection: ?*ID2D1GradientStopCollection, linearGradientBrush: ?*?*ID2D1LinearGradientBrush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateLinearGradientBrush(@as(*const ID2D1RenderTarget, @ptrCast(self)), linearGradientBrushProperties, brushProperties, gradientStopCollection, linearGradientBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateRadialGradientBrush(self: *const T, radialGradientBrushProperties: ?*const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES, brushProperties: ?*const D2D1_BRUSH_PROPERTIES, gradientStopCollection: ?*ID2D1GradientStopCollection, radialGradientBrush: ?*?*ID2D1RadialGradientBrush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateRadialGradientBrush(@as(*const ID2D1RenderTarget, @ptrCast(self)), radialGradientBrushProperties, brushProperties, gradientStopCollection, radialGradientBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateCompatibleRenderTarget(self: *const T, desiredSize: ?*const D2D_SIZE_F, desiredPixelSize: ?*const D2D_SIZE_U, desiredFormat: ?*const D2D1_PIXEL_FORMAT, options: D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS, bitmapRenderTarget: ?*?*ID2D1BitmapRenderTarget) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateCompatibleRenderTarget(@as(*const ID2D1RenderTarget, @ptrCast(self)), desiredSize, desiredPixelSize, desiredFormat, options, bitmapRenderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateLayer(self: *const T, size: ?*const D2D_SIZE_F, layer: ?*?*ID2D1Layer) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateLayer(@as(*const ID2D1RenderTarget, @ptrCast(self)), size, layer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_CreateMesh(self: *const T, mesh: ?*?*ID2D1Mesh) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).CreateMesh(@as(*const ID2D1RenderTarget, @ptrCast(self)), mesh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawLine(self: *const T, point0: D2D_POINT_2F, point1: D2D_POINT_2F, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawLine(@as(*const ID2D1RenderTarget, @ptrCast(self)), point0, point1, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawRectangle(self: *const T, rect: ?*const D2D_RECT_F, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawRectangle(@as(*const ID2D1RenderTarget, @ptrCast(self)), rect, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_FillRectangle(self: *const T, rect: ?*const D2D_RECT_F, brush: ?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).FillRectangle(@as(*const ID2D1RenderTarget, @ptrCast(self)), rect, brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawRoundedRectangle(self: *const T, roundedRect: ?*const D2D1_ROUNDED_RECT, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawRoundedRectangle(@as(*const ID2D1RenderTarget, @ptrCast(self)), roundedRect, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_FillRoundedRectangle(self: *const T, roundedRect: ?*const D2D1_ROUNDED_RECT, brush: ?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).FillRoundedRectangle(@as(*const ID2D1RenderTarget, @ptrCast(self)), roundedRect, brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawEllipse(self: *const T, ellipse: ?*const D2D1_ELLIPSE, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawEllipse(@as(*const ID2D1RenderTarget, @ptrCast(self)), ellipse, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_FillEllipse(self: *const T, ellipse: ?*const D2D1_ELLIPSE, brush: ?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).FillEllipse(@as(*const ID2D1RenderTarget, @ptrCast(self)), ellipse, brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawGeometry(self: *const T, geometry: ?*ID2D1Geometry, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawGeometry(@as(*const ID2D1RenderTarget, @ptrCast(self)), geometry, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_FillGeometry(self: *const T, geometry: ?*ID2D1Geometry, brush: ?*ID2D1Brush, opacityBrush: ?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).FillGeometry(@as(*const ID2D1RenderTarget, @ptrCast(self)), geometry, brush, opacityBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_FillMesh(self: *const T, mesh: ?*ID2D1Mesh, brush: ?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).FillMesh(@as(*const ID2D1RenderTarget, @ptrCast(self)), mesh, brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_FillOpacityMask(self: *const T, opacityMask: ?*ID2D1Bitmap, brush: ?*ID2D1Brush, content: D2D1_OPACITY_MASK_CONTENT, destinationRectangle: ?*const D2D_RECT_F, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).FillOpacityMask(@as(*const ID2D1RenderTarget, @ptrCast(self)), opacityMask, brush, content, destinationRectangle, sourceRectangle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawBitmap(self: *const T, bitmap: ?*ID2D1Bitmap, destinationRectangle: ?*const D2D_RECT_F, opacity: f32, interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ID2D1RenderTarget, @ptrCast(self)), bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawText(self: *const T, string: [*:0]const u16, stringLength: u32, textFormat: ?*IDWriteTextFormat, layoutRect: ?*const D2D_RECT_F, defaultFillBrush: ?*ID2D1Brush, options: D2D1_DRAW_TEXT_OPTIONS, measuringMode: DWRITE_MEASURING_MODE) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawText(@as(*const ID2D1RenderTarget, @ptrCast(self)), string, stringLength, textFormat, layoutRect, defaultFillBrush, options, measuringMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawTextLayout(self: *const T, origin: D2D_POINT_2F, textLayout: ?*IDWriteTextLayout, defaultFillBrush: ?*ID2D1Brush, options: D2D1_DRAW_TEXT_OPTIONS) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawTextLayout(@as(*const ID2D1RenderTarget, @ptrCast(self)), origin, textLayout, defaultFillBrush, options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_DrawGlyphRun(self: *const T, baselineOrigin: D2D_POINT_2F, glyphRun: ?*const DWRITE_GLYPH_RUN, foregroundBrush: ?*ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).DrawGlyphRun(@as(*const ID2D1RenderTarget, @ptrCast(self)), baselineOrigin, glyphRun, foregroundBrush, measuringMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SetTransform(self: *const T, transform: ?*const D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SetTransform(@as(*const ID2D1RenderTarget, @ptrCast(self)), transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetTransform(self: *const T, transform: ?*D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetTransform(@as(*const ID2D1RenderTarget, @ptrCast(self)), transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SetAntialiasMode(self: *const T, antialiasMode: D2D1_ANTIALIAS_MODE) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SetAntialiasMode(@as(*const ID2D1RenderTarget, @ptrCast(self)), antialiasMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetAntialiasMode(self: *const T) callconv(.Inline) D2D1_ANTIALIAS_MODE {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetAntialiasMode(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SetTextAntialiasMode(self: *const T, textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SetTextAntialiasMode(@as(*const ID2D1RenderTarget, @ptrCast(self)), textAntialiasMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetTextAntialiasMode(self: *const T) callconv(.Inline) D2D1_TEXT_ANTIALIAS_MODE {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetTextAntialiasMode(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SetTextRenderingParams(self: *const T, textRenderingParams: ?*IDWriteRenderingParams) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SetTextRenderingParams(@as(*const ID2D1RenderTarget, @ptrCast(self)), textRenderingParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetTextRenderingParams(self: *const T, textRenderingParams: ?*?*IDWriteRenderingParams) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetTextRenderingParams(@as(*const ID2D1RenderTarget, @ptrCast(self)), textRenderingParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SetTags(self: *const T, tag1: u64, tag2: u64) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SetTags(@as(*const ID2D1RenderTarget, @ptrCast(self)), tag1, tag2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetTags(self: *const T, tag1: ?*u64, tag2: ?*u64) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetTags(@as(*const ID2D1RenderTarget, @ptrCast(self)), tag1, tag2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_PushLayer(self: *const T, layerParameters: ?*const D2D1_LAYER_PARAMETERS, layer: ?*ID2D1Layer) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).PushLayer(@as(*const ID2D1RenderTarget, @ptrCast(self)), layerParameters, layer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_PopLayer(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).PopLayer(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_Flush(self: *const T, tag1: ?*u64, tag2: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).Flush(@as(*const ID2D1RenderTarget, @ptrCast(self)), tag1, tag2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SaveDrawingState(self: *const T, drawingStateBlock: ?*ID2D1DrawingStateBlock) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SaveDrawingState(@as(*const ID2D1RenderTarget, @ptrCast(self)), drawingStateBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_RestoreDrawingState(self: *const T, drawingStateBlock: ?*ID2D1DrawingStateBlock) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).RestoreDrawingState(@as(*const ID2D1RenderTarget, @ptrCast(self)), drawingStateBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_PushAxisAlignedClip(self: *const T, clipRect: ?*const D2D_RECT_F, antialiasMode: D2D1_ANTIALIAS_MODE) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).PushAxisAlignedClip(@as(*const ID2D1RenderTarget, @ptrCast(self)), clipRect, antialiasMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_PopAxisAlignedClip(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).PopAxisAlignedClip(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_Clear(self: *const T, clearColor: ?*const D2D1_COLOR_F) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).Clear(@as(*const ID2D1RenderTarget, @ptrCast(self)), clearColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_BeginDraw(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).BeginDraw(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_EndDraw(self: *const T, tag1: ?*u64, tag2: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).EndDraw(@as(*const ID2D1RenderTarget, @ptrCast(self)), tag1, tag2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetPixelFormat(self: *const T) callconv(.Inline) D2D1_PIXEL_FORMAT {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetPixelFormat(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_SetDpi(self: *const T, dpiX: f32, dpiY: f32) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).SetDpi(@as(*const ID2D1RenderTarget, @ptrCast(self)), dpiX, dpiY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetDpi(self: *const T, dpiX: ?*f32, dpiY: ?*f32) callconv(.Inline) void {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetDpi(@as(*const ID2D1RenderTarget, @ptrCast(self)), dpiX, dpiY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetSize(self: *const T) callconv(.Inline) D2D_SIZE_F {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetSize(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetPixelSize(self: *const T) callconv(.Inline) D2D_SIZE_U {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetPixelSize(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_GetMaximumBitmapSize(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).GetMaximumBitmapSize(@as(*const ID2D1RenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderTarget_IsSupported(self: *const T, renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES) callconv(.Inline) BOOL {
            return @as(*const ID2D1RenderTarget.VTable, @ptrCast(self.vtable)).IsSupported(@as(*const ID2D1RenderTarget, @ptrCast(self)), renderTargetProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1BitmapRenderTarget_Value = Guid.initString("2cd90695-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1BitmapRenderTarget = &IID_ID2D1BitmapRenderTarget_Value;
pub const ID2D1BitmapRenderTarget = extern struct {
    pub const VTable = extern struct {
        base: ID2D1RenderTarget.VTable,
        GetBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapRenderTarget,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1BitmapRenderTarget,
                bitmap: ?*?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1RenderTarget.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapRenderTarget_GetBitmap(self: *const T, bitmap: ?*?*ID2D1Bitmap) callconv(.Inline) HRESULT {
            return @as(*const ID2D1BitmapRenderTarget.VTable, @ptrCast(self.vtable)).GetBitmap(@as(*const ID2D1BitmapRenderTarget, @ptrCast(self)), bitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1HwndRenderTarget_Value = Guid.initString("2cd90698-12e2-11dc-9fed-001143a055f9");
pub const IID_ID2D1HwndRenderTarget = &IID_ID2D1HwndRenderTarget_Value;
pub const ID2D1HwndRenderTarget = extern struct {
    pub const VTable = extern struct {
        base: ID2D1RenderTarget.VTable,
        CheckWindowState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1HwndRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_WINDOW_STATE,
            else => *const fn(
                self: *const ID2D1HwndRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_WINDOW_STATE,
        },
        Resize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1HwndRenderTarget,
                pixelSize: ?*const D2D_SIZE_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1HwndRenderTarget,
                pixelSize: ?*const D2D_SIZE_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHwnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1HwndRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) ?HWND,
            else => *const fn(
                self: *const ID2D1HwndRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) ?HWND,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1RenderTarget.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1HwndRenderTarget_CheckWindowState(self: *const T) callconv(.Inline) D2D1_WINDOW_STATE {
            return @as(*const ID2D1HwndRenderTarget.VTable, @ptrCast(self.vtable)).CheckWindowState(@as(*const ID2D1HwndRenderTarget, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1HwndRenderTarget_Resize(self: *const T, pixelSize: ?*const D2D_SIZE_U) callconv(.Inline) HRESULT {
            return @as(*const ID2D1HwndRenderTarget.VTable, @ptrCast(self.vtable)).Resize(@as(*const ID2D1HwndRenderTarget, @ptrCast(self)), pixelSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1HwndRenderTarget_GetHwnd(self: *const T) callconv(.Inline) ?HWND {
            return @as(*const ID2D1HwndRenderTarget.VTable, @ptrCast(self.vtable)).GetHwnd(@as(*const ID2D1HwndRenderTarget, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1GdiInteropRenderTarget_Value = Guid.initString("e0db51c3-6f77-4bae-b3d5-e47509b35838");
pub const IID_ID2D1GdiInteropRenderTarget = &IID_ID2D1GdiInteropRenderTarget_Value;
pub const ID2D1GdiInteropRenderTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiInteropRenderTarget,
                mode: D2D1_DC_INITIALIZE_MODE,
                hdc: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiInteropRenderTarget,
                mode: D2D1_DC_INITIALIZE_MODE,
                hdc: ?*?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiInteropRenderTarget,
                update: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiInteropRenderTarget,
                update: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiInteropRenderTarget_GetDC(self: *const T, mode: D2D1_DC_INITIALIZE_MODE, hdc: ?*?HDC) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiInteropRenderTarget.VTable, @ptrCast(self.vtable)).GetDC(@as(*const ID2D1GdiInteropRenderTarget, @ptrCast(self)), mode, hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiInteropRenderTarget_ReleaseDC(self: *const T, update: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiInteropRenderTarget.VTable, @ptrCast(self.vtable)).ReleaseDC(@as(*const ID2D1GdiInteropRenderTarget, @ptrCast(self)), update);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1DCRenderTarget_Value = Guid.initString("1c51bc64-de61-46fd-9899-63a5d8f03950");
pub const IID_ID2D1DCRenderTarget = &IID_ID2D1DCRenderTarget_Value;
pub const ID2D1DCRenderTarget = extern struct {
    pub const VTable = extern struct {
        base: ID2D1RenderTarget.VTable,
        BindDC: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DCRenderTarget,
                hDC: ?HDC,
                pSubRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DCRenderTarget,
                hDC: ?HDC,
                pSubRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1RenderTarget.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DCRenderTarget_BindDC(self: *const T, hDC: ?HDC, pSubRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DCRenderTarget.VTable, @ptrCast(self.vtable)).BindDC(@as(*const ID2D1DCRenderTarget, @ptrCast(self)), hDC, pSubRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ID2D1Factory_Value = Guid.initString("06152247-6f50-465a-9245-118bfd3b6007");
pub const IID_ID2D1Factory = &IID_ID2D1Factory_Value;
pub const ID2D1Factory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReloadSystemMetrics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDesktopDpi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Factory,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateRectangleGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                rectangle: ?*const D2D_RECT_F,
                rectangleGeometry: ?*?*ID2D1RectangleGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                rectangle: ?*const D2D_RECT_F,
                rectangleGeometry: ?*?*ID2D1RectangleGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRoundedRectangleGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                roundedRectangle: ?*const D2D1_ROUNDED_RECT,
                roundedRectangleGeometry: ?*?*ID2D1RoundedRectangleGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                roundedRectangle: ?*const D2D1_ROUNDED_RECT,
                roundedRectangleGeometry: ?*?*ID2D1RoundedRectangleGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEllipseGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                ellipse: ?*const D2D1_ELLIPSE,
                ellipseGeometry: ?*?*ID2D1EllipseGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                ellipse: ?*const D2D1_ELLIPSE,
                ellipseGeometry: ?*?*ID2D1EllipseGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGeometryGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                fillMode: D2D1_FILL_MODE,
                geometries: [*]?*ID2D1Geometry,
                geometriesCount: u32,
                geometryGroup: ?*?*ID2D1GeometryGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                fillMode: D2D1_FILL_MODE,
                geometries: [*]?*ID2D1Geometry,
                geometriesCount: u32,
                geometryGroup: ?*?*ID2D1GeometryGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTransformedGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                sourceGeometry: ?*ID2D1Geometry,
                transform: ?*const D2D_MATRIX_3X2_F,
                transformedGeometry: ?*?*ID2D1TransformedGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                sourceGeometry: ?*ID2D1Geometry,
                transform: ?*const D2D_MATRIX_3X2_F,
                transformedGeometry: ?*?*ID2D1TransformedGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePathGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                pathGeometry: ?*?*ID2D1PathGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                pathGeometry: ?*?*ID2D1PathGeometry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStrokeStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                strokeStyleProperties: ?*const D2D1_STROKE_STYLE_PROPERTIES,
                dashes: ?[*]const f32,
                dashesCount: u32,
                strokeStyle: ?*?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                strokeStyleProperties: ?*const D2D1_STROKE_STYLE_PROPERTIES,
                dashes: ?[*]const f32,
                dashesCount: u32,
                strokeStyle: ?*?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDrawingStateBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                drawingStateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION,
                textRenderingParams: ?*IDWriteRenderingParams,
                drawingStateBlock: ?*?*ID2D1DrawingStateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                drawingStateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION,
                textRenderingParams: ?*IDWriteRenderingParams,
                drawingStateBlock: ?*?*ID2D1DrawingStateBlock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateWicBitmapRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                target: ?*IWICBitmap,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                renderTarget: ?*?*ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                target: ?*IWICBitmap,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                renderTarget: ?*?*ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateHwndRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                hwndRenderTargetProperties: ?*const D2D1_HWND_RENDER_TARGET_PROPERTIES,
                hwndRenderTarget: ?*?*ID2D1HwndRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                hwndRenderTargetProperties: ?*const D2D1_HWND_RENDER_TARGET_PROPERTIES,
                hwndRenderTarget: ?*?*ID2D1HwndRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDxgiSurfaceRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                dxgiSurface: ?*IDXGISurface,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                renderTarget: ?*?*ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                dxgiSurface: ?*IDXGISurface,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                renderTarget: ?*?*ID2D1RenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDCRenderTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                dcRenderTarget: ?*?*ID2D1DCRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory,
                renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES,
                dcRenderTarget: ?*?*ID2D1DCRenderTarget,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_ReloadSystemMetrics(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).ReloadSystemMetrics(@as(*const ID2D1Factory, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_GetDesktopDpi(self: *const T, dpiX: ?*f32, dpiY: ?*f32) callconv(.Inline) void {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).GetDesktopDpi(@as(*const ID2D1Factory, @ptrCast(self)), dpiX, dpiY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateRectangleGeometry(self: *const T, rectangle: ?*const D2D_RECT_F, rectangleGeometry: ?*?*ID2D1RectangleGeometry) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateRectangleGeometry(@as(*const ID2D1Factory, @ptrCast(self)), rectangle, rectangleGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateRoundedRectangleGeometry(self: *const T, roundedRectangle: ?*const D2D1_ROUNDED_RECT, roundedRectangleGeometry: ?*?*ID2D1RoundedRectangleGeometry) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateRoundedRectangleGeometry(@as(*const ID2D1Factory, @ptrCast(self)), roundedRectangle, roundedRectangleGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateEllipseGeometry(self: *const T, ellipse: ?*const D2D1_ELLIPSE, ellipseGeometry: ?*?*ID2D1EllipseGeometry) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateEllipseGeometry(@as(*const ID2D1Factory, @ptrCast(self)), ellipse, ellipseGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateGeometryGroup(self: *const T, fillMode: D2D1_FILL_MODE, geometries: [*]?*ID2D1Geometry, geometriesCount: u32, geometryGroup: ?*?*ID2D1GeometryGroup) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateGeometryGroup(@as(*const ID2D1Factory, @ptrCast(self)), fillMode, geometries, geometriesCount, geometryGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateTransformedGeometry(self: *const T, sourceGeometry: ?*ID2D1Geometry, transform: ?*const D2D_MATRIX_3X2_F, transformedGeometry: ?*?*ID2D1TransformedGeometry) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateTransformedGeometry(@as(*const ID2D1Factory, @ptrCast(self)), sourceGeometry, transform, transformedGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreatePathGeometry(self: *const T, pathGeometry: ?*?*ID2D1PathGeometry) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreatePathGeometry(@as(*const ID2D1Factory, @ptrCast(self)), pathGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateStrokeStyle(self: *const T, strokeStyleProperties: ?*const D2D1_STROKE_STYLE_PROPERTIES, dashes: ?[*]const f32, dashesCount: u32, strokeStyle: ?*?*ID2D1StrokeStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateStrokeStyle(@as(*const ID2D1Factory, @ptrCast(self)), strokeStyleProperties, dashes, dashesCount, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateDrawingStateBlock(self: *const T, drawingStateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION, textRenderingParams: ?*IDWriteRenderingParams, drawingStateBlock: ?*?*ID2D1DrawingStateBlock) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateDrawingStateBlock(@as(*const ID2D1Factory, @ptrCast(self)), drawingStateDescription, textRenderingParams, drawingStateBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateWicBitmapRenderTarget(self: *const T, target: ?*IWICBitmap, renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES, renderTarget: ?*?*ID2D1RenderTarget) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateWicBitmapRenderTarget(@as(*const ID2D1Factory, @ptrCast(self)), target, renderTargetProperties, renderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateHwndRenderTarget(self: *const T, renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES, hwndRenderTargetProperties: ?*const D2D1_HWND_RENDER_TARGET_PROPERTIES, hwndRenderTarget: ?*?*ID2D1HwndRenderTarget) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateHwndRenderTarget(@as(*const ID2D1Factory, @ptrCast(self)), renderTargetProperties, hwndRenderTargetProperties, hwndRenderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateDxgiSurfaceRenderTarget(self: *const T, dxgiSurface: ?*IDXGISurface, renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES, renderTarget: ?*?*ID2D1RenderTarget) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateDxgiSurfaceRenderTarget(@as(*const ID2D1Factory, @ptrCast(self)), dxgiSurface, renderTargetProperties, renderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory_CreateDCRenderTarget(self: *const T, renderTargetProperties: ?*const D2D1_RENDER_TARGET_PROPERTIES, dcRenderTarget: ?*?*ID2D1DCRenderTarget) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory.VTable, @ptrCast(self.vtable)).CreateDCRenderTarget(@as(*const ID2D1Factory, @ptrCast(self)), renderTargetProperties, dcRenderTarget);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D2D1_CHANNEL_SELECTOR = enum(u32) {
    R = 0,
    G = 1,
    B = 2,
    A = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CHANNEL_SELECTOR_R = D2D1_CHANNEL_SELECTOR.R;
pub const D2D1_CHANNEL_SELECTOR_G = D2D1_CHANNEL_SELECTOR.G;
pub const D2D1_CHANNEL_SELECTOR_B = D2D1_CHANNEL_SELECTOR.B;
pub const D2D1_CHANNEL_SELECTOR_A = D2D1_CHANNEL_SELECTOR.A;
pub const D2D1_CHANNEL_SELECTOR_FORCE_DWORD = D2D1_CHANNEL_SELECTOR.FORCE_DWORD;

pub const D2D1_BITMAPSOURCE_ORIENTATION = enum(u32) {
    DEFAULT = 1,
    FLIP_HORIZONTAL = 2,
    ROTATE_CLOCKWISE180 = 3,
    ROTATE_CLOCKWISE180_FLIP_HORIZONTAL = 4,
    ROTATE_CLOCKWISE270_FLIP_HORIZONTAL = 5,
    ROTATE_CLOCKWISE90 = 6,
    ROTATE_CLOCKWISE90_FLIP_HORIZONTAL = 7,
    ROTATE_CLOCKWISE270 = 8,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BITMAPSOURCE_ORIENTATION_DEFAULT = D2D1_BITMAPSOURCE_ORIENTATION.DEFAULT;
pub const D2D1_BITMAPSOURCE_ORIENTATION_FLIP_HORIZONTAL = D2D1_BITMAPSOURCE_ORIENTATION.FLIP_HORIZONTAL;
pub const D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180 = D2D1_BITMAPSOURCE_ORIENTATION.ROTATE_CLOCKWISE180;
pub const D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL = D2D1_BITMAPSOURCE_ORIENTATION.ROTATE_CLOCKWISE180_FLIP_HORIZONTAL;
pub const D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL = D2D1_BITMAPSOURCE_ORIENTATION.ROTATE_CLOCKWISE270_FLIP_HORIZONTAL;
pub const D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90 = D2D1_BITMAPSOURCE_ORIENTATION.ROTATE_CLOCKWISE90;
pub const D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL = D2D1_BITMAPSOURCE_ORIENTATION.ROTATE_CLOCKWISE90_FLIP_HORIZONTAL;
pub const D2D1_BITMAPSOURCE_ORIENTATION_ROTATE_CLOCKWISE270 = D2D1_BITMAPSOURCE_ORIENTATION.ROTATE_CLOCKWISE270;
pub const D2D1_BITMAPSOURCE_ORIENTATION_FORCE_DWORD = D2D1_BITMAPSOURCE_ORIENTATION.FORCE_DWORD;

pub const D2D1_GAUSSIANBLUR_PROP = enum(u32) {
    STANDARD_DEVIATION = 0,
    OPTIMIZATION = 1,
    BORDER_MODE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GAUSSIANBLUR_PROP_STANDARD_DEVIATION = D2D1_GAUSSIANBLUR_PROP.STANDARD_DEVIATION;
pub const D2D1_GAUSSIANBLUR_PROP_OPTIMIZATION = D2D1_GAUSSIANBLUR_PROP.OPTIMIZATION;
pub const D2D1_GAUSSIANBLUR_PROP_BORDER_MODE = D2D1_GAUSSIANBLUR_PROP.BORDER_MODE;
pub const D2D1_GAUSSIANBLUR_PROP_FORCE_DWORD = D2D1_GAUSSIANBLUR_PROP.FORCE_DWORD;

pub const D2D1_GAUSSIANBLUR_OPTIMIZATION = enum(u32) {
    SPEED = 0,
    BALANCED = 1,
    QUALITY = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GAUSSIANBLUR_OPTIMIZATION_SPEED = D2D1_GAUSSIANBLUR_OPTIMIZATION.SPEED;
pub const D2D1_GAUSSIANBLUR_OPTIMIZATION_BALANCED = D2D1_GAUSSIANBLUR_OPTIMIZATION.BALANCED;
pub const D2D1_GAUSSIANBLUR_OPTIMIZATION_QUALITY = D2D1_GAUSSIANBLUR_OPTIMIZATION.QUALITY;
pub const D2D1_GAUSSIANBLUR_OPTIMIZATION_FORCE_DWORD = D2D1_GAUSSIANBLUR_OPTIMIZATION.FORCE_DWORD;

pub const D2D1_DIRECTIONALBLUR_PROP = enum(u32) {
    STANDARD_DEVIATION = 0,
    ANGLE = 1,
    OPTIMIZATION = 2,
    BORDER_MODE = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DIRECTIONALBLUR_PROP_STANDARD_DEVIATION = D2D1_DIRECTIONALBLUR_PROP.STANDARD_DEVIATION;
pub const D2D1_DIRECTIONALBLUR_PROP_ANGLE = D2D1_DIRECTIONALBLUR_PROP.ANGLE;
pub const D2D1_DIRECTIONALBLUR_PROP_OPTIMIZATION = D2D1_DIRECTIONALBLUR_PROP.OPTIMIZATION;
pub const D2D1_DIRECTIONALBLUR_PROP_BORDER_MODE = D2D1_DIRECTIONALBLUR_PROP.BORDER_MODE;
pub const D2D1_DIRECTIONALBLUR_PROP_FORCE_DWORD = D2D1_DIRECTIONALBLUR_PROP.FORCE_DWORD;

pub const D2D1_DIRECTIONALBLUR_OPTIMIZATION = enum(u32) {
    SPEED = 0,
    BALANCED = 1,
    QUALITY = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DIRECTIONALBLUR_OPTIMIZATION_SPEED = D2D1_DIRECTIONALBLUR_OPTIMIZATION.SPEED;
pub const D2D1_DIRECTIONALBLUR_OPTIMIZATION_BALANCED = D2D1_DIRECTIONALBLUR_OPTIMIZATION.BALANCED;
pub const D2D1_DIRECTIONALBLUR_OPTIMIZATION_QUALITY = D2D1_DIRECTIONALBLUR_OPTIMIZATION.QUALITY;
pub const D2D1_DIRECTIONALBLUR_OPTIMIZATION_FORCE_DWORD = D2D1_DIRECTIONALBLUR_OPTIMIZATION.FORCE_DWORD;

pub const D2D1_SHADOW_PROP = enum(u32) {
    BLUR_STANDARD_DEVIATION = 0,
    COLOR = 1,
    OPTIMIZATION = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SHADOW_PROP_BLUR_STANDARD_DEVIATION = D2D1_SHADOW_PROP.BLUR_STANDARD_DEVIATION;
pub const D2D1_SHADOW_PROP_COLOR = D2D1_SHADOW_PROP.COLOR;
pub const D2D1_SHADOW_PROP_OPTIMIZATION = D2D1_SHADOW_PROP.OPTIMIZATION;
pub const D2D1_SHADOW_PROP_FORCE_DWORD = D2D1_SHADOW_PROP.FORCE_DWORD;

pub const D2D1_SHADOW_OPTIMIZATION = enum(u32) {
    SPEED = 0,
    BALANCED = 1,
    QUALITY = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SHADOW_OPTIMIZATION_SPEED = D2D1_SHADOW_OPTIMIZATION.SPEED;
pub const D2D1_SHADOW_OPTIMIZATION_BALANCED = D2D1_SHADOW_OPTIMIZATION.BALANCED;
pub const D2D1_SHADOW_OPTIMIZATION_QUALITY = D2D1_SHADOW_OPTIMIZATION.QUALITY;
pub const D2D1_SHADOW_OPTIMIZATION_FORCE_DWORD = D2D1_SHADOW_OPTIMIZATION.FORCE_DWORD;

pub const D2D1_BLEND_PROP = enum(u32) {
    MODE = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BLEND_PROP_MODE = D2D1_BLEND_PROP.MODE;
pub const D2D1_BLEND_PROP_FORCE_DWORD = D2D1_BLEND_PROP.FORCE_DWORD;

pub const D2D1_SATURATION_PROP = enum(u32) {
    SATURATION = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SATURATION_PROP_SATURATION = D2D1_SATURATION_PROP.SATURATION;
pub const D2D1_SATURATION_PROP_FORCE_DWORD = D2D1_SATURATION_PROP.FORCE_DWORD;

pub const D2D1_HUEROTATION_PROP = enum(u32) {
    ANGLE = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HUEROTATION_PROP_ANGLE = D2D1_HUEROTATION_PROP.ANGLE;
pub const D2D1_HUEROTATION_PROP_FORCE_DWORD = D2D1_HUEROTATION_PROP.FORCE_DWORD;

pub const D2D1_COLORMATRIX_PROP = enum(u32) {
    COLOR_MATRIX = 0,
    ALPHA_MODE = 1,
    CLAMP_OUTPUT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLORMATRIX_PROP_COLOR_MATRIX = D2D1_COLORMATRIX_PROP.COLOR_MATRIX;
pub const D2D1_COLORMATRIX_PROP_ALPHA_MODE = D2D1_COLORMATRIX_PROP.ALPHA_MODE;
pub const D2D1_COLORMATRIX_PROP_CLAMP_OUTPUT = D2D1_COLORMATRIX_PROP.CLAMP_OUTPUT;
pub const D2D1_COLORMATRIX_PROP_FORCE_DWORD = D2D1_COLORMATRIX_PROP.FORCE_DWORD;

pub const D2D1_BITMAPSOURCE_PROP = enum(u32) {
    WIC_BITMAP_SOURCE = 0,
    SCALE = 1,
    INTERPOLATION_MODE = 2,
    ENABLE_DPI_CORRECTION = 3,
    ALPHA_MODE = 4,
    ORIENTATION = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BITMAPSOURCE_PROP_WIC_BITMAP_SOURCE = D2D1_BITMAPSOURCE_PROP.WIC_BITMAP_SOURCE;
pub const D2D1_BITMAPSOURCE_PROP_SCALE = D2D1_BITMAPSOURCE_PROP.SCALE;
pub const D2D1_BITMAPSOURCE_PROP_INTERPOLATION_MODE = D2D1_BITMAPSOURCE_PROP.INTERPOLATION_MODE;
pub const D2D1_BITMAPSOURCE_PROP_ENABLE_DPI_CORRECTION = D2D1_BITMAPSOURCE_PROP.ENABLE_DPI_CORRECTION;
pub const D2D1_BITMAPSOURCE_PROP_ALPHA_MODE = D2D1_BITMAPSOURCE_PROP.ALPHA_MODE;
pub const D2D1_BITMAPSOURCE_PROP_ORIENTATION = D2D1_BITMAPSOURCE_PROP.ORIENTATION;
pub const D2D1_BITMAPSOURCE_PROP_FORCE_DWORD = D2D1_BITMAPSOURCE_PROP.FORCE_DWORD;

pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    FANT = 6,
    MIPMAP_LINEAR = 7,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_BITMAPSOURCE_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE_LINEAR = D2D1_BITMAPSOURCE_INTERPOLATION_MODE.LINEAR;
pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE_CUBIC = D2D1_BITMAPSOURCE_INTERPOLATION_MODE.CUBIC;
pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE_FANT = D2D1_BITMAPSOURCE_INTERPOLATION_MODE.FANT;
pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE_MIPMAP_LINEAR = D2D1_BITMAPSOURCE_INTERPOLATION_MODE.MIPMAP_LINEAR;
pub const D2D1_BITMAPSOURCE_INTERPOLATION_MODE_FORCE_DWORD = D2D1_BITMAPSOURCE_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_BITMAPSOURCE_ALPHA_MODE = enum(u32) {
    PREMULTIPLIED = 1,
    STRAIGHT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BITMAPSOURCE_ALPHA_MODE_PREMULTIPLIED = D2D1_BITMAPSOURCE_ALPHA_MODE.PREMULTIPLIED;
pub const D2D1_BITMAPSOURCE_ALPHA_MODE_STRAIGHT = D2D1_BITMAPSOURCE_ALPHA_MODE.STRAIGHT;
pub const D2D1_BITMAPSOURCE_ALPHA_MODE_FORCE_DWORD = D2D1_BITMAPSOURCE_ALPHA_MODE.FORCE_DWORD;

pub const D2D1_COMPOSITE_PROP = enum(u32) {
    MODE = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COMPOSITE_PROP_MODE = D2D1_COMPOSITE_PROP.MODE;
pub const D2D1_COMPOSITE_PROP_FORCE_DWORD = D2D1_COMPOSITE_PROP.FORCE_DWORD;

pub const D2D1_3DTRANSFORM_PROP = enum(u32) {
    INTERPOLATION_MODE = 0,
    BORDER_MODE = 1,
    TRANSFORM_MATRIX = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_3DTRANSFORM_PROP_INTERPOLATION_MODE = D2D1_3DTRANSFORM_PROP.INTERPOLATION_MODE;
pub const D2D1_3DTRANSFORM_PROP_BORDER_MODE = D2D1_3DTRANSFORM_PROP.BORDER_MODE;
pub const D2D1_3DTRANSFORM_PROP_TRANSFORM_MATRIX = D2D1_3DTRANSFORM_PROP.TRANSFORM_MATRIX;
pub const D2D1_3DTRANSFORM_PROP_FORCE_DWORD = D2D1_3DTRANSFORM_PROP.FORCE_DWORD;

pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_3DTRANSFORM_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE_LINEAR = D2D1_3DTRANSFORM_INTERPOLATION_MODE.LINEAR;
pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE_CUBIC = D2D1_3DTRANSFORM_INTERPOLATION_MODE.CUBIC;
pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_3DTRANSFORM_INTERPOLATION_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE_ANISOTROPIC = D2D1_3DTRANSFORM_INTERPOLATION_MODE.ANISOTROPIC;
pub const D2D1_3DTRANSFORM_INTERPOLATION_MODE_FORCE_DWORD = D2D1_3DTRANSFORM_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_3DPERSPECTIVETRANSFORM_PROP = enum(u32) {
    INTERPOLATION_MODE = 0,
    BORDER_MODE = 1,
    DEPTH = 2,
    PERSPECTIVE_ORIGIN = 3,
    LOCAL_OFFSET = 4,
    GLOBAL_OFFSET = 5,
    ROTATION_ORIGIN = 6,
    ROTATION = 7,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_INTERPOLATION_MODE = D2D1_3DPERSPECTIVETRANSFORM_PROP.INTERPOLATION_MODE;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_BORDER_MODE = D2D1_3DPERSPECTIVETRANSFORM_PROP.BORDER_MODE;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_DEPTH = D2D1_3DPERSPECTIVETRANSFORM_PROP.DEPTH;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_PERSPECTIVE_ORIGIN = D2D1_3DPERSPECTIVETRANSFORM_PROP.PERSPECTIVE_ORIGIN;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_LOCAL_OFFSET = D2D1_3DPERSPECTIVETRANSFORM_PROP.LOCAL_OFFSET;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_GLOBAL_OFFSET = D2D1_3DPERSPECTIVETRANSFORM_PROP.GLOBAL_OFFSET;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION_ORIGIN = D2D1_3DPERSPECTIVETRANSFORM_PROP.ROTATION_ORIGIN;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_ROTATION = D2D1_3DPERSPECTIVETRANSFORM_PROP.ROTATION;
pub const D2D1_3DPERSPECTIVETRANSFORM_PROP_FORCE_DWORD = D2D1_3DPERSPECTIVETRANSFORM_PROP.FORCE_DWORD;

pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_LINEAR = D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE.LINEAR;
pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_CUBIC = D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE.CUBIC;
pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_ANISOTROPIC = D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE.ANISOTROPIC;
pub const D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE_FORCE_DWORD = D2D1_3DPERSPECTIVETRANSFORM_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_2DAFFINETRANSFORM_PROP = enum(u32) {
    INTERPOLATION_MODE = 0,
    BORDER_MODE = 1,
    TRANSFORM_MATRIX = 2,
    SHARPNESS = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_2DAFFINETRANSFORM_PROP_INTERPOLATION_MODE = D2D1_2DAFFINETRANSFORM_PROP.INTERPOLATION_MODE;
pub const D2D1_2DAFFINETRANSFORM_PROP_BORDER_MODE = D2D1_2DAFFINETRANSFORM_PROP.BORDER_MODE;
pub const D2D1_2DAFFINETRANSFORM_PROP_TRANSFORM_MATRIX = D2D1_2DAFFINETRANSFORM_PROP.TRANSFORM_MATRIX;
pub const D2D1_2DAFFINETRANSFORM_PROP_SHARPNESS = D2D1_2DAFFINETRANSFORM_PROP.SHARPNESS;
pub const D2D1_2DAFFINETRANSFORM_PROP_FORCE_DWORD = D2D1_2DAFFINETRANSFORM_PROP.FORCE_DWORD;

pub const D2D1_DPICOMPENSATION_PROP = enum(u32) {
    INTERPOLATION_MODE = 0,
    BORDER_MODE = 1,
    INPUT_DPI = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DPICOMPENSATION_PROP_INTERPOLATION_MODE = D2D1_DPICOMPENSATION_PROP.INTERPOLATION_MODE;
pub const D2D1_DPICOMPENSATION_PROP_BORDER_MODE = D2D1_DPICOMPENSATION_PROP.BORDER_MODE;
pub const D2D1_DPICOMPENSATION_PROP_INPUT_DPI = D2D1_DPICOMPENSATION_PROP.INPUT_DPI;
pub const D2D1_DPICOMPENSATION_PROP_FORCE_DWORD = D2D1_DPICOMPENSATION_PROP.FORCE_DWORD;

pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_LINEAR = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.LINEAR;
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_CUBIC = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.CUBIC;
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_ANISOTROPIC = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.ANISOTROPIC;
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_DPICOMPENSATION_INTERPOLATION_MODE_FORCE_DWORD = D2D1_DPICOMPENSATION_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_SCALE_PROP = enum(u32) {
    SCALE = 0,
    CENTER_POINT = 1,
    INTERPOLATION_MODE = 2,
    BORDER_MODE = 3,
    SHARPNESS = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SCALE_PROP_SCALE = D2D1_SCALE_PROP.SCALE;
pub const D2D1_SCALE_PROP_CENTER_POINT = D2D1_SCALE_PROP.CENTER_POINT;
pub const D2D1_SCALE_PROP_INTERPOLATION_MODE = D2D1_SCALE_PROP.INTERPOLATION_MODE;
pub const D2D1_SCALE_PROP_BORDER_MODE = D2D1_SCALE_PROP.BORDER_MODE;
pub const D2D1_SCALE_PROP_SHARPNESS = D2D1_SCALE_PROP.SHARPNESS;
pub const D2D1_SCALE_PROP_FORCE_DWORD = D2D1_SCALE_PROP.FORCE_DWORD;

pub const D2D1_SCALE_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SCALE_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_SCALE_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_SCALE_INTERPOLATION_MODE_LINEAR = D2D1_SCALE_INTERPOLATION_MODE.LINEAR;
pub const D2D1_SCALE_INTERPOLATION_MODE_CUBIC = D2D1_SCALE_INTERPOLATION_MODE.CUBIC;
pub const D2D1_SCALE_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_SCALE_INTERPOLATION_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_SCALE_INTERPOLATION_MODE_ANISOTROPIC = D2D1_SCALE_INTERPOLATION_MODE.ANISOTROPIC;
pub const D2D1_SCALE_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = D2D1_SCALE_INTERPOLATION_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_SCALE_INTERPOLATION_MODE_FORCE_DWORD = D2D1_SCALE_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_TURBULENCE_PROP = enum(u32) {
    OFFSET = 0,
    SIZE = 1,
    BASE_FREQUENCY = 2,
    NUM_OCTAVES = 3,
    SEED = 4,
    NOISE = 5,
    STITCHABLE = 6,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_TURBULENCE_PROP_OFFSET = D2D1_TURBULENCE_PROP.OFFSET;
pub const D2D1_TURBULENCE_PROP_SIZE = D2D1_TURBULENCE_PROP.SIZE;
pub const D2D1_TURBULENCE_PROP_BASE_FREQUENCY = D2D1_TURBULENCE_PROP.BASE_FREQUENCY;
pub const D2D1_TURBULENCE_PROP_NUM_OCTAVES = D2D1_TURBULENCE_PROP.NUM_OCTAVES;
pub const D2D1_TURBULENCE_PROP_SEED = D2D1_TURBULENCE_PROP.SEED;
pub const D2D1_TURBULENCE_PROP_NOISE = D2D1_TURBULENCE_PROP.NOISE;
pub const D2D1_TURBULENCE_PROP_STITCHABLE = D2D1_TURBULENCE_PROP.STITCHABLE;
pub const D2D1_TURBULENCE_PROP_FORCE_DWORD = D2D1_TURBULENCE_PROP.FORCE_DWORD;

pub const D2D1_DISPLACEMENTMAP_PROP = enum(u32) {
    SCALE = 0,
    X_CHANNEL_SELECT = 1,
    Y_CHANNEL_SELECT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DISPLACEMENTMAP_PROP_SCALE = D2D1_DISPLACEMENTMAP_PROP.SCALE;
pub const D2D1_DISPLACEMENTMAP_PROP_X_CHANNEL_SELECT = D2D1_DISPLACEMENTMAP_PROP.X_CHANNEL_SELECT;
pub const D2D1_DISPLACEMENTMAP_PROP_Y_CHANNEL_SELECT = D2D1_DISPLACEMENTMAP_PROP.Y_CHANNEL_SELECT;
pub const D2D1_DISPLACEMENTMAP_PROP_FORCE_DWORD = D2D1_DISPLACEMENTMAP_PROP.FORCE_DWORD;

pub const D2D1_COLORMANAGEMENT_PROP = enum(u32) {
    SOURCE_COLOR_CONTEXT = 0,
    SOURCE_RENDERING_INTENT = 1,
    DESTINATION_COLOR_CONTEXT = 2,
    DESTINATION_RENDERING_INTENT = 3,
    ALPHA_MODE = 4,
    QUALITY = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLORMANAGEMENT_PROP_SOURCE_COLOR_CONTEXT = D2D1_COLORMANAGEMENT_PROP.SOURCE_COLOR_CONTEXT;
pub const D2D1_COLORMANAGEMENT_PROP_SOURCE_RENDERING_INTENT = D2D1_COLORMANAGEMENT_PROP.SOURCE_RENDERING_INTENT;
pub const D2D1_COLORMANAGEMENT_PROP_DESTINATION_COLOR_CONTEXT = D2D1_COLORMANAGEMENT_PROP.DESTINATION_COLOR_CONTEXT;
pub const D2D1_COLORMANAGEMENT_PROP_DESTINATION_RENDERING_INTENT = D2D1_COLORMANAGEMENT_PROP.DESTINATION_RENDERING_INTENT;
pub const D2D1_COLORMANAGEMENT_PROP_ALPHA_MODE = D2D1_COLORMANAGEMENT_PROP.ALPHA_MODE;
pub const D2D1_COLORMANAGEMENT_PROP_QUALITY = D2D1_COLORMANAGEMENT_PROP.QUALITY;
pub const D2D1_COLORMANAGEMENT_PROP_FORCE_DWORD = D2D1_COLORMANAGEMENT_PROP.FORCE_DWORD;

pub const D2D1_COLORMANAGEMENT_ALPHA_MODE = enum(u32) {
    PREMULTIPLIED = 1,
    STRAIGHT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLORMANAGEMENT_ALPHA_MODE_PREMULTIPLIED = D2D1_COLORMANAGEMENT_ALPHA_MODE.PREMULTIPLIED;
pub const D2D1_COLORMANAGEMENT_ALPHA_MODE_STRAIGHT = D2D1_COLORMANAGEMENT_ALPHA_MODE.STRAIGHT;
pub const D2D1_COLORMANAGEMENT_ALPHA_MODE_FORCE_DWORD = D2D1_COLORMANAGEMENT_ALPHA_MODE.FORCE_DWORD;

pub const D2D1_COLORMANAGEMENT_QUALITY = enum(u32) {
    PROOF = 0,
    NORMAL = 1,
    BEST = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLORMANAGEMENT_QUALITY_PROOF = D2D1_COLORMANAGEMENT_QUALITY.PROOF;
pub const D2D1_COLORMANAGEMENT_QUALITY_NORMAL = D2D1_COLORMANAGEMENT_QUALITY.NORMAL;
pub const D2D1_COLORMANAGEMENT_QUALITY_BEST = D2D1_COLORMANAGEMENT_QUALITY.BEST;
pub const D2D1_COLORMANAGEMENT_QUALITY_FORCE_DWORD = D2D1_COLORMANAGEMENT_QUALITY.FORCE_DWORD;

pub const D2D1_COLORMANAGEMENT_RENDERING_INTENT = enum(u32) {
    PERCEPTUAL = 0,
    RELATIVE_COLORIMETRIC = 1,
    SATURATION = 2,
    ABSOLUTE_COLORIMETRIC = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLORMANAGEMENT_RENDERING_INTENT_PERCEPTUAL = D2D1_COLORMANAGEMENT_RENDERING_INTENT.PERCEPTUAL;
pub const D2D1_COLORMANAGEMENT_RENDERING_INTENT_RELATIVE_COLORIMETRIC = D2D1_COLORMANAGEMENT_RENDERING_INTENT.RELATIVE_COLORIMETRIC;
pub const D2D1_COLORMANAGEMENT_RENDERING_INTENT_SATURATION = D2D1_COLORMANAGEMENT_RENDERING_INTENT.SATURATION;
pub const D2D1_COLORMANAGEMENT_RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = D2D1_COLORMANAGEMENT_RENDERING_INTENT.ABSOLUTE_COLORIMETRIC;
pub const D2D1_COLORMANAGEMENT_RENDERING_INTENT_FORCE_DWORD = D2D1_COLORMANAGEMENT_RENDERING_INTENT.FORCE_DWORD;

pub const D2D1_HISTOGRAM_PROP = enum(u32) {
    NUM_BINS = 0,
    CHANNEL_SELECT = 1,
    HISTOGRAM_OUTPUT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HISTOGRAM_PROP_NUM_BINS = D2D1_HISTOGRAM_PROP.NUM_BINS;
pub const D2D1_HISTOGRAM_PROP_CHANNEL_SELECT = D2D1_HISTOGRAM_PROP.CHANNEL_SELECT;
pub const D2D1_HISTOGRAM_PROP_HISTOGRAM_OUTPUT = D2D1_HISTOGRAM_PROP.HISTOGRAM_OUTPUT;
pub const D2D1_HISTOGRAM_PROP_FORCE_DWORD = D2D1_HISTOGRAM_PROP.FORCE_DWORD;

pub const D2D1_POINTSPECULAR_PROP = enum(u32) {
    LIGHT_POSITION = 0,
    SPECULAR_EXPONENT = 1,
    SPECULAR_CONSTANT = 2,
    SURFACE_SCALE = 3,
    COLOR = 4,
    KERNEL_UNIT_LENGTH = 5,
    SCALE_MODE = 6,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_POINTSPECULAR_PROP_LIGHT_POSITION = D2D1_POINTSPECULAR_PROP.LIGHT_POSITION;
pub const D2D1_POINTSPECULAR_PROP_SPECULAR_EXPONENT = D2D1_POINTSPECULAR_PROP.SPECULAR_EXPONENT;
pub const D2D1_POINTSPECULAR_PROP_SPECULAR_CONSTANT = D2D1_POINTSPECULAR_PROP.SPECULAR_CONSTANT;
pub const D2D1_POINTSPECULAR_PROP_SURFACE_SCALE = D2D1_POINTSPECULAR_PROP.SURFACE_SCALE;
pub const D2D1_POINTSPECULAR_PROP_COLOR = D2D1_POINTSPECULAR_PROP.COLOR;
pub const D2D1_POINTSPECULAR_PROP_KERNEL_UNIT_LENGTH = D2D1_POINTSPECULAR_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_POINTSPECULAR_PROP_SCALE_MODE = D2D1_POINTSPECULAR_PROP.SCALE_MODE;
pub const D2D1_POINTSPECULAR_PROP_FORCE_DWORD = D2D1_POINTSPECULAR_PROP.FORCE_DWORD;

pub const D2D1_POINTSPECULAR_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_POINTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_POINTSPECULAR_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_POINTSPECULAR_SCALE_MODE_LINEAR = D2D1_POINTSPECULAR_SCALE_MODE.LINEAR;
pub const D2D1_POINTSPECULAR_SCALE_MODE_CUBIC = D2D1_POINTSPECULAR_SCALE_MODE.CUBIC;
pub const D2D1_POINTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_POINTSPECULAR_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_POINTSPECULAR_SCALE_MODE_ANISOTROPIC = D2D1_POINTSPECULAR_SCALE_MODE.ANISOTROPIC;
pub const D2D1_POINTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_POINTSPECULAR_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_POINTSPECULAR_SCALE_MODE_FORCE_DWORD = D2D1_POINTSPECULAR_SCALE_MODE.FORCE_DWORD;

pub const D2D1_SPOTSPECULAR_PROP = enum(u32) {
    LIGHT_POSITION = 0,
    POINTS_AT = 1,
    FOCUS = 2,
    LIMITING_CONE_ANGLE = 3,
    SPECULAR_EXPONENT = 4,
    SPECULAR_CONSTANT = 5,
    SURFACE_SCALE = 6,
    COLOR = 7,
    KERNEL_UNIT_LENGTH = 8,
    SCALE_MODE = 9,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SPOTSPECULAR_PROP_LIGHT_POSITION = D2D1_SPOTSPECULAR_PROP.LIGHT_POSITION;
pub const D2D1_SPOTSPECULAR_PROP_POINTS_AT = D2D1_SPOTSPECULAR_PROP.POINTS_AT;
pub const D2D1_SPOTSPECULAR_PROP_FOCUS = D2D1_SPOTSPECULAR_PROP.FOCUS;
pub const D2D1_SPOTSPECULAR_PROP_LIMITING_CONE_ANGLE = D2D1_SPOTSPECULAR_PROP.LIMITING_CONE_ANGLE;
pub const D2D1_SPOTSPECULAR_PROP_SPECULAR_EXPONENT = D2D1_SPOTSPECULAR_PROP.SPECULAR_EXPONENT;
pub const D2D1_SPOTSPECULAR_PROP_SPECULAR_CONSTANT = D2D1_SPOTSPECULAR_PROP.SPECULAR_CONSTANT;
pub const D2D1_SPOTSPECULAR_PROP_SURFACE_SCALE = D2D1_SPOTSPECULAR_PROP.SURFACE_SCALE;
pub const D2D1_SPOTSPECULAR_PROP_COLOR = D2D1_SPOTSPECULAR_PROP.COLOR;
pub const D2D1_SPOTSPECULAR_PROP_KERNEL_UNIT_LENGTH = D2D1_SPOTSPECULAR_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_SPOTSPECULAR_PROP_SCALE_MODE = D2D1_SPOTSPECULAR_PROP.SCALE_MODE;
pub const D2D1_SPOTSPECULAR_PROP_FORCE_DWORD = D2D1_SPOTSPECULAR_PROP.FORCE_DWORD;

pub const D2D1_SPOTSPECULAR_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SPOTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_SPOTSPECULAR_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_SPOTSPECULAR_SCALE_MODE_LINEAR = D2D1_SPOTSPECULAR_SCALE_MODE.LINEAR;
pub const D2D1_SPOTSPECULAR_SCALE_MODE_CUBIC = D2D1_SPOTSPECULAR_SCALE_MODE.CUBIC;
pub const D2D1_SPOTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_SPOTSPECULAR_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_SPOTSPECULAR_SCALE_MODE_ANISOTROPIC = D2D1_SPOTSPECULAR_SCALE_MODE.ANISOTROPIC;
pub const D2D1_SPOTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_SPOTSPECULAR_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_SPOTSPECULAR_SCALE_MODE_FORCE_DWORD = D2D1_SPOTSPECULAR_SCALE_MODE.FORCE_DWORD;

pub const D2D1_DISTANTSPECULAR_PROP = enum(u32) {
    AZIMUTH = 0,
    ELEVATION = 1,
    SPECULAR_EXPONENT = 2,
    SPECULAR_CONSTANT = 3,
    SURFACE_SCALE = 4,
    COLOR = 5,
    KERNEL_UNIT_LENGTH = 6,
    SCALE_MODE = 7,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DISTANTSPECULAR_PROP_AZIMUTH = D2D1_DISTANTSPECULAR_PROP.AZIMUTH;
pub const D2D1_DISTANTSPECULAR_PROP_ELEVATION = D2D1_DISTANTSPECULAR_PROP.ELEVATION;
pub const D2D1_DISTANTSPECULAR_PROP_SPECULAR_EXPONENT = D2D1_DISTANTSPECULAR_PROP.SPECULAR_EXPONENT;
pub const D2D1_DISTANTSPECULAR_PROP_SPECULAR_CONSTANT = D2D1_DISTANTSPECULAR_PROP.SPECULAR_CONSTANT;
pub const D2D1_DISTANTSPECULAR_PROP_SURFACE_SCALE = D2D1_DISTANTSPECULAR_PROP.SURFACE_SCALE;
pub const D2D1_DISTANTSPECULAR_PROP_COLOR = D2D1_DISTANTSPECULAR_PROP.COLOR;
pub const D2D1_DISTANTSPECULAR_PROP_KERNEL_UNIT_LENGTH = D2D1_DISTANTSPECULAR_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_DISTANTSPECULAR_PROP_SCALE_MODE = D2D1_DISTANTSPECULAR_PROP.SCALE_MODE;
pub const D2D1_DISTANTSPECULAR_PROP_FORCE_DWORD = D2D1_DISTANTSPECULAR_PROP.FORCE_DWORD;

pub const D2D1_DISTANTSPECULAR_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_DISTANTSPECULAR_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_LINEAR = D2D1_DISTANTSPECULAR_SCALE_MODE.LINEAR;
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_CUBIC = D2D1_DISTANTSPECULAR_SCALE_MODE.CUBIC;
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_DISTANTSPECULAR_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_ANISOTROPIC = D2D1_DISTANTSPECULAR_SCALE_MODE.ANISOTROPIC;
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_DISTANTSPECULAR_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_DISTANTSPECULAR_SCALE_MODE_FORCE_DWORD = D2D1_DISTANTSPECULAR_SCALE_MODE.FORCE_DWORD;

pub const D2D1_POINTDIFFUSE_PROP = enum(u32) {
    LIGHT_POSITION = 0,
    DIFFUSE_CONSTANT = 1,
    SURFACE_SCALE = 2,
    COLOR = 3,
    KERNEL_UNIT_LENGTH = 4,
    SCALE_MODE = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_POINTDIFFUSE_PROP_LIGHT_POSITION = D2D1_POINTDIFFUSE_PROP.LIGHT_POSITION;
pub const D2D1_POINTDIFFUSE_PROP_DIFFUSE_CONSTANT = D2D1_POINTDIFFUSE_PROP.DIFFUSE_CONSTANT;
pub const D2D1_POINTDIFFUSE_PROP_SURFACE_SCALE = D2D1_POINTDIFFUSE_PROP.SURFACE_SCALE;
pub const D2D1_POINTDIFFUSE_PROP_COLOR = D2D1_POINTDIFFUSE_PROP.COLOR;
pub const D2D1_POINTDIFFUSE_PROP_KERNEL_UNIT_LENGTH = D2D1_POINTDIFFUSE_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_POINTDIFFUSE_PROP_SCALE_MODE = D2D1_POINTDIFFUSE_PROP.SCALE_MODE;
pub const D2D1_POINTDIFFUSE_PROP_FORCE_DWORD = D2D1_POINTDIFFUSE_PROP.FORCE_DWORD;

pub const D2D1_POINTDIFFUSE_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_POINTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_POINTDIFFUSE_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_POINTDIFFUSE_SCALE_MODE_LINEAR = D2D1_POINTDIFFUSE_SCALE_MODE.LINEAR;
pub const D2D1_POINTDIFFUSE_SCALE_MODE_CUBIC = D2D1_POINTDIFFUSE_SCALE_MODE.CUBIC;
pub const D2D1_POINTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_POINTDIFFUSE_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_POINTDIFFUSE_SCALE_MODE_ANISOTROPIC = D2D1_POINTDIFFUSE_SCALE_MODE.ANISOTROPIC;
pub const D2D1_POINTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_POINTDIFFUSE_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_POINTDIFFUSE_SCALE_MODE_FORCE_DWORD = D2D1_POINTDIFFUSE_SCALE_MODE.FORCE_DWORD;

pub const D2D1_SPOTDIFFUSE_PROP = enum(u32) {
    LIGHT_POSITION = 0,
    POINTS_AT = 1,
    FOCUS = 2,
    LIMITING_CONE_ANGLE = 3,
    DIFFUSE_CONSTANT = 4,
    SURFACE_SCALE = 5,
    COLOR = 6,
    KERNEL_UNIT_LENGTH = 7,
    SCALE_MODE = 8,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SPOTDIFFUSE_PROP_LIGHT_POSITION = D2D1_SPOTDIFFUSE_PROP.LIGHT_POSITION;
pub const D2D1_SPOTDIFFUSE_PROP_POINTS_AT = D2D1_SPOTDIFFUSE_PROP.POINTS_AT;
pub const D2D1_SPOTDIFFUSE_PROP_FOCUS = D2D1_SPOTDIFFUSE_PROP.FOCUS;
pub const D2D1_SPOTDIFFUSE_PROP_LIMITING_CONE_ANGLE = D2D1_SPOTDIFFUSE_PROP.LIMITING_CONE_ANGLE;
pub const D2D1_SPOTDIFFUSE_PROP_DIFFUSE_CONSTANT = D2D1_SPOTDIFFUSE_PROP.DIFFUSE_CONSTANT;
pub const D2D1_SPOTDIFFUSE_PROP_SURFACE_SCALE = D2D1_SPOTDIFFUSE_PROP.SURFACE_SCALE;
pub const D2D1_SPOTDIFFUSE_PROP_COLOR = D2D1_SPOTDIFFUSE_PROP.COLOR;
pub const D2D1_SPOTDIFFUSE_PROP_KERNEL_UNIT_LENGTH = D2D1_SPOTDIFFUSE_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_SPOTDIFFUSE_PROP_SCALE_MODE = D2D1_SPOTDIFFUSE_PROP.SCALE_MODE;
pub const D2D1_SPOTDIFFUSE_PROP_FORCE_DWORD = D2D1_SPOTDIFFUSE_PROP.FORCE_DWORD;

pub const D2D1_SPOTDIFFUSE_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_SPOTDIFFUSE_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_LINEAR = D2D1_SPOTDIFFUSE_SCALE_MODE.LINEAR;
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_CUBIC = D2D1_SPOTDIFFUSE_SCALE_MODE.CUBIC;
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_SPOTDIFFUSE_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_ANISOTROPIC = D2D1_SPOTDIFFUSE_SCALE_MODE.ANISOTROPIC;
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_SPOTDIFFUSE_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_SPOTDIFFUSE_SCALE_MODE_FORCE_DWORD = D2D1_SPOTDIFFUSE_SCALE_MODE.FORCE_DWORD;

pub const D2D1_DISTANTDIFFUSE_PROP = enum(u32) {
    AZIMUTH = 0,
    ELEVATION = 1,
    DIFFUSE_CONSTANT = 2,
    SURFACE_SCALE = 3,
    COLOR = 4,
    KERNEL_UNIT_LENGTH = 5,
    SCALE_MODE = 6,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DISTANTDIFFUSE_PROP_AZIMUTH = D2D1_DISTANTDIFFUSE_PROP.AZIMUTH;
pub const D2D1_DISTANTDIFFUSE_PROP_ELEVATION = D2D1_DISTANTDIFFUSE_PROP.ELEVATION;
pub const D2D1_DISTANTDIFFUSE_PROP_DIFFUSE_CONSTANT = D2D1_DISTANTDIFFUSE_PROP.DIFFUSE_CONSTANT;
pub const D2D1_DISTANTDIFFUSE_PROP_SURFACE_SCALE = D2D1_DISTANTDIFFUSE_PROP.SURFACE_SCALE;
pub const D2D1_DISTANTDIFFUSE_PROP_COLOR = D2D1_DISTANTDIFFUSE_PROP.COLOR;
pub const D2D1_DISTANTDIFFUSE_PROP_KERNEL_UNIT_LENGTH = D2D1_DISTANTDIFFUSE_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_DISTANTDIFFUSE_PROP_SCALE_MODE = D2D1_DISTANTDIFFUSE_PROP.SCALE_MODE;
pub const D2D1_DISTANTDIFFUSE_PROP_FORCE_DWORD = D2D1_DISTANTDIFFUSE_PROP.FORCE_DWORD;

pub const D2D1_DISTANTDIFFUSE_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_DISTANTDIFFUSE_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_LINEAR = D2D1_DISTANTDIFFUSE_SCALE_MODE.LINEAR;
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_CUBIC = D2D1_DISTANTDIFFUSE_SCALE_MODE.CUBIC;
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_DISTANTDIFFUSE_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_ANISOTROPIC = D2D1_DISTANTDIFFUSE_SCALE_MODE.ANISOTROPIC;
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_DISTANTDIFFUSE_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_DISTANTDIFFUSE_SCALE_MODE_FORCE_DWORD = D2D1_DISTANTDIFFUSE_SCALE_MODE.FORCE_DWORD;

pub const D2D1_FLOOD_PROP = enum(u32) {
    COLOR = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_FLOOD_PROP_COLOR = D2D1_FLOOD_PROP.COLOR;
pub const D2D1_FLOOD_PROP_FORCE_DWORD = D2D1_FLOOD_PROP.FORCE_DWORD;

pub const D2D1_LINEARTRANSFER_PROP = enum(u32) {
    RED_Y_INTERCEPT = 0,
    RED_SLOPE = 1,
    RED_DISABLE = 2,
    GREEN_Y_INTERCEPT = 3,
    GREEN_SLOPE = 4,
    GREEN_DISABLE = 5,
    BLUE_Y_INTERCEPT = 6,
    BLUE_SLOPE = 7,
    BLUE_DISABLE = 8,
    ALPHA_Y_INTERCEPT = 9,
    ALPHA_SLOPE = 10,
    ALPHA_DISABLE = 11,
    CLAMP_OUTPUT = 12,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_LINEARTRANSFER_PROP_RED_Y_INTERCEPT = D2D1_LINEARTRANSFER_PROP.RED_Y_INTERCEPT;
pub const D2D1_LINEARTRANSFER_PROP_RED_SLOPE = D2D1_LINEARTRANSFER_PROP.RED_SLOPE;
pub const D2D1_LINEARTRANSFER_PROP_RED_DISABLE = D2D1_LINEARTRANSFER_PROP.RED_DISABLE;
pub const D2D1_LINEARTRANSFER_PROP_GREEN_Y_INTERCEPT = D2D1_LINEARTRANSFER_PROP.GREEN_Y_INTERCEPT;
pub const D2D1_LINEARTRANSFER_PROP_GREEN_SLOPE = D2D1_LINEARTRANSFER_PROP.GREEN_SLOPE;
pub const D2D1_LINEARTRANSFER_PROP_GREEN_DISABLE = D2D1_LINEARTRANSFER_PROP.GREEN_DISABLE;
pub const D2D1_LINEARTRANSFER_PROP_BLUE_Y_INTERCEPT = D2D1_LINEARTRANSFER_PROP.BLUE_Y_INTERCEPT;
pub const D2D1_LINEARTRANSFER_PROP_BLUE_SLOPE = D2D1_LINEARTRANSFER_PROP.BLUE_SLOPE;
pub const D2D1_LINEARTRANSFER_PROP_BLUE_DISABLE = D2D1_LINEARTRANSFER_PROP.BLUE_DISABLE;
pub const D2D1_LINEARTRANSFER_PROP_ALPHA_Y_INTERCEPT = D2D1_LINEARTRANSFER_PROP.ALPHA_Y_INTERCEPT;
pub const D2D1_LINEARTRANSFER_PROP_ALPHA_SLOPE = D2D1_LINEARTRANSFER_PROP.ALPHA_SLOPE;
pub const D2D1_LINEARTRANSFER_PROP_ALPHA_DISABLE = D2D1_LINEARTRANSFER_PROP.ALPHA_DISABLE;
pub const D2D1_LINEARTRANSFER_PROP_CLAMP_OUTPUT = D2D1_LINEARTRANSFER_PROP.CLAMP_OUTPUT;
pub const D2D1_LINEARTRANSFER_PROP_FORCE_DWORD = D2D1_LINEARTRANSFER_PROP.FORCE_DWORD;

pub const D2D1_GAMMATRANSFER_PROP = enum(u32) {
    RED_AMPLITUDE = 0,
    RED_EXPONENT = 1,
    RED_OFFSET = 2,
    RED_DISABLE = 3,
    GREEN_AMPLITUDE = 4,
    GREEN_EXPONENT = 5,
    GREEN_OFFSET = 6,
    GREEN_DISABLE = 7,
    BLUE_AMPLITUDE = 8,
    BLUE_EXPONENT = 9,
    BLUE_OFFSET = 10,
    BLUE_DISABLE = 11,
    ALPHA_AMPLITUDE = 12,
    ALPHA_EXPONENT = 13,
    ALPHA_OFFSET = 14,
    ALPHA_DISABLE = 15,
    CLAMP_OUTPUT = 16,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GAMMATRANSFER_PROP_RED_AMPLITUDE = D2D1_GAMMATRANSFER_PROP.RED_AMPLITUDE;
pub const D2D1_GAMMATRANSFER_PROP_RED_EXPONENT = D2D1_GAMMATRANSFER_PROP.RED_EXPONENT;
pub const D2D1_GAMMATRANSFER_PROP_RED_OFFSET = D2D1_GAMMATRANSFER_PROP.RED_OFFSET;
pub const D2D1_GAMMATRANSFER_PROP_RED_DISABLE = D2D1_GAMMATRANSFER_PROP.RED_DISABLE;
pub const D2D1_GAMMATRANSFER_PROP_GREEN_AMPLITUDE = D2D1_GAMMATRANSFER_PROP.GREEN_AMPLITUDE;
pub const D2D1_GAMMATRANSFER_PROP_GREEN_EXPONENT = D2D1_GAMMATRANSFER_PROP.GREEN_EXPONENT;
pub const D2D1_GAMMATRANSFER_PROP_GREEN_OFFSET = D2D1_GAMMATRANSFER_PROP.GREEN_OFFSET;
pub const D2D1_GAMMATRANSFER_PROP_GREEN_DISABLE = D2D1_GAMMATRANSFER_PROP.GREEN_DISABLE;
pub const D2D1_GAMMATRANSFER_PROP_BLUE_AMPLITUDE = D2D1_GAMMATRANSFER_PROP.BLUE_AMPLITUDE;
pub const D2D1_GAMMATRANSFER_PROP_BLUE_EXPONENT = D2D1_GAMMATRANSFER_PROP.BLUE_EXPONENT;
pub const D2D1_GAMMATRANSFER_PROP_BLUE_OFFSET = D2D1_GAMMATRANSFER_PROP.BLUE_OFFSET;
pub const D2D1_GAMMATRANSFER_PROP_BLUE_DISABLE = D2D1_GAMMATRANSFER_PROP.BLUE_DISABLE;
pub const D2D1_GAMMATRANSFER_PROP_ALPHA_AMPLITUDE = D2D1_GAMMATRANSFER_PROP.ALPHA_AMPLITUDE;
pub const D2D1_GAMMATRANSFER_PROP_ALPHA_EXPONENT = D2D1_GAMMATRANSFER_PROP.ALPHA_EXPONENT;
pub const D2D1_GAMMATRANSFER_PROP_ALPHA_OFFSET = D2D1_GAMMATRANSFER_PROP.ALPHA_OFFSET;
pub const D2D1_GAMMATRANSFER_PROP_ALPHA_DISABLE = D2D1_GAMMATRANSFER_PROP.ALPHA_DISABLE;
pub const D2D1_GAMMATRANSFER_PROP_CLAMP_OUTPUT = D2D1_GAMMATRANSFER_PROP.CLAMP_OUTPUT;
pub const D2D1_GAMMATRANSFER_PROP_FORCE_DWORD = D2D1_GAMMATRANSFER_PROP.FORCE_DWORD;

pub const D2D1_TABLETRANSFER_PROP = enum(u32) {
    RED_TABLE = 0,
    RED_DISABLE = 1,
    GREEN_TABLE = 2,
    GREEN_DISABLE = 3,
    BLUE_TABLE = 4,
    BLUE_DISABLE = 5,
    ALPHA_TABLE = 6,
    ALPHA_DISABLE = 7,
    CLAMP_OUTPUT = 8,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_TABLETRANSFER_PROP_RED_TABLE = D2D1_TABLETRANSFER_PROP.RED_TABLE;
pub const D2D1_TABLETRANSFER_PROP_RED_DISABLE = D2D1_TABLETRANSFER_PROP.RED_DISABLE;
pub const D2D1_TABLETRANSFER_PROP_GREEN_TABLE = D2D1_TABLETRANSFER_PROP.GREEN_TABLE;
pub const D2D1_TABLETRANSFER_PROP_GREEN_DISABLE = D2D1_TABLETRANSFER_PROP.GREEN_DISABLE;
pub const D2D1_TABLETRANSFER_PROP_BLUE_TABLE = D2D1_TABLETRANSFER_PROP.BLUE_TABLE;
pub const D2D1_TABLETRANSFER_PROP_BLUE_DISABLE = D2D1_TABLETRANSFER_PROP.BLUE_DISABLE;
pub const D2D1_TABLETRANSFER_PROP_ALPHA_TABLE = D2D1_TABLETRANSFER_PROP.ALPHA_TABLE;
pub const D2D1_TABLETRANSFER_PROP_ALPHA_DISABLE = D2D1_TABLETRANSFER_PROP.ALPHA_DISABLE;
pub const D2D1_TABLETRANSFER_PROP_CLAMP_OUTPUT = D2D1_TABLETRANSFER_PROP.CLAMP_OUTPUT;
pub const D2D1_TABLETRANSFER_PROP_FORCE_DWORD = D2D1_TABLETRANSFER_PROP.FORCE_DWORD;

pub const D2D1_DISCRETETRANSFER_PROP = enum(u32) {
    RED_TABLE = 0,
    RED_DISABLE = 1,
    GREEN_TABLE = 2,
    GREEN_DISABLE = 3,
    BLUE_TABLE = 4,
    BLUE_DISABLE = 5,
    ALPHA_TABLE = 6,
    ALPHA_DISABLE = 7,
    CLAMP_OUTPUT = 8,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_DISCRETETRANSFER_PROP_RED_TABLE = D2D1_DISCRETETRANSFER_PROP.RED_TABLE;
pub const D2D1_DISCRETETRANSFER_PROP_RED_DISABLE = D2D1_DISCRETETRANSFER_PROP.RED_DISABLE;
pub const D2D1_DISCRETETRANSFER_PROP_GREEN_TABLE = D2D1_DISCRETETRANSFER_PROP.GREEN_TABLE;
pub const D2D1_DISCRETETRANSFER_PROP_GREEN_DISABLE = D2D1_DISCRETETRANSFER_PROP.GREEN_DISABLE;
pub const D2D1_DISCRETETRANSFER_PROP_BLUE_TABLE = D2D1_DISCRETETRANSFER_PROP.BLUE_TABLE;
pub const D2D1_DISCRETETRANSFER_PROP_BLUE_DISABLE = D2D1_DISCRETETRANSFER_PROP.BLUE_DISABLE;
pub const D2D1_DISCRETETRANSFER_PROP_ALPHA_TABLE = D2D1_DISCRETETRANSFER_PROP.ALPHA_TABLE;
pub const D2D1_DISCRETETRANSFER_PROP_ALPHA_DISABLE = D2D1_DISCRETETRANSFER_PROP.ALPHA_DISABLE;
pub const D2D1_DISCRETETRANSFER_PROP_CLAMP_OUTPUT = D2D1_DISCRETETRANSFER_PROP.CLAMP_OUTPUT;
pub const D2D1_DISCRETETRANSFER_PROP_FORCE_DWORD = D2D1_DISCRETETRANSFER_PROP.FORCE_DWORD;

pub const D2D1_CONVOLVEMATRIX_PROP = enum(u32) {
    KERNEL_UNIT_LENGTH = 0,
    SCALE_MODE = 1,
    KERNEL_SIZE_X = 2,
    KERNEL_SIZE_Y = 3,
    KERNEL_MATRIX = 4,
    DIVISOR = 5,
    BIAS = 6,
    KERNEL_OFFSET = 7,
    PRESERVE_ALPHA = 8,
    BORDER_MODE = 9,
    CLAMP_OUTPUT = 10,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CONVOLVEMATRIX_PROP_KERNEL_UNIT_LENGTH = D2D1_CONVOLVEMATRIX_PROP.KERNEL_UNIT_LENGTH;
pub const D2D1_CONVOLVEMATRIX_PROP_SCALE_MODE = D2D1_CONVOLVEMATRIX_PROP.SCALE_MODE;
pub const D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_X = D2D1_CONVOLVEMATRIX_PROP.KERNEL_SIZE_X;
pub const D2D1_CONVOLVEMATRIX_PROP_KERNEL_SIZE_Y = D2D1_CONVOLVEMATRIX_PROP.KERNEL_SIZE_Y;
pub const D2D1_CONVOLVEMATRIX_PROP_KERNEL_MATRIX = D2D1_CONVOLVEMATRIX_PROP.KERNEL_MATRIX;
pub const D2D1_CONVOLVEMATRIX_PROP_DIVISOR = D2D1_CONVOLVEMATRIX_PROP.DIVISOR;
pub const D2D1_CONVOLVEMATRIX_PROP_BIAS = D2D1_CONVOLVEMATRIX_PROP.BIAS;
pub const D2D1_CONVOLVEMATRIX_PROP_KERNEL_OFFSET = D2D1_CONVOLVEMATRIX_PROP.KERNEL_OFFSET;
pub const D2D1_CONVOLVEMATRIX_PROP_PRESERVE_ALPHA = D2D1_CONVOLVEMATRIX_PROP.PRESERVE_ALPHA;
pub const D2D1_CONVOLVEMATRIX_PROP_BORDER_MODE = D2D1_CONVOLVEMATRIX_PROP.BORDER_MODE;
pub const D2D1_CONVOLVEMATRIX_PROP_CLAMP_OUTPUT = D2D1_CONVOLVEMATRIX_PROP.CLAMP_OUTPUT;
pub const D2D1_CONVOLVEMATRIX_PROP_FORCE_DWORD = D2D1_CONVOLVEMATRIX_PROP.FORCE_DWORD;

pub const D2D1_CONVOLVEMATRIX_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_CONVOLVEMATRIX_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_LINEAR = D2D1_CONVOLVEMATRIX_SCALE_MODE.LINEAR;
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_CUBIC = D2D1_CONVOLVEMATRIX_SCALE_MODE.CUBIC;
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_CONVOLVEMATRIX_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_ANISOTROPIC = D2D1_CONVOLVEMATRIX_SCALE_MODE.ANISOTROPIC;
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_HIGH_QUALITY_CUBIC = D2D1_CONVOLVEMATRIX_SCALE_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_CONVOLVEMATRIX_SCALE_MODE_FORCE_DWORD = D2D1_CONVOLVEMATRIX_SCALE_MODE.FORCE_DWORD;

pub const D2D1_BRIGHTNESS_PROP = enum(u32) {
    WHITE_POINT = 0,
    BLACK_POINT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BRIGHTNESS_PROP_WHITE_POINT = D2D1_BRIGHTNESS_PROP.WHITE_POINT;
pub const D2D1_BRIGHTNESS_PROP_BLACK_POINT = D2D1_BRIGHTNESS_PROP.BLACK_POINT;
pub const D2D1_BRIGHTNESS_PROP_FORCE_DWORD = D2D1_BRIGHTNESS_PROP.FORCE_DWORD;

pub const D2D1_ARITHMETICCOMPOSITE_PROP = enum(u32) {
    COEFFICIENTS = 0,
    CLAMP_OUTPUT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_ARITHMETICCOMPOSITE_PROP_COEFFICIENTS = D2D1_ARITHMETICCOMPOSITE_PROP.COEFFICIENTS;
pub const D2D1_ARITHMETICCOMPOSITE_PROP_CLAMP_OUTPUT = D2D1_ARITHMETICCOMPOSITE_PROP.CLAMP_OUTPUT;
pub const D2D1_ARITHMETICCOMPOSITE_PROP_FORCE_DWORD = D2D1_ARITHMETICCOMPOSITE_PROP.FORCE_DWORD;

pub const D2D1_CROP_PROP = enum(u32) {
    RECT = 0,
    BORDER_MODE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CROP_PROP_RECT = D2D1_CROP_PROP.RECT;
pub const D2D1_CROP_PROP_BORDER_MODE = D2D1_CROP_PROP.BORDER_MODE;
pub const D2D1_CROP_PROP_FORCE_DWORD = D2D1_CROP_PROP.FORCE_DWORD;

pub const D2D1_BORDER_PROP = enum(u32) {
    EDGE_MODE_X = 0,
    EDGE_MODE_Y = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BORDER_PROP_EDGE_MODE_X = D2D1_BORDER_PROP.EDGE_MODE_X;
pub const D2D1_BORDER_PROP_EDGE_MODE_Y = D2D1_BORDER_PROP.EDGE_MODE_Y;
pub const D2D1_BORDER_PROP_FORCE_DWORD = D2D1_BORDER_PROP.FORCE_DWORD;

pub const D2D1_BORDER_EDGE_MODE = enum(u32) {
    CLAMP = 0,
    WRAP = 1,
    MIRROR = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BORDER_EDGE_MODE_CLAMP = D2D1_BORDER_EDGE_MODE.CLAMP;
pub const D2D1_BORDER_EDGE_MODE_WRAP = D2D1_BORDER_EDGE_MODE.WRAP;
pub const D2D1_BORDER_EDGE_MODE_MIRROR = D2D1_BORDER_EDGE_MODE.MIRROR;
pub const D2D1_BORDER_EDGE_MODE_FORCE_DWORD = D2D1_BORDER_EDGE_MODE.FORCE_DWORD;

pub const D2D1_MORPHOLOGY_PROP = enum(u32) {
    MODE = 0,
    WIDTH = 1,
    HEIGHT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_MORPHOLOGY_PROP_MODE = D2D1_MORPHOLOGY_PROP.MODE;
pub const D2D1_MORPHOLOGY_PROP_WIDTH = D2D1_MORPHOLOGY_PROP.WIDTH;
pub const D2D1_MORPHOLOGY_PROP_HEIGHT = D2D1_MORPHOLOGY_PROP.HEIGHT;
pub const D2D1_MORPHOLOGY_PROP_FORCE_DWORD = D2D1_MORPHOLOGY_PROP.FORCE_DWORD;

pub const D2D1_MORPHOLOGY_MODE = enum(u32) {
    ERODE = 0,
    DILATE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_MORPHOLOGY_MODE_ERODE = D2D1_MORPHOLOGY_MODE.ERODE;
pub const D2D1_MORPHOLOGY_MODE_DILATE = D2D1_MORPHOLOGY_MODE.DILATE;
pub const D2D1_MORPHOLOGY_MODE_FORCE_DWORD = D2D1_MORPHOLOGY_MODE.FORCE_DWORD;

pub const D2D1_TILE_PROP = enum(u32) {
    RECT = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_TILE_PROP_RECT = D2D1_TILE_PROP.RECT;
pub const D2D1_TILE_PROP_FORCE_DWORD = D2D1_TILE_PROP.FORCE_DWORD;

pub const D2D1_ATLAS_PROP = enum(u32) {
    INPUT_RECT = 0,
    INPUT_PADDING_RECT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_ATLAS_PROP_INPUT_RECT = D2D1_ATLAS_PROP.INPUT_RECT;
pub const D2D1_ATLAS_PROP_INPUT_PADDING_RECT = D2D1_ATLAS_PROP.INPUT_PADDING_RECT;
pub const D2D1_ATLAS_PROP_FORCE_DWORD = D2D1_ATLAS_PROP.FORCE_DWORD;

pub const D2D1_OPACITYMETADATA_PROP = enum(u32) {
    INPUT_OPAQUE_RECT = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_OPACITYMETADATA_PROP_INPUT_OPAQUE_RECT = D2D1_OPACITYMETADATA_PROP.INPUT_OPAQUE_RECT;
pub const D2D1_OPACITYMETADATA_PROP_FORCE_DWORD = D2D1_OPACITYMETADATA_PROP.FORCE_DWORD;

pub const PD2D1_EFFECT_FACTORY = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        effectImpl: ?*?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        effectImpl: ?*?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const D2D1_PROPERTY_TYPE = enum(u32) {
    UNKNOWN = 0,
    STRING = 1,
    BOOL = 2,
    UINT32 = 3,
    INT32 = 4,
    FLOAT = 5,
    VECTOR2 = 6,
    VECTOR3 = 7,
    VECTOR4 = 8,
    BLOB = 9,
    IUNKNOWN = 10,
    ENUM = 11,
    ARRAY = 12,
    CLSID = 13,
    MATRIX_3X2 = 14,
    MATRIX_4X3 = 15,
    MATRIX_4X4 = 16,
    MATRIX_5X4 = 17,
    COLOR_CONTEXT = 18,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_PROPERTY_TYPE_UNKNOWN = D2D1_PROPERTY_TYPE.UNKNOWN;
pub const D2D1_PROPERTY_TYPE_STRING = D2D1_PROPERTY_TYPE.STRING;
pub const D2D1_PROPERTY_TYPE_BOOL = D2D1_PROPERTY_TYPE.BOOL;
pub const D2D1_PROPERTY_TYPE_UINT32 = D2D1_PROPERTY_TYPE.UINT32;
pub const D2D1_PROPERTY_TYPE_INT32 = D2D1_PROPERTY_TYPE.INT32;
pub const D2D1_PROPERTY_TYPE_FLOAT = D2D1_PROPERTY_TYPE.FLOAT;
pub const D2D1_PROPERTY_TYPE_VECTOR2 = D2D1_PROPERTY_TYPE.VECTOR2;
pub const D2D1_PROPERTY_TYPE_VECTOR3 = D2D1_PROPERTY_TYPE.VECTOR3;
pub const D2D1_PROPERTY_TYPE_VECTOR4 = D2D1_PROPERTY_TYPE.VECTOR4;
pub const D2D1_PROPERTY_TYPE_BLOB = D2D1_PROPERTY_TYPE.BLOB;
pub const D2D1_PROPERTY_TYPE_IUNKNOWN = D2D1_PROPERTY_TYPE.IUNKNOWN;
pub const D2D1_PROPERTY_TYPE_ENUM = D2D1_PROPERTY_TYPE.ENUM;
pub const D2D1_PROPERTY_TYPE_ARRAY = D2D1_PROPERTY_TYPE.ARRAY;
pub const D2D1_PROPERTY_TYPE_CLSID = D2D1_PROPERTY_TYPE.CLSID;
pub const D2D1_PROPERTY_TYPE_MATRIX_3X2 = D2D1_PROPERTY_TYPE.MATRIX_3X2;
pub const D2D1_PROPERTY_TYPE_MATRIX_4X3 = D2D1_PROPERTY_TYPE.MATRIX_4X3;
pub const D2D1_PROPERTY_TYPE_MATRIX_4X4 = D2D1_PROPERTY_TYPE.MATRIX_4X4;
pub const D2D1_PROPERTY_TYPE_MATRIX_5X4 = D2D1_PROPERTY_TYPE.MATRIX_5X4;
pub const D2D1_PROPERTY_TYPE_COLOR_CONTEXT = D2D1_PROPERTY_TYPE.COLOR_CONTEXT;
pub const D2D1_PROPERTY_TYPE_FORCE_DWORD = D2D1_PROPERTY_TYPE.FORCE_DWORD;

pub const D2D1_PROPERTY = enum(u32) {
    CLSID = 2147483648,
    DISPLAYNAME = 2147483649,
    AUTHOR = 2147483650,
    CATEGORY = 2147483651,
    DESCRIPTION = 2147483652,
    INPUTS = 2147483653,
    CACHED = 2147483654,
    PRECISION = 2147483655,
    MIN_INPUTS = 2147483656,
    MAX_INPUTS = 2147483657,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_PROPERTY_CLSID = D2D1_PROPERTY.CLSID;
pub const D2D1_PROPERTY_DISPLAYNAME = D2D1_PROPERTY.DISPLAYNAME;
pub const D2D1_PROPERTY_AUTHOR = D2D1_PROPERTY.AUTHOR;
pub const D2D1_PROPERTY_CATEGORY = D2D1_PROPERTY.CATEGORY;
pub const D2D1_PROPERTY_DESCRIPTION = D2D1_PROPERTY.DESCRIPTION;
pub const D2D1_PROPERTY_INPUTS = D2D1_PROPERTY.INPUTS;
pub const D2D1_PROPERTY_CACHED = D2D1_PROPERTY.CACHED;
pub const D2D1_PROPERTY_PRECISION = D2D1_PROPERTY.PRECISION;
pub const D2D1_PROPERTY_MIN_INPUTS = D2D1_PROPERTY.MIN_INPUTS;
pub const D2D1_PROPERTY_MAX_INPUTS = D2D1_PROPERTY.MAX_INPUTS;
pub const D2D1_PROPERTY_FORCE_DWORD = D2D1_PROPERTY.FORCE_DWORD;

pub const D2D1_SUBPROPERTY = enum(u32) {
    DISPLAYNAME = 2147483648,
    ISREADONLY = 2147483649,
    MIN = 2147483650,
    MAX = 2147483651,
    DEFAULT = 2147483652,
    FIELDS = 2147483653,
    INDEX = 2147483654,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SUBPROPERTY_DISPLAYNAME = D2D1_SUBPROPERTY.DISPLAYNAME;
pub const D2D1_SUBPROPERTY_ISREADONLY = D2D1_SUBPROPERTY.ISREADONLY;
pub const D2D1_SUBPROPERTY_MIN = D2D1_SUBPROPERTY.MIN;
pub const D2D1_SUBPROPERTY_MAX = D2D1_SUBPROPERTY.MAX;
pub const D2D1_SUBPROPERTY_DEFAULT = D2D1_SUBPROPERTY.DEFAULT;
pub const D2D1_SUBPROPERTY_FIELDS = D2D1_SUBPROPERTY.FIELDS;
pub const D2D1_SUBPROPERTY_INDEX = D2D1_SUBPROPERTY.INDEX;
pub const D2D1_SUBPROPERTY_FORCE_DWORD = D2D1_SUBPROPERTY.FORCE_DWORD;

pub const D2D1_BITMAP_OPTIONS = enum(u32) {
    NONE = 0,
    TARGET = 1,
    CANNOT_DRAW = 2,
    CPU_READ = 4,
    GDI_COMPATIBLE = 8,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        TARGET: u1 = 0,
        CANNOT_DRAW: u1 = 0,
        CPU_READ: u1 = 0,
        GDI_COMPATIBLE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_BITMAP_OPTIONS {
        return @as(D2D1_BITMAP_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_BITMAP_OPTIONS.NONE) else 0)
            | (if (o.TARGET == 1) @intFromEnum(D2D1_BITMAP_OPTIONS.TARGET) else 0)
            | (if (o.CANNOT_DRAW == 1) @intFromEnum(D2D1_BITMAP_OPTIONS.CANNOT_DRAW) else 0)
            | (if (o.CPU_READ == 1) @intFromEnum(D2D1_BITMAP_OPTIONS.CPU_READ) else 0)
            | (if (o.GDI_COMPATIBLE == 1) @intFromEnum(D2D1_BITMAP_OPTIONS.GDI_COMPATIBLE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_BITMAP_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_BITMAP_OPTIONS_NONE = D2D1_BITMAP_OPTIONS.NONE;
pub const D2D1_BITMAP_OPTIONS_TARGET = D2D1_BITMAP_OPTIONS.TARGET;
pub const D2D1_BITMAP_OPTIONS_CANNOT_DRAW = D2D1_BITMAP_OPTIONS.CANNOT_DRAW;
pub const D2D1_BITMAP_OPTIONS_CPU_READ = D2D1_BITMAP_OPTIONS.CPU_READ;
pub const D2D1_BITMAP_OPTIONS_GDI_COMPATIBLE = D2D1_BITMAP_OPTIONS.GDI_COMPATIBLE;
pub const D2D1_BITMAP_OPTIONS_FORCE_DWORD = D2D1_BITMAP_OPTIONS.FORCE_DWORD;

pub const D2D1_BUFFER_PRECISION = enum(u32) {
    UNKNOWN = 0,
    @"8BPC_UNORM" = 1,
    @"8BPC_UNORM_SRGB" = 2,
    @"16BPC_UNORM" = 3,
    @"16BPC_FLOAT" = 4,
    @"32BPC_FLOAT" = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BUFFER_PRECISION_UNKNOWN = D2D1_BUFFER_PRECISION.UNKNOWN;
pub const D2D1_BUFFER_PRECISION_8BPC_UNORM = D2D1_BUFFER_PRECISION.@"8BPC_UNORM";
pub const D2D1_BUFFER_PRECISION_8BPC_UNORM_SRGB = D2D1_BUFFER_PRECISION.@"8BPC_UNORM_SRGB";
pub const D2D1_BUFFER_PRECISION_16BPC_UNORM = D2D1_BUFFER_PRECISION.@"16BPC_UNORM";
pub const D2D1_BUFFER_PRECISION_16BPC_FLOAT = D2D1_BUFFER_PRECISION.@"16BPC_FLOAT";
pub const D2D1_BUFFER_PRECISION_32BPC_FLOAT = D2D1_BUFFER_PRECISION.@"32BPC_FLOAT";
pub const D2D1_BUFFER_PRECISION_FORCE_DWORD = D2D1_BUFFER_PRECISION.FORCE_DWORD;

pub const D2D1_MAP_OPTIONS = enum(u32) {
    NONE = 0,
    READ = 1,
    WRITE = 2,
    DISCARD = 4,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        READ: u1 = 0,
        WRITE: u1 = 0,
        DISCARD: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_MAP_OPTIONS {
        return @as(D2D1_MAP_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_MAP_OPTIONS.NONE) else 0)
            | (if (o.READ == 1) @intFromEnum(D2D1_MAP_OPTIONS.READ) else 0)
            | (if (o.WRITE == 1) @intFromEnum(D2D1_MAP_OPTIONS.WRITE) else 0)
            | (if (o.DISCARD == 1) @intFromEnum(D2D1_MAP_OPTIONS.DISCARD) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_MAP_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_MAP_OPTIONS_NONE = D2D1_MAP_OPTIONS.NONE;
pub const D2D1_MAP_OPTIONS_READ = D2D1_MAP_OPTIONS.READ;
pub const D2D1_MAP_OPTIONS_WRITE = D2D1_MAP_OPTIONS.WRITE;
pub const D2D1_MAP_OPTIONS_DISCARD = D2D1_MAP_OPTIONS.DISCARD;
pub const D2D1_MAP_OPTIONS_FORCE_DWORD = D2D1_MAP_OPTIONS.FORCE_DWORD;

pub const D2D1_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_INTERPOLATION_MODE_LINEAR = D2D1_INTERPOLATION_MODE.LINEAR;
pub const D2D1_INTERPOLATION_MODE_CUBIC = D2D1_INTERPOLATION_MODE.CUBIC;
pub const D2D1_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_INTERPOLATION_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_INTERPOLATION_MODE_ANISOTROPIC = D2D1_INTERPOLATION_MODE.ANISOTROPIC;
pub const D2D1_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = D2D1_INTERPOLATION_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_INTERPOLATION_MODE_FORCE_DWORD = D2D1_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_UNIT_MODE = enum(u32) {
    DIPS = 0,
    PIXELS = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_UNIT_MODE_DIPS = D2D1_UNIT_MODE.DIPS;
pub const D2D1_UNIT_MODE_PIXELS = D2D1_UNIT_MODE.PIXELS;
pub const D2D1_UNIT_MODE_FORCE_DWORD = D2D1_UNIT_MODE.FORCE_DWORD;

pub const D2D1_COLOR_SPACE = enum(u32) {
    CUSTOM = 0,
    SRGB = 1,
    SCRGB = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLOR_SPACE_CUSTOM = D2D1_COLOR_SPACE.CUSTOM;
pub const D2D1_COLOR_SPACE_SRGB = D2D1_COLOR_SPACE.SRGB;
pub const D2D1_COLOR_SPACE_SCRGB = D2D1_COLOR_SPACE.SCRGB;
pub const D2D1_COLOR_SPACE_FORCE_DWORD = D2D1_COLOR_SPACE.FORCE_DWORD;

pub const D2D1_DEVICE_CONTEXT_OPTIONS = enum(u32) {
    NONE = 0,
    ENABLE_MULTITHREADED_OPTIMIZATIONS = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        ENABLE_MULTITHREADED_OPTIMIZATIONS: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_DEVICE_CONTEXT_OPTIONS {
        return @as(D2D1_DEVICE_CONTEXT_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_DEVICE_CONTEXT_OPTIONS.NONE) else 0)
            | (if (o.ENABLE_MULTITHREADED_OPTIMIZATIONS == 1) @intFromEnum(D2D1_DEVICE_CONTEXT_OPTIONS.ENABLE_MULTITHREADED_OPTIMIZATIONS) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_DEVICE_CONTEXT_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_DEVICE_CONTEXT_OPTIONS_NONE = D2D1_DEVICE_CONTEXT_OPTIONS.NONE;
pub const D2D1_DEVICE_CONTEXT_OPTIONS_ENABLE_MULTITHREADED_OPTIMIZATIONS = D2D1_DEVICE_CONTEXT_OPTIONS.ENABLE_MULTITHREADED_OPTIMIZATIONS;
pub const D2D1_DEVICE_CONTEXT_OPTIONS_FORCE_DWORD = D2D1_DEVICE_CONTEXT_OPTIONS.FORCE_DWORD;

pub const D2D1_STROKE_TRANSFORM_TYPE = enum(u32) {
    NORMAL = 0,
    FIXED = 1,
    HAIRLINE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_STROKE_TRANSFORM_TYPE_NORMAL = D2D1_STROKE_TRANSFORM_TYPE.NORMAL;
pub const D2D1_STROKE_TRANSFORM_TYPE_FIXED = D2D1_STROKE_TRANSFORM_TYPE.FIXED;
pub const D2D1_STROKE_TRANSFORM_TYPE_HAIRLINE = D2D1_STROKE_TRANSFORM_TYPE.HAIRLINE;
pub const D2D1_STROKE_TRANSFORM_TYPE_FORCE_DWORD = D2D1_STROKE_TRANSFORM_TYPE.FORCE_DWORD;

pub const D2D1_PRIMITIVE_BLEND = enum(u32) {
    SOURCE_OVER = 0,
    COPY = 1,
    MIN = 2,
    ADD = 3,
    MAX = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_PRIMITIVE_BLEND_SOURCE_OVER = D2D1_PRIMITIVE_BLEND.SOURCE_OVER;
pub const D2D1_PRIMITIVE_BLEND_COPY = D2D1_PRIMITIVE_BLEND.COPY;
pub const D2D1_PRIMITIVE_BLEND_MIN = D2D1_PRIMITIVE_BLEND.MIN;
pub const D2D1_PRIMITIVE_BLEND_ADD = D2D1_PRIMITIVE_BLEND.ADD;
pub const D2D1_PRIMITIVE_BLEND_MAX = D2D1_PRIMITIVE_BLEND.MAX;
pub const D2D1_PRIMITIVE_BLEND_FORCE_DWORD = D2D1_PRIMITIVE_BLEND.FORCE_DWORD;

pub const D2D1_THREADING_MODE = enum(u32) {
    SINGLE_THREADED = 0,
    MULTI_THREADED = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_THREADING_MODE_SINGLE_THREADED = D2D1_THREADING_MODE.SINGLE_THREADED;
pub const D2D1_THREADING_MODE_MULTI_THREADED = D2D1_THREADING_MODE.MULTI_THREADED;
pub const D2D1_THREADING_MODE_FORCE_DWORD = D2D1_THREADING_MODE.FORCE_DWORD;

pub const D2D1_COLOR_INTERPOLATION_MODE = enum(u32) {
    STRAIGHT = 0,
    PREMULTIPLIED = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLOR_INTERPOLATION_MODE_STRAIGHT = D2D1_COLOR_INTERPOLATION_MODE.STRAIGHT;
pub const D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED = D2D1_COLOR_INTERPOLATION_MODE.PREMULTIPLIED;
pub const D2D1_COLOR_INTERPOLATION_MODE_FORCE_DWORD = D2D1_COLOR_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_BITMAP_PROPERTIES1 = extern struct {
    pixelFormat: D2D1_PIXEL_FORMAT,
    dpiX: f32,
    dpiY: f32,
    bitmapOptions: D2D1_BITMAP_OPTIONS,
    colorContext: ?*ID2D1ColorContext,
};

pub const D2D1_MAPPED_RECT = extern struct {
    pitch: u32,
    bits: ?*u8,
};

pub const D2D1_RENDERING_CONTROLS = extern struct {
    bufferPrecision: D2D1_BUFFER_PRECISION,
    tileSize: D2D_SIZE_U,
};

pub const D2D1_EFFECT_INPUT_DESCRIPTION = extern struct {
    effect: ?*ID2D1Effect,
    inputIndex: u32,
    inputRectangle: D2D_RECT_F,
};

pub const D2D1_POINT_DESCRIPTION = extern struct {
    point: D2D_POINT_2F,
    unitTangentVector: D2D_POINT_2F,
    endSegment: u32,
    endFigure: u32,
    lengthToEndSegment: f32,
};

pub const D2D1_IMAGE_BRUSH_PROPERTIES = extern struct {
    sourceRectangle: D2D_RECT_F,
    extendModeX: D2D1_EXTEND_MODE,
    extendModeY: D2D1_EXTEND_MODE,
    interpolationMode: D2D1_INTERPOLATION_MODE,
};

pub const D2D1_BITMAP_BRUSH_PROPERTIES1 = extern struct {
    extendModeX: D2D1_EXTEND_MODE,
    extendModeY: D2D1_EXTEND_MODE,
    interpolationMode: D2D1_INTERPOLATION_MODE,
};

pub const D2D1_STROKE_STYLE_PROPERTIES1 = extern struct {
    startCap: D2D1_CAP_STYLE,
    endCap: D2D1_CAP_STYLE,
    dashCap: D2D1_CAP_STYLE,
    lineJoin: D2D1_LINE_JOIN,
    miterLimit: f32,
    dashStyle: D2D1_DASH_STYLE,
    dashOffset: f32,
    transformType: D2D1_STROKE_TRANSFORM_TYPE,
};

pub const D2D1_LAYER_OPTIONS1 = enum(u32) {
    NONE = 0,
    INITIALIZE_FROM_BACKGROUND = 1,
    IGNORE_ALPHA = 2,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        INITIALIZE_FROM_BACKGROUND: u1 = 0,
        IGNORE_ALPHA: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_LAYER_OPTIONS1 {
        return @as(D2D1_LAYER_OPTIONS1, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_LAYER_OPTIONS1.NONE) else 0)
            | (if (o.INITIALIZE_FROM_BACKGROUND == 1) @intFromEnum(D2D1_LAYER_OPTIONS1.INITIALIZE_FROM_BACKGROUND) else 0)
            | (if (o.IGNORE_ALPHA == 1) @intFromEnum(D2D1_LAYER_OPTIONS1.IGNORE_ALPHA) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_LAYER_OPTIONS1.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_LAYER_OPTIONS1_NONE = D2D1_LAYER_OPTIONS1.NONE;
pub const D2D1_LAYER_OPTIONS1_INITIALIZE_FROM_BACKGROUND = D2D1_LAYER_OPTIONS1.INITIALIZE_FROM_BACKGROUND;
pub const D2D1_LAYER_OPTIONS1_IGNORE_ALPHA = D2D1_LAYER_OPTIONS1.IGNORE_ALPHA;
pub const D2D1_LAYER_OPTIONS1_FORCE_DWORD = D2D1_LAYER_OPTIONS1.FORCE_DWORD;

pub const D2D1_LAYER_PARAMETERS1 = extern struct {
    contentBounds: D2D_RECT_F,
    geometricMask: ?*ID2D1Geometry,
    maskAntialiasMode: D2D1_ANTIALIAS_MODE,
    maskTransform: D2D_MATRIX_3X2_F,
    opacity: f32,
    opacityBrush: ?*ID2D1Brush,
    layerOptions: D2D1_LAYER_OPTIONS1,
};

pub const D2D1_PRINT_FONT_SUBSET_MODE = enum(u32) {
    DEFAULT = 0,
    EACHPAGE = 1,
    NONE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_PRINT_FONT_SUBSET_MODE_DEFAULT = D2D1_PRINT_FONT_SUBSET_MODE.DEFAULT;
pub const D2D1_PRINT_FONT_SUBSET_MODE_EACHPAGE = D2D1_PRINT_FONT_SUBSET_MODE.EACHPAGE;
pub const D2D1_PRINT_FONT_SUBSET_MODE_NONE = D2D1_PRINT_FONT_SUBSET_MODE.NONE;
pub const D2D1_PRINT_FONT_SUBSET_MODE_FORCE_DWORD = D2D1_PRINT_FONT_SUBSET_MODE.FORCE_DWORD;

pub const D2D1_DRAWING_STATE_DESCRIPTION1 = extern struct {
    antialiasMode: D2D1_ANTIALIAS_MODE,
    textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE,
    tag1: u64,
    tag2: u64,
    transform: D2D_MATRIX_3X2_F,
    primitiveBlend: D2D1_PRIMITIVE_BLEND,
    unitMode: D2D1_UNIT_MODE,
};

pub const D2D1_PRINT_CONTROL_PROPERTIES = extern struct {
    fontSubset: D2D1_PRINT_FONT_SUBSET_MODE,
    rasterDPI: f32,
    colorSpace: D2D1_COLOR_SPACE,
};

pub const D2D1_CREATION_PROPERTIES = extern struct {
    threadingMode: D2D1_THREADING_MODE,
    debugLevel: D2D1_DEBUG_LEVEL,
    options: D2D1_DEVICE_CONTEXT_OPTIONS,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1GdiMetafileSink_Value = Guid.initString("82237326-8111-4f7c-bcf4-b5c1175564fe");
pub const IID_ID2D1GdiMetafileSink = &IID_ID2D1GdiMetafileSink_Value;
pub const ID2D1GdiMetafileSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProcessRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiMetafileSink,
                recordType: u32,
                recordData: ?*const anyopaque,
                recordDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiMetafileSink,
                recordType: u32,
                recordData: ?*const anyopaque,
                recordDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiMetafileSink_ProcessRecord(self: *const T, recordType: u32, recordData: ?*const anyopaque, recordDataSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiMetafileSink.VTable, @ptrCast(self.vtable)).ProcessRecord(@as(*const ID2D1GdiMetafileSink, @ptrCast(self)), recordType, recordData, recordDataSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1GdiMetafile_Value = Guid.initString("2f543dc3-cfc1-4211-864f-cfd91c6f3395");
pub const IID_ID2D1GdiMetafile = &IID_ID2D1GdiMetafile_Value;
pub const ID2D1GdiMetafile = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        Stream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiMetafile,
                sink: ?*ID2D1GdiMetafileSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiMetafile,
                sink: ?*ID2D1GdiMetafileSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiMetafile,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiMetafile,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiMetafile_Stream(self: *const T, sink: ?*ID2D1GdiMetafileSink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiMetafile.VTable, @ptrCast(self.vtable)).Stream(@as(*const ID2D1GdiMetafile, @ptrCast(self)), sink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiMetafile_GetBounds(self: *const T, bounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiMetafile.VTable, @ptrCast(self.vtable)).GetBounds(@as(*const ID2D1GdiMetafile, @ptrCast(self)), bounds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1CommandSink_Value = Guid.initString("54d7898a-a061-40a7-bec7-e465bcba2c4f");
pub const IID_ID2D1CommandSink = &IID_ID2D1CommandSink_Value;
pub const ID2D1CommandSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAntialiasMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                tag1: u64,
                tag2: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                tag1: u64,
                tag2: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextAntialiasMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextRenderingParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                textRenderingParams: ?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                textRenderingParams: ?*IDWriteRenderingParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPrimitiveBlend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnitMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                unitMode: D2D1_UNIT_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                unitMode: D2D1_UNIT_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                color: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                color: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawGlyphRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                glyphRunDescription: ?*const DWRITE_GLYPH_RUN_DESCRIPTION,
                foregroundBrush: ?*ID2D1Brush,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                glyphRunDescription: ?*const DWRITE_GLYPH_RUN_DESCRIPTION,
                foregroundBrush: ?*ID2D1Brush,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                point0: D2D_POINT_2F,
                point1: D2D_POINT_2F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                point0: D2D_POINT_2F,
                point1: D2D_POINT_2F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                bitmap: ?*ID2D1Bitmap,
                destinationRectangle: ?*const D2D_RECT_F,
                opacity: f32,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                sourceRectangle: ?*const D2D_RECT_F,
                perspectiveTransform: ?*const D2D_MATRIX_4X4_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                bitmap: ?*ID2D1Bitmap,
                destinationRectangle: ?*const D2D_RECT_F,
                opacity: f32,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                sourceRectangle: ?*const D2D_RECT_F,
                perspectiveTransform: ?*const D2D_MATRIX_4X4_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                image: ?*ID2D1Image,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                compositeMode: D2D1_COMPOSITE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                image: ?*ID2D1Image,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                compositeMode: D2D1_COMPOSITE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawGdiMetafile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                gdiMetafile: ?*ID2D1GdiMetafile,
                targetOffset: ?*const D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                gdiMetafile: ?*ID2D1GdiMetafile,
                targetOffset: ?*const D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillMesh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                mesh: ?*ID2D1Mesh,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                mesh: ?*ID2D1Mesh,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillOpacityMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                opacityMask: ?*ID2D1Bitmap,
                brush: ?*ID2D1Brush,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                opacityMask: ?*ID2D1Bitmap,
                brush: ?*ID2D1Brush,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                opacityBrush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                geometry: ?*ID2D1Geometry,
                brush: ?*ID2D1Brush,
                opacityBrush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                rect: ?*const D2D_RECT_F,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushAxisAlignedClip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                clipRect: ?*const D2D_RECT_F,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                clipRect: ?*const D2D_RECT_F,
                antialiasMode: D2D1_ANTIALIAS_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushLayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
                layerParameters1: ?*const D2D1_LAYER_PARAMETERS1,
                layer: ?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
                layerParameters1: ?*const D2D1_LAYER_PARAMETERS1,
                layer: ?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopAxisAlignedClip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopLayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_BeginDraw(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).BeginDraw(@as(*const ID2D1CommandSink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).EndDraw(@as(*const ID2D1CommandSink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetAntialiasMode(self: *const T, antialiasMode: D2D1_ANTIALIAS_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetAntialiasMode(@as(*const ID2D1CommandSink, @ptrCast(self)), antialiasMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetTags(self: *const T, tag1: u64, tag2: u64) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetTags(@as(*const ID2D1CommandSink, @ptrCast(self)), tag1, tag2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetTextAntialiasMode(self: *const T, textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetTextAntialiasMode(@as(*const ID2D1CommandSink, @ptrCast(self)), textAntialiasMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetTextRenderingParams(self: *const T, textRenderingParams: ?*IDWriteRenderingParams) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetTextRenderingParams(@as(*const ID2D1CommandSink, @ptrCast(self)), textRenderingParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetTransform(self: *const T, transform: ?*const D2D_MATRIX_3X2_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetTransform(@as(*const ID2D1CommandSink, @ptrCast(self)), transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetPrimitiveBlend(self: *const T, primitiveBlend: D2D1_PRIMITIVE_BLEND) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetPrimitiveBlend(@as(*const ID2D1CommandSink, @ptrCast(self)), primitiveBlend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_SetUnitMode(self: *const T, unitMode: D2D1_UNIT_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).SetUnitMode(@as(*const ID2D1CommandSink, @ptrCast(self)), unitMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_Clear(self: *const T, color: ?*const D2D1_COLOR_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).Clear(@as(*const ID2D1CommandSink, @ptrCast(self)), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawGlyphRun(self: *const T, baselineOrigin: D2D_POINT_2F, glyphRun: ?*const DWRITE_GLYPH_RUN, glyphRunDescription: ?*const DWRITE_GLYPH_RUN_DESCRIPTION, foregroundBrush: ?*ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawGlyphRun(@as(*const ID2D1CommandSink, @ptrCast(self)), baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawLine(self: *const T, point0: D2D_POINT_2F, point1: D2D_POINT_2F, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawLine(@as(*const ID2D1CommandSink, @ptrCast(self)), point0, point1, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawGeometry(self: *const T, geometry: ?*ID2D1Geometry, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawGeometry(@as(*const ID2D1CommandSink, @ptrCast(self)), geometry, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawRectangle(self: *const T, rect: ?*const D2D_RECT_F, brush: ?*ID2D1Brush, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawRectangle(@as(*const ID2D1CommandSink, @ptrCast(self)), rect, brush, strokeWidth, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawBitmap(self: *const T, bitmap: ?*ID2D1Bitmap, destinationRectangle: ?*const D2D_RECT_F, opacity: f32, interpolationMode: D2D1_INTERPOLATION_MODE, sourceRectangle: ?*const D2D_RECT_F, perspectiveTransform: ?*const D2D_MATRIX_4X4_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ID2D1CommandSink, @ptrCast(self)), bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawImage(self: *const T, image: ?*ID2D1Image, targetOffset: ?*const D2D_POINT_2F, imageRectangle: ?*const D2D_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE, compositeMode: D2D1_COMPOSITE_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawImage(@as(*const ID2D1CommandSink, @ptrCast(self)), image, targetOffset, imageRectangle, interpolationMode, compositeMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_DrawGdiMetafile(self: *const T, gdiMetafile: ?*ID2D1GdiMetafile, targetOffset: ?*const D2D_POINT_2F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).DrawGdiMetafile(@as(*const ID2D1CommandSink, @ptrCast(self)), gdiMetafile, targetOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_FillMesh(self: *const T, mesh: ?*ID2D1Mesh, brush: ?*ID2D1Brush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).FillMesh(@as(*const ID2D1CommandSink, @ptrCast(self)), mesh, brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_FillOpacityMask(self: *const T, opacityMask: ?*ID2D1Bitmap, brush: ?*ID2D1Brush, destinationRectangle: ?*const D2D_RECT_F, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).FillOpacityMask(@as(*const ID2D1CommandSink, @ptrCast(self)), opacityMask, brush, destinationRectangle, sourceRectangle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_FillGeometry(self: *const T, geometry: ?*ID2D1Geometry, brush: ?*ID2D1Brush, opacityBrush: ?*ID2D1Brush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).FillGeometry(@as(*const ID2D1CommandSink, @ptrCast(self)), geometry, brush, opacityBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_FillRectangle(self: *const T, rect: ?*const D2D_RECT_F, brush: ?*ID2D1Brush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).FillRectangle(@as(*const ID2D1CommandSink, @ptrCast(self)), rect, brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_PushAxisAlignedClip(self: *const T, clipRect: ?*const D2D_RECT_F, antialiasMode: D2D1_ANTIALIAS_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).PushAxisAlignedClip(@as(*const ID2D1CommandSink, @ptrCast(self)), clipRect, antialiasMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_PushLayer(self: *const T, layerParameters1: ?*const D2D1_LAYER_PARAMETERS1, layer: ?*ID2D1Layer) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).PushLayer(@as(*const ID2D1CommandSink, @ptrCast(self)), layerParameters1, layer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_PopAxisAlignedClip(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).PopAxisAlignedClip(@as(*const ID2D1CommandSink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink_PopLayer(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink.VTable, @ptrCast(self.vtable)).PopLayer(@as(*const ID2D1CommandSink, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1CommandList_Value = Guid.initString("b4f34a19-2383-4d76-94f6-ec343657c3dc");
pub const IID_ID2D1CommandList = &IID_ID2D1CommandList_Value;
pub const ID2D1CommandList = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Image.VTable,
        Stream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandList,
                sink: ?*ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandList,
                sink: ?*ID2D1CommandSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Image.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandList_Stream(self: *const T, sink: ?*ID2D1CommandSink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandList.VTable, @ptrCast(self.vtable)).Stream(@as(*const ID2D1CommandList, @ptrCast(self)), sink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandList_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandList.VTable, @ptrCast(self.vtable)).Close(@as(*const ID2D1CommandList, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1PrintControl_Value = Guid.initString("2c1d867d-c290-41c8-ae7e-34a98702e9a5");
pub const IID_ID2D1PrintControl = &IID_ID2D1PrintControl_Value;
pub const ID2D1PrintControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PrintControl,
                commandList: ?*ID2D1CommandList,
                pageSize: D2D_SIZE_F,
                pagePrintTicketStream: ?*IStream,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PrintControl,
                commandList: ?*ID2D1CommandList,
                pageSize: D2D_SIZE_F,
                pagePrintTicketStream: ?*IStream,
                tag1: ?*u64,
                tag2: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PrintControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PrintControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PrintControl_AddPage(self: *const T, commandList: ?*ID2D1CommandList, pageSize: D2D_SIZE_F, pagePrintTicketStream: ?*IStream, tag1: ?*u64, tag2: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PrintControl.VTable, @ptrCast(self.vtable)).AddPage(@as(*const ID2D1PrintControl, @ptrCast(self)), commandList, pageSize, pagePrintTicketStream, tag1, tag2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PrintControl_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PrintControl.VTable, @ptrCast(self.vtable)).Close(@as(*const ID2D1PrintControl, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1ImageBrush_Value = Guid.initString("fe9e984d-3f95-407c-b5db-cb94d4e8f87c");
pub const IID_ID2D1ImageBrush = &IID_ID2D1ImageBrush_Value;
pub const ID2D1ImageBrush = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Brush.VTable,
        SetImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                image: ?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                image: ?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetExtendModeX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                extendModeX: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                extendModeX: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetExtendModeY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                extendModeY: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                extendModeY: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetInterpolationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetSourceRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                image: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                image: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetExtendModeX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
        GetExtendModeY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
        GetInterpolationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INTERPOLATION_MODE,
            else => *const fn(
                self: *const ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INTERPOLATION_MODE,
        },
        GetSourceRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageBrush,
                sourceRectangle: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageBrush,
                sourceRectangle: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Brush.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_SetImage(self: *const T, image: ?*ID2D1Image) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).SetImage(@as(*const ID2D1ImageBrush, @ptrCast(self)), image);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_SetExtendModeX(self: *const T, extendModeX: D2D1_EXTEND_MODE) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).SetExtendModeX(@as(*const ID2D1ImageBrush, @ptrCast(self)), extendModeX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_SetExtendModeY(self: *const T, extendModeY: D2D1_EXTEND_MODE) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).SetExtendModeY(@as(*const ID2D1ImageBrush, @ptrCast(self)), extendModeY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_SetInterpolationMode(self: *const T, interpolationMode: D2D1_INTERPOLATION_MODE) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).SetInterpolationMode(@as(*const ID2D1ImageBrush, @ptrCast(self)), interpolationMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_SetSourceRectangle(self: *const T, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).SetSourceRectangle(@as(*const ID2D1ImageBrush, @ptrCast(self)), sourceRectangle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_GetImage(self: *const T, image: ?*?*ID2D1Image) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).GetImage(@as(*const ID2D1ImageBrush, @ptrCast(self)), image);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_GetExtendModeX(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).GetExtendModeX(@as(*const ID2D1ImageBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_GetExtendModeY(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).GetExtendModeY(@as(*const ID2D1ImageBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_GetInterpolationMode(self: *const T) callconv(.Inline) D2D1_INTERPOLATION_MODE {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).GetInterpolationMode(@as(*const ID2D1ImageBrush, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageBrush_GetSourceRectangle(self: *const T, sourceRectangle: ?*D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1ImageBrush.VTable, @ptrCast(self.vtable)).GetSourceRectangle(@as(*const ID2D1ImageBrush, @ptrCast(self)), sourceRectangle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1BitmapBrush1_Value = Guid.initString("41343a53-e41a-49a2-91cd-21793bbb62e5");
pub const IID_ID2D1BitmapBrush1 = &IID_ID2D1BitmapBrush1_Value;
pub const ID2D1BitmapBrush1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1BitmapBrush.VTable,
        SetInterpolationMode1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush1,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BitmapBrush1,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetInterpolationMode1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BitmapBrush1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INTERPOLATION_MODE,
            else => *const fn(
                self: *const ID2D1BitmapBrush1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INTERPOLATION_MODE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1BitmapBrush.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush1_SetInterpolationMode1(self: *const T, interpolationMode: D2D1_INTERPOLATION_MODE) callconv(.Inline) void {
            return @as(*const ID2D1BitmapBrush1.VTable, @ptrCast(self.vtable)).SetInterpolationMode1(@as(*const ID2D1BitmapBrush1, @ptrCast(self)), interpolationMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BitmapBrush1_GetInterpolationMode1(self: *const T) callconv(.Inline) D2D1_INTERPOLATION_MODE {
            return @as(*const ID2D1BitmapBrush1.VTable, @ptrCast(self.vtable)).GetInterpolationMode1(@as(*const ID2D1BitmapBrush1, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1StrokeStyle1_Value = Guid.initString("10a72a66-e91c-43f4-993f-ddf4b82b0b4a");
pub const IID_ID2D1StrokeStyle1 = &IID_ID2D1StrokeStyle1_Value;
pub const ID2D1StrokeStyle1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1StrokeStyle.VTable,
        GetStrokeTransformType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1StrokeStyle1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_STROKE_TRANSFORM_TYPE,
            else => *const fn(
                self: *const ID2D1StrokeStyle1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_STROKE_TRANSFORM_TYPE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1StrokeStyle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1StrokeStyle1_GetStrokeTransformType(self: *const T) callconv(.Inline) D2D1_STROKE_TRANSFORM_TYPE {
            return @as(*const ID2D1StrokeStyle1.VTable, @ptrCast(self.vtable)).GetStrokeTransformType(@as(*const ID2D1StrokeStyle1, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1PathGeometry1_Value = Guid.initString("62baa2d2-ab54-41b7-b872-787e0106a421");
pub const IID_ID2D1PathGeometry1 = &IID_ID2D1PathGeometry1_Value;
pub const ID2D1PathGeometry1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1PathGeometry.VTable,
        ComputePointAndSegmentAtLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1PathGeometry1,
                length: f32,
                startSegment: u32,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                pointDescription: ?*D2D1_POINT_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1PathGeometry1,
                length: f32,
                startSegment: u32,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                pointDescription: ?*D2D1_POINT_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1PathGeometry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1PathGeometry1_ComputePointAndSegmentAtLength(self: *const T, length: f32, startSegment: u32, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, pointDescription: ?*D2D1_POINT_DESCRIPTION) callconv(.Inline) HRESULT {
            return @as(*const ID2D1PathGeometry1.VTable, @ptrCast(self.vtable)).ComputePointAndSegmentAtLength(@as(*const ID2D1PathGeometry1, @ptrCast(self)), length, startSegment, worldTransform, flatteningTolerance, pointDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Properties_Value = Guid.initString("483473d7-cd46-4f9d-9d3a-3112aa80159d");
pub const IID_ID2D1Properties = &IID_ID2D1Properties_Value;
pub const ID2D1Properties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1Properties,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetPropertyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
                name: [*:0]u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
                name: [*:0]u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyNameLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PROPERTY_TYPE,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PROPERTY_TYPE,
        },
        GetPropertyIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                name: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1Properties,
                name: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetValueByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                name: ?[*:0]const u16,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]const u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Properties,
                name: ?[*:0]const u16,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]const u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]const u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]const u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                name: ?[*:0]const u16,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Properties,
                name: ?[*:0]const u16,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
                type: D2D1_PROPERTY_TYPE,
                data: [*:0]u8,
                dataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetSubProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Properties,
                index: u32,
                subProperties: ?*?*ID2D1Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Properties,
                index: u32,
                subProperties: ?*?*ID2D1Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetPropertyCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetPropertyCount(@as(*const ID2D1Properties, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetPropertyName(self: *const T, index: u32, name: [*:0]u16, nameCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetPropertyName(@as(*const ID2D1Properties, @ptrCast(self)), index, name, nameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetPropertyNameLength(self: *const T, index: u32) callconv(.Inline) u32 {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetPropertyNameLength(@as(*const ID2D1Properties, @ptrCast(self)), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetType(self: *const T, index: u32) callconv(.Inline) D2D1_PROPERTY_TYPE {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetType(@as(*const ID2D1Properties, @ptrCast(self)), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetPropertyIndex(self: *const T, name: ?[*:0]const u16) callconv(.Inline) u32 {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetPropertyIndex(@as(*const ID2D1Properties, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_SetValueByName(self: *const T, name: ?[*:0]const u16, type_: D2D1_PROPERTY_TYPE, data: [*:0]const u8, dataSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).SetValueByName(@as(*const ID2D1Properties, @ptrCast(self)), name, type_, data, dataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_SetValue(self: *const T, index: u32, type_: D2D1_PROPERTY_TYPE, data: [*:0]const u8, dataSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).SetValue(@as(*const ID2D1Properties, @ptrCast(self)), index, type_, data, dataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetValueByName(self: *const T, name: ?[*:0]const u16, type_: D2D1_PROPERTY_TYPE, data: [*:0]u8, dataSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetValueByName(@as(*const ID2D1Properties, @ptrCast(self)), name, type_, data, dataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetValue(self: *const T, index: u32, type_: D2D1_PROPERTY_TYPE, data: [*:0]u8, dataSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ID2D1Properties, @ptrCast(self)), index, type_, data, dataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetValueSize(self: *const T, index: u32) callconv(.Inline) u32 {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetValueSize(@as(*const ID2D1Properties, @ptrCast(self)), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Properties_GetSubProperties(self: *const T, index: u32, subProperties: ?*?*ID2D1Properties) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Properties.VTable, @ptrCast(self.vtable)).GetSubProperties(@as(*const ID2D1Properties, @ptrCast(self)), index, subProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Effect_Value = Guid.initString("28211a43-7d89-476f-8181-2d6159b220ad");
pub const IID_ID2D1Effect = &IID_ID2D1Effect_Value;
pub const ID2D1Effect = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Properties.VTable,
        SetInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Effect,
                index: u32,
                input: ?*ID2D1Image,
                invalidate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Effect,
                index: u32,
                input: ?*ID2D1Image,
                invalidate: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Effect,
                inputCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Effect,
                inputCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Effect,
                index: u32,
                input: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Effect,
                index: u32,
                input: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Effect,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1Effect,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Effect,
                outputImage: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Effect,
                outputImage: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Properties.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Effect_SetInput(self: *const T, index: u32, input: ?*ID2D1Image, invalidate: BOOL) callconv(.Inline) void {
            return @as(*const ID2D1Effect.VTable, @ptrCast(self.vtable)).SetInput(@as(*const ID2D1Effect, @ptrCast(self)), index, input, invalidate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Effect_SetInputCount(self: *const T, inputCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Effect.VTable, @ptrCast(self.vtable)).SetInputCount(@as(*const ID2D1Effect, @ptrCast(self)), inputCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Effect_GetInput(self: *const T, index: u32, input: ?*?*ID2D1Image) callconv(.Inline) void {
            return @as(*const ID2D1Effect.VTable, @ptrCast(self.vtable)).GetInput(@as(*const ID2D1Effect, @ptrCast(self)), index, input);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Effect_GetInputCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1Effect.VTable, @ptrCast(self.vtable)).GetInputCount(@as(*const ID2D1Effect, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Effect_GetOutput(self: *const T, outputImage: ?*?*ID2D1Image) callconv(.Inline) void {
            return @as(*const ID2D1Effect.VTable, @ptrCast(self.vtable)).GetOutput(@as(*const ID2D1Effect, @ptrCast(self)), outputImage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Bitmap1_Value = Guid.initString("a898a84c-3873-4588-b08b-ebbf978df041");
pub const IID_ID2D1Bitmap1 = &IID_ID2D1Bitmap1_Value;
pub const ID2D1Bitmap1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Bitmap.VTable,
        GetColorContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap1,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Bitmap1,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_BITMAP_OPTIONS,
            else => *const fn(
                self: *const ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_BITMAP_OPTIONS,
        },
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap1,
                dxgiSurface: ?*?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Bitmap1,
                dxgiSurface: ?*?*IDXGISurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap1,
                options: D2D1_MAP_OPTIONS,
                mappedRect: ?*D2D1_MAPPED_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Bitmap1,
                options: D2D1_MAP_OPTIONS,
                mappedRect: ?*D2D1_MAPPED_RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Bitmap.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap1_GetColorContext(self: *const T, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) void {
            return @as(*const ID2D1Bitmap1.VTable, @ptrCast(self.vtable)).GetColorContext(@as(*const ID2D1Bitmap1, @ptrCast(self)), colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap1_GetOptions(self: *const T) callconv(.Inline) D2D1_BITMAP_OPTIONS {
            return @as(*const ID2D1Bitmap1.VTable, @ptrCast(self.vtable)).GetOptions(@as(*const ID2D1Bitmap1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap1_GetSurface(self: *const T, dxgiSurface: ?*?*IDXGISurface) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Bitmap1.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const ID2D1Bitmap1, @ptrCast(self)), dxgiSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap1_Map(self: *const T, options: D2D1_MAP_OPTIONS, mappedRect: ?*D2D1_MAPPED_RECT) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Bitmap1.VTable, @ptrCast(self.vtable)).Map(@as(*const ID2D1Bitmap1, @ptrCast(self)), options, mappedRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Bitmap1_Unmap(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Bitmap1.VTable, @ptrCast(self.vtable)).Unmap(@as(*const ID2D1Bitmap1, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1ColorContext_Value = Guid.initString("1c4820bb-5771-4518-a581-2fe4dd0ec657");
pub const IID_ID2D1ColorContext = &IID_ID2D1ColorContext_Value;
pub const ID2D1ColorContext = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetColorSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_SPACE,
            else => *const fn(
                self: *const ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_SPACE,
        },
        GetProfileSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ColorContext,
                profile: [*:0]u8,
                profileSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ColorContext,
                profile: [*:0]u8,
                profileSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ColorContext_GetColorSpace(self: *const T) callconv(.Inline) D2D1_COLOR_SPACE {
            return @as(*const ID2D1ColorContext.VTable, @ptrCast(self.vtable)).GetColorSpace(@as(*const ID2D1ColorContext, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ColorContext_GetProfileSize(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1ColorContext.VTable, @ptrCast(self.vtable)).GetProfileSize(@as(*const ID2D1ColorContext, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ColorContext_GetProfile(self: *const T, profile: [*:0]u8, profileSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ColorContext.VTable, @ptrCast(self.vtable)).GetProfile(@as(*const ID2D1ColorContext, @ptrCast(self)), profile, profileSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1GradientStopCollection1_Value = Guid.initString("ae1572f4-5dd0-4777-998b-9279472ae63b");
pub const IID_ID2D1GradientStopCollection1 = &IID_ID2D1GradientStopCollection1_Value;
pub const ID2D1GradientStopCollection1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1GradientStopCollection.VTable,
        GetGradientStops1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection1,
                gradientStops: [*]D2D1_GRADIENT_STOP,
                gradientStopsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1GradientStopCollection1,
                gradientStops: [*]D2D1_GRADIENT_STOP,
                gradientStopsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPreInterpolationSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_SPACE,
            else => *const fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_SPACE,
        },
        GetPostInterpolationSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_SPACE,
            else => *const fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_SPACE,
        },
        GetBufferPrecision: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_BUFFER_PRECISION,
            else => *const fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_BUFFER_PRECISION,
        },
        GetColorInterpolationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_INTERPOLATION_MODE,
            else => *const fn(
                self: *const ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_INTERPOLATION_MODE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1GradientStopCollection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection1_GetGradientStops1(self: *const T, gradientStops: [*]D2D1_GRADIENT_STOP, gradientStopsCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1GradientStopCollection1.VTable, @ptrCast(self.vtable)).GetGradientStops1(@as(*const ID2D1GradientStopCollection1, @ptrCast(self)), gradientStops, gradientStopsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection1_GetPreInterpolationSpace(self: *const T) callconv(.Inline) D2D1_COLOR_SPACE {
            return @as(*const ID2D1GradientStopCollection1.VTable, @ptrCast(self.vtable)).GetPreInterpolationSpace(@as(*const ID2D1GradientStopCollection1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection1_GetPostInterpolationSpace(self: *const T) callconv(.Inline) D2D1_COLOR_SPACE {
            return @as(*const ID2D1GradientStopCollection1.VTable, @ptrCast(self.vtable)).GetPostInterpolationSpace(@as(*const ID2D1GradientStopCollection1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection1_GetBufferPrecision(self: *const T) callconv(.Inline) D2D1_BUFFER_PRECISION {
            return @as(*const ID2D1GradientStopCollection1.VTable, @ptrCast(self.vtable)).GetBufferPrecision(@as(*const ID2D1GradientStopCollection1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientStopCollection1_GetColorInterpolationMode(self: *const T) callconv(.Inline) D2D1_COLOR_INTERPOLATION_MODE {
            return @as(*const ID2D1GradientStopCollection1.VTable, @ptrCast(self.vtable)).GetColorInterpolationMode(@as(*const ID2D1GradientStopCollection1, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1DrawingStateBlock1_Value = Guid.initString("689f1f85-c72e-4e33-8f19-85754efd5ace");
pub const IID_ID2D1DrawingStateBlock1 = &IID_ID2D1DrawingStateBlock1_Value;
pub const ID2D1DrawingStateBlock1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DrawingStateBlock.VTable,
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawingStateBlock1,
                stateDescription: ?*D2D1_DRAWING_STATE_DESCRIPTION1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DrawingStateBlock1,
                stateDescription: ?*D2D1_DRAWING_STATE_DESCRIPTION1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawingStateBlock1,
                stateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DrawingStateBlock1,
                stateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DrawingStateBlock.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawingStateBlock1_GetDescription(self: *const T, stateDescription: ?*D2D1_DRAWING_STATE_DESCRIPTION1) callconv(.Inline) void {
            return @as(*const ID2D1DrawingStateBlock1.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ID2D1DrawingStateBlock1, @ptrCast(self)), stateDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawingStateBlock1_SetDescription(self: *const T, stateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION1) callconv(.Inline) void {
            return @as(*const ID2D1DrawingStateBlock1.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const ID2D1DrawingStateBlock1, @ptrCast(self)), stateDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1DeviceContext_Value = Guid.initString("e8f7fe7a-191c-466d-ad95-975678bda998");
pub const IID_ID2D1DeviceContext = &IID_ID2D1DeviceContext_Value;
pub const ID2D1DeviceContext = extern struct {
    pub const VTable = extern struct {
        base: ID2D1RenderTarget.VTable,
        CreateBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                size: D2D_SIZE_U,
                sourceData: ?*const anyopaque,
                pitch: u32,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1,
                bitmap: ?*?*ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                size: D2D_SIZE_U,
                sourceData: ?*const anyopaque,
                pitch: u32,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1,
                bitmap: ?*?*ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBitmapFromWicBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                wicBitmapSource: ?*IWICBitmapSource,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1,
                bitmap: ?*?*ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                wicBitmapSource: ?*IWICBitmapSource,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1,
                bitmap: ?*?*ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                space: D2D1_COLOR_SPACE,
                profile: ?[*:0]const u8,
                profileSize: u32,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                space: D2D1_COLOR_SPACE,
                profile: ?[*:0]const u8,
                profileSize: u32,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContextFromFilename: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                filename: ?[*:0]const u16,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                filename: ?[*:0]const u16,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContextFromWicColorContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                wicColorContext: ?*IWICColorContext,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                wicColorContext: ?*IWICColorContext,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBitmapFromDxgiSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                surface: ?*IDXGISurface,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1,
                bitmap: ?*?*ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                surface: ?*IDXGISurface,
                bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1,
                bitmap: ?*?*ID2D1Bitmap1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                effectId: ?*const Guid,
                effect: ?*?*ID2D1Effect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                effectId: ?*const Guid,
                effect: ?*?*ID2D1Effect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGradientStopCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                straightAlphaGradientStops: [*]const D2D1_GRADIENT_STOP,
                straightAlphaGradientStopsCount: u32,
                preInterpolationSpace: D2D1_COLOR_SPACE,
                postInterpolationSpace: D2D1_COLOR_SPACE,
                bufferPrecision: D2D1_BUFFER_PRECISION,
                extendMode: D2D1_EXTEND_MODE,
                colorInterpolationMode: D2D1_COLOR_INTERPOLATION_MODE,
                gradientStopCollection1: ?*?*ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                straightAlphaGradientStops: [*]const D2D1_GRADIENT_STOP,
                straightAlphaGradientStopsCount: u32,
                preInterpolationSpace: D2D1_COLOR_SPACE,
                postInterpolationSpace: D2D1_COLOR_SPACE,
                bufferPrecision: D2D1_BUFFER_PRECISION,
                extendMode: D2D1_EXTEND_MODE,
                colorInterpolationMode: D2D1_COLOR_INTERPOLATION_MODE,
                gradientStopCollection1: ?*?*ID2D1GradientStopCollection1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateImageBrush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                imageBrushProperties: ?*const D2D1_IMAGE_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                imageBrush: ?*?*ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                imageBrushProperties: ?*const D2D1_IMAGE_BRUSH_PROPERTIES,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                imageBrush: ?*?*ID2D1ImageBrush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBitmapBrush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                bitmap: ?*ID2D1Bitmap,
                bitmapBrushProperties: ?*const D2D1_BITMAP_BRUSH_PROPERTIES1,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                bitmapBrush: ?*?*ID2D1BitmapBrush1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                bitmap: ?*ID2D1Bitmap,
                bitmapBrushProperties: ?*const D2D1_BITMAP_BRUSH_PROPERTIES1,
                brushProperties: ?*const D2D1_BRUSH_PROPERTIES,
                bitmapBrush: ?*?*ID2D1BitmapBrush1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCommandList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                commandList: ?*?*ID2D1CommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                commandList: ?*?*ID2D1CommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDxgiFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                format: DXGI_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                format: DXGI_FORMAT,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        IsBufferPrecisionSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                bufferPrecision: D2D1_BUFFER_PRECISION,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                bufferPrecision: D2D1_BUFFER_PRECISION,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetImageLocalBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                localBounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                localBounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImageWorldBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                worldBounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                worldBounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGlyphRunWorldBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                measuringMode: DWRITE_MEASURING_MODE,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                measuringMode: DWRITE_MEASURING_MODE,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                device: ?*?*ID2D1Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                device: ?*?*ID2D1Device,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                image: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                image: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetRenderingControls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                renderingControls: ?*const D2D1_RENDERING_CONTROLS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                renderingControls: ?*const D2D1_RENDERING_CONTROLS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetRenderingControls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                renderingControls: ?*D2D1_RENDERING_CONTROLS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                renderingControls: ?*D2D1_RENDERING_CONTROLS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPrimitiveBlend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPrimitiveBlend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PRIMITIVE_BLEND,
            else => *const fn(
                self: *const ID2D1DeviceContext,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_PRIMITIVE_BLEND,
        },
        SetUnitMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                unitMode: D2D1_UNIT_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                unitMode: D2D1_UNIT_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetUnitMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_UNIT_MODE,
            else => *const fn(
                self: *const ID2D1DeviceContext,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_UNIT_MODE,
        },
        DrawGlyphRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                glyphRunDescription: ?*const DWRITE_GLYPH_RUN_DESCRIPTION,
                foregroundBrush: ?*ID2D1Brush,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                glyphRunDescription: ?*const DWRITE_GLYPH_RUN_DESCRIPTION,
                foregroundBrush: ?*ID2D1Brush,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                compositeMode: D2D1_COMPOSITE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                image: ?*ID2D1Image,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                compositeMode: D2D1_COMPOSITE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawGdiMetafile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                gdiMetafile: ?*ID2D1GdiMetafile,
                targetOffset: ?*const D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                gdiMetafile: ?*ID2D1GdiMetafile,
                targetOffset: ?*const D2D_POINT_2F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                bitmap: ?*ID2D1Bitmap,
                destinationRectangle: ?*const D2D_RECT_F,
                opacity: f32,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                sourceRectangle: ?*const D2D_RECT_F,
                perspectiveTransform: ?*const D2D_MATRIX_4X4_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                bitmap: ?*ID2D1Bitmap,
                destinationRectangle: ?*const D2D_RECT_F,
                opacity: f32,
                interpolationMode: D2D1_INTERPOLATION_MODE,
                sourceRectangle: ?*const D2D_RECT_F,
                perspectiveTransform: ?*const D2D_MATRIX_4X4_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PushLayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                layerParameters: ?*const D2D1_LAYER_PARAMETERS1,
                layer: ?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                layerParameters: ?*const D2D1_LAYER_PARAMETERS1,
                layer: ?*ID2D1Layer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        InvalidateEffectInputRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                effect: ?*ID2D1Effect,
                input: u32,
                inputRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                effect: ?*ID2D1Effect,
                input: u32,
                inputRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectInvalidRectangleCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                effect: ?*ID2D1Effect,
                rectangleCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                effect: ?*ID2D1Effect,
                rectangleCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectInvalidRectangles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                effect: ?*ID2D1Effect,
                rectangles: [*]D2D_RECT_F,
                rectanglesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                effect: ?*ID2D1Effect,
                rectangles: [*]D2D_RECT_F,
                rectanglesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectRequiredInputRectangles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                renderEffect: ?*ID2D1Effect,
                renderImageRectangle: ?*const D2D_RECT_F,
                inputDescriptions: [*]const D2D1_EFFECT_INPUT_DESCRIPTION,
                requiredInputRects: [*]D2D_RECT_F,
                inputCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                renderEffect: ?*ID2D1Effect,
                renderImageRectangle: ?*const D2D_RECT_F,
                inputDescriptions: [*]const D2D1_EFFECT_INPUT_DESCRIPTION,
                requiredInputRects: [*]D2D_RECT_F,
                inputCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillOpacityMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext,
                opacityMask: ?*ID2D1Bitmap,
                brush: ?*ID2D1Brush,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext,
                opacityMask: ?*ID2D1Bitmap,
                brush: ?*ID2D1Brush,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1RenderTarget.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateBitmap(self: *const T, size: D2D_SIZE_U, sourceData: ?*const anyopaque, pitch: u32, bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1, bitmap: ?*?*ID2D1Bitmap1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateBitmap(@as(*const ID2D1DeviceContext, @ptrCast(self)), size, sourceData, pitch, bitmapProperties, bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateBitmapFromWicBitmap(self: *const T, wicBitmapSource: ?*IWICBitmapSource, bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1, bitmap: ?*?*ID2D1Bitmap1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateBitmapFromWicBitmap(@as(*const ID2D1DeviceContext, @ptrCast(self)), wicBitmapSource, bitmapProperties, bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateColorContext(self: *const T, space: D2D1_COLOR_SPACE, profile: ?[*:0]const u8, profileSize: u32, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateColorContext(@as(*const ID2D1DeviceContext, @ptrCast(self)), space, profile, profileSize, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateColorContextFromFilename(self: *const T, filename: ?[*:0]const u16, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateColorContextFromFilename(@as(*const ID2D1DeviceContext, @ptrCast(self)), filename, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateColorContextFromWicColorContext(self: *const T, wicColorContext: ?*IWICColorContext, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateColorContextFromWicColorContext(@as(*const ID2D1DeviceContext, @ptrCast(self)), wicColorContext, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateBitmapFromDxgiSurface(self: *const T, surface: ?*IDXGISurface, bitmapProperties: ?*const D2D1_BITMAP_PROPERTIES1, bitmap: ?*?*ID2D1Bitmap1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateBitmapFromDxgiSurface(@as(*const ID2D1DeviceContext, @ptrCast(self)), surface, bitmapProperties, bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateEffect(self: *const T, effectId: ?*const Guid, effect: ?*?*ID2D1Effect) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateEffect(@as(*const ID2D1DeviceContext, @ptrCast(self)), effectId, effect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateGradientStopCollection(self: *const T, straightAlphaGradientStops: [*]const D2D1_GRADIENT_STOP, straightAlphaGradientStopsCount: u32, preInterpolationSpace: D2D1_COLOR_SPACE, postInterpolationSpace: D2D1_COLOR_SPACE, bufferPrecision: D2D1_BUFFER_PRECISION, extendMode: D2D1_EXTEND_MODE, colorInterpolationMode: D2D1_COLOR_INTERPOLATION_MODE, gradientStopCollection1: ?*?*ID2D1GradientStopCollection1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateGradientStopCollection(@as(*const ID2D1DeviceContext, @ptrCast(self)), straightAlphaGradientStops, straightAlphaGradientStopsCount, preInterpolationSpace, postInterpolationSpace, bufferPrecision, extendMode, colorInterpolationMode, gradientStopCollection1);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateImageBrush(self: *const T, image: ?*ID2D1Image, imageBrushProperties: ?*const D2D1_IMAGE_BRUSH_PROPERTIES, brushProperties: ?*const D2D1_BRUSH_PROPERTIES, imageBrush: ?*?*ID2D1ImageBrush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateImageBrush(@as(*const ID2D1DeviceContext, @ptrCast(self)), image, imageBrushProperties, brushProperties, imageBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateBitmapBrush(self: *const T, bitmap: ?*ID2D1Bitmap, bitmapBrushProperties: ?*const D2D1_BITMAP_BRUSH_PROPERTIES1, brushProperties: ?*const D2D1_BRUSH_PROPERTIES, bitmapBrush: ?*?*ID2D1BitmapBrush1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateBitmapBrush(@as(*const ID2D1DeviceContext, @ptrCast(self)), bitmap, bitmapBrushProperties, brushProperties, bitmapBrush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_CreateCommandList(self: *const T, commandList: ?*?*ID2D1CommandList) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).CreateCommandList(@as(*const ID2D1DeviceContext, @ptrCast(self)), commandList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_IsDxgiFormatSupported(self: *const T, format: DXGI_FORMAT) callconv(.Inline) BOOL {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).IsDxgiFormatSupported(@as(*const ID2D1DeviceContext, @ptrCast(self)), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_IsBufferPrecisionSupported(self: *const T, bufferPrecision: D2D1_BUFFER_PRECISION) callconv(.Inline) BOOL {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).IsBufferPrecisionSupported(@as(*const ID2D1DeviceContext, @ptrCast(self)), bufferPrecision);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetImageLocalBounds(self: *const T, image: ?*ID2D1Image, localBounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetImageLocalBounds(@as(*const ID2D1DeviceContext, @ptrCast(self)), image, localBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetImageWorldBounds(self: *const T, image: ?*ID2D1Image, worldBounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetImageWorldBounds(@as(*const ID2D1DeviceContext, @ptrCast(self)), image, worldBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetGlyphRunWorldBounds(self: *const T, baselineOrigin: D2D_POINT_2F, glyphRun: ?*const DWRITE_GLYPH_RUN, measuringMode: DWRITE_MEASURING_MODE, bounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetGlyphRunWorldBounds(@as(*const ID2D1DeviceContext, @ptrCast(self)), baselineOrigin, glyphRun, measuringMode, bounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetDevice(self: *const T, device: ?*?*ID2D1Device) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const ID2D1DeviceContext, @ptrCast(self)), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_SetTarget(self: *const T, image: ?*ID2D1Image) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).SetTarget(@as(*const ID2D1DeviceContext, @ptrCast(self)), image);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetTarget(self: *const T, image: ?*?*ID2D1Image) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetTarget(@as(*const ID2D1DeviceContext, @ptrCast(self)), image);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_SetRenderingControls(self: *const T, renderingControls: ?*const D2D1_RENDERING_CONTROLS) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).SetRenderingControls(@as(*const ID2D1DeviceContext, @ptrCast(self)), renderingControls);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetRenderingControls(self: *const T, renderingControls: ?*D2D1_RENDERING_CONTROLS) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetRenderingControls(@as(*const ID2D1DeviceContext, @ptrCast(self)), renderingControls);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_SetPrimitiveBlend(self: *const T, primitiveBlend: D2D1_PRIMITIVE_BLEND) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).SetPrimitiveBlend(@as(*const ID2D1DeviceContext, @ptrCast(self)), primitiveBlend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetPrimitiveBlend(self: *const T) callconv(.Inline) D2D1_PRIMITIVE_BLEND {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetPrimitiveBlend(@as(*const ID2D1DeviceContext, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_SetUnitMode(self: *const T, unitMode: D2D1_UNIT_MODE) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).SetUnitMode(@as(*const ID2D1DeviceContext, @ptrCast(self)), unitMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetUnitMode(self: *const T) callconv(.Inline) D2D1_UNIT_MODE {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetUnitMode(@as(*const ID2D1DeviceContext, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_DrawGlyphRun(self: *const T, baselineOrigin: D2D_POINT_2F, glyphRun: ?*const DWRITE_GLYPH_RUN, glyphRunDescription: ?*const DWRITE_GLYPH_RUN_DESCRIPTION, foregroundBrush: ?*ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).DrawGlyphRun(@as(*const ID2D1DeviceContext, @ptrCast(self)), baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_DrawImage(self: *const T, image: ?*ID2D1Image, targetOffset: ?*const D2D_POINT_2F, imageRectangle: ?*const D2D_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE, compositeMode: D2D1_COMPOSITE_MODE) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).DrawImage(@as(*const ID2D1DeviceContext, @ptrCast(self)), image, targetOffset, imageRectangle, interpolationMode, compositeMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_DrawGdiMetafile(self: *const T, gdiMetafile: ?*ID2D1GdiMetafile, targetOffset: ?*const D2D_POINT_2F) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).DrawGdiMetafile(@as(*const ID2D1DeviceContext, @ptrCast(self)), gdiMetafile, targetOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_DrawBitmap(self: *const T, bitmap: ?*ID2D1Bitmap, destinationRectangle: ?*const D2D_RECT_F, opacity: f32, interpolationMode: D2D1_INTERPOLATION_MODE, sourceRectangle: ?*const D2D_RECT_F, perspectiveTransform: ?*const D2D_MATRIX_4X4_F) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).DrawBitmap(@as(*const ID2D1DeviceContext, @ptrCast(self)), bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_PushLayer(self: *const T, layerParameters: ?*const D2D1_LAYER_PARAMETERS1, layer: ?*ID2D1Layer) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).PushLayer(@as(*const ID2D1DeviceContext, @ptrCast(self)), layerParameters, layer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_InvalidateEffectInputRectangle(self: *const T, effect: ?*ID2D1Effect, input: u32, inputRectangle: ?*const D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).InvalidateEffectInputRectangle(@as(*const ID2D1DeviceContext, @ptrCast(self)), effect, input, inputRectangle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetEffectInvalidRectangleCount(self: *const T, effect: ?*ID2D1Effect, rectangleCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetEffectInvalidRectangleCount(@as(*const ID2D1DeviceContext, @ptrCast(self)), effect, rectangleCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetEffectInvalidRectangles(self: *const T, effect: ?*ID2D1Effect, rectangles: [*]D2D_RECT_F, rectanglesCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetEffectInvalidRectangles(@as(*const ID2D1DeviceContext, @ptrCast(self)), effect, rectangles, rectanglesCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_GetEffectRequiredInputRectangles(self: *const T, renderEffect: ?*ID2D1Effect, renderImageRectangle: ?*const D2D_RECT_F, inputDescriptions: [*]const D2D1_EFFECT_INPUT_DESCRIPTION, requiredInputRects: [*]D2D_RECT_F, inputCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).GetEffectRequiredInputRectangles(@as(*const ID2D1DeviceContext, @ptrCast(self)), renderEffect, renderImageRectangle, inputDescriptions, requiredInputRects, inputCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext_FillOpacityMask(self: *const T, opacityMask: ?*ID2D1Bitmap, brush: ?*ID2D1Brush, destinationRectangle: ?*const D2D_RECT_F, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext.VTable, @ptrCast(self.vtable)).FillOpacityMask(@as(*const ID2D1DeviceContext, @ptrCast(self)), opacityMask, brush, destinationRectangle, sourceRectangle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Device_Value = Guid.initString("47dd575d-ac05-4cdd-8049-9b02cd16f44c");
pub const IID_ID2D1Device = &IID_ID2D1Device_Value;
pub const ID2D1Device = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext: ?*?*ID2D1DeviceContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext: ?*?*ID2D1DeviceContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePrintControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device,
                wicFactory: ?*IWICImagingFactory,
                documentTarget: ?*IPrintDocumentPackageTarget,
                printControlProperties: ?*const D2D1_PRINT_CONTROL_PROPERTIES,
                printControl: ?*?*ID2D1PrintControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device,
                wicFactory: ?*IWICImagingFactory,
                documentTarget: ?*IPrintDocumentPackageTarget,
                printControlProperties: ?*const D2D1_PRINT_CONTROL_PROPERTIES,
                printControl: ?*?*ID2D1PrintControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaximumTextureMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device,
                maximumInBytes: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Device,
                maximumInBytes: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMaximumTextureMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID2D1Device,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        ClearResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device,
                millisecondsSinceUse: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Device,
                millisecondsSinceUse: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext: ?*?*ID2D1DeviceContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device, @ptrCast(self)), options, deviceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device_CreatePrintControl(self: *const T, wicFactory: ?*IWICImagingFactory, documentTarget: ?*IPrintDocumentPackageTarget, printControlProperties: ?*const D2D1_PRINT_CONTROL_PROPERTIES, printControl: ?*?*ID2D1PrintControl) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device.VTable, @ptrCast(self.vtable)).CreatePrintControl(@as(*const ID2D1Device, @ptrCast(self)), wicFactory, documentTarget, printControlProperties, printControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device_SetMaximumTextureMemory(self: *const T, maximumInBytes: u64) callconv(.Inline) void {
            return @as(*const ID2D1Device.VTable, @ptrCast(self.vtable)).SetMaximumTextureMemory(@as(*const ID2D1Device, @ptrCast(self)), maximumInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device_GetMaximumTextureMemory(self: *const T) callconv(.Inline) u64 {
            return @as(*const ID2D1Device.VTable, @ptrCast(self.vtable)).GetMaximumTextureMemory(@as(*const ID2D1Device, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device_ClearResources(self: *const T, millisecondsSinceUse: u32) callconv(.Inline) void {
            return @as(*const ID2D1Device.VTable, @ptrCast(self.vtable)).ClearResources(@as(*const ID2D1Device, @ptrCast(self)), millisecondsSinceUse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Factory1_Value = Guid.initString("bb12d362-daee-4b9a-aa1d-14ba401cfa1f");
pub const IID_ID2D1Factory1 = &IID_ID2D1Factory1_Value;
pub const ID2D1Factory1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice: ?*?*ID2D1Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice: ?*?*ID2D1Device,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStrokeStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                strokeStyleProperties: ?*const D2D1_STROKE_STYLE_PROPERTIES1,
                dashes: ?[*]const f32,
                dashesCount: u32,
                strokeStyle: ?*?*ID2D1StrokeStyle1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                strokeStyleProperties: ?*const D2D1_STROKE_STYLE_PROPERTIES1,
                dashes: ?[*]const f32,
                dashesCount: u32,
                strokeStyle: ?*?*ID2D1StrokeStyle1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePathGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                pathGeometry: ?*?*ID2D1PathGeometry1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                pathGeometry: ?*?*ID2D1PathGeometry1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDrawingStateBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                drawingStateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION1,
                textRenderingParams: ?*IDWriteRenderingParams,
                drawingStateBlock: ?*?*ID2D1DrawingStateBlock1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                drawingStateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION1,
                textRenderingParams: ?*IDWriteRenderingParams,
                drawingStateBlock: ?*?*ID2D1DrawingStateBlock1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGdiMetafile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                metafileStream: ?*IStream,
                metafile: ?*?*ID2D1GdiMetafile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                metafileStream: ?*IStream,
                metafile: ?*?*ID2D1GdiMetafile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterEffectFromStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                classId: ?*const Guid,
                propertyXml: ?*IStream,
                bindings: ?[*]const D2D1_PROPERTY_BINDING,
                bindingsCount: u32,
                effectFactory: ?PD2D1_EFFECT_FACTORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                classId: ?*const Guid,
                propertyXml: ?*IStream,
                bindings: ?[*]const D2D1_PROPERTY_BINDING,
                bindingsCount: u32,
                effectFactory: ?PD2D1_EFFECT_FACTORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterEffectFromString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                classId: ?*const Guid,
                propertyXml: ?[*:0]const u16,
                bindings: ?[*]const D2D1_PROPERTY_BINDING,
                bindingsCount: u32,
                effectFactory: ?PD2D1_EFFECT_FACTORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                classId: ?*const Guid,
                propertyXml: ?[*:0]const u16,
                bindings: ?[*]const D2D1_PROPERTY_BINDING,
                bindingsCount: u32,
                effectFactory: ?PD2D1_EFFECT_FACTORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                classId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                classId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegisteredEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                effects: ?[*]Guid,
                effectsCount: u32,
                effectsReturned: ?*u32,
                effectsRegistered: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                effects: ?[*]Guid,
                effectsCount: u32,
                effectsReturned: ?*u32,
                effectsRegistered: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory1,
                effectId: ?*const Guid,
                properties: ?*?*ID2D1Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory1,
                effectId: ?*const Guid,
                properties: ?*?*ID2D1Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice: ?*?*ID2D1Device) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory1, @ptrCast(self)), dxgiDevice, d2dDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_CreateStrokeStyle(self: *const T, strokeStyleProperties: ?*const D2D1_STROKE_STYLE_PROPERTIES1, dashes: ?[*]const f32, dashesCount: u32, strokeStyle: ?*?*ID2D1StrokeStyle1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).CreateStrokeStyle(@as(*const ID2D1Factory1, @ptrCast(self)), strokeStyleProperties, dashes, dashesCount, strokeStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_CreatePathGeometry(self: *const T, pathGeometry: ?*?*ID2D1PathGeometry1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).CreatePathGeometry(@as(*const ID2D1Factory1, @ptrCast(self)), pathGeometry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_CreateDrawingStateBlock(self: *const T, drawingStateDescription: ?*const D2D1_DRAWING_STATE_DESCRIPTION1, textRenderingParams: ?*IDWriteRenderingParams, drawingStateBlock: ?*?*ID2D1DrawingStateBlock1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).CreateDrawingStateBlock(@as(*const ID2D1Factory1, @ptrCast(self)), drawingStateDescription, textRenderingParams, drawingStateBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_CreateGdiMetafile(self: *const T, metafileStream: ?*IStream, metafile: ?*?*ID2D1GdiMetafile) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).CreateGdiMetafile(@as(*const ID2D1Factory1, @ptrCast(self)), metafileStream, metafile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_RegisterEffectFromStream(self: *const T, classId: ?*const Guid, propertyXml: ?*IStream, bindings: ?[*]const D2D1_PROPERTY_BINDING, bindingsCount: u32, effectFactory: ?PD2D1_EFFECT_FACTORY) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).RegisterEffectFromStream(@as(*const ID2D1Factory1, @ptrCast(self)), classId, propertyXml, bindings, bindingsCount, effectFactory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_RegisterEffectFromString(self: *const T, classId: ?*const Guid, propertyXml: ?[*:0]const u16, bindings: ?[*]const D2D1_PROPERTY_BINDING, bindingsCount: u32, effectFactory: ?PD2D1_EFFECT_FACTORY) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).RegisterEffectFromString(@as(*const ID2D1Factory1, @ptrCast(self)), classId, propertyXml, bindings, bindingsCount, effectFactory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_UnregisterEffect(self: *const T, classId: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).UnregisterEffect(@as(*const ID2D1Factory1, @ptrCast(self)), classId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_GetRegisteredEffects(self: *const T, effects: ?[*]Guid, effectsCount: u32, effectsReturned: ?*u32, effectsRegistered: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).GetRegisteredEffects(@as(*const ID2D1Factory1, @ptrCast(self)), effects, effectsCount, effectsReturned, effectsRegistered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory1_GetEffectProperties(self: *const T, effectId: ?*const Guid, properties: ?*?*ID2D1Properties) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory1.VTable, @ptrCast(self.vtable)).GetEffectProperties(@as(*const ID2D1Factory1, @ptrCast(self)), effectId, properties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Multithread_Value = Guid.initString("31e6e7bc-e0ff-4d46-8c64-a0a8c41c15d3");
pub const IID_ID2D1Multithread = &IID_ID2D1Multithread_Value;
pub const ID2D1Multithread = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMultithreadProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Multithread,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1Multithread,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        Enter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Leave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Multithread,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Multithread_GetMultithreadProtected(self: *const T) callconv(.Inline) BOOL {
            return @as(*const ID2D1Multithread.VTable, @ptrCast(self.vtable)).GetMultithreadProtected(@as(*const ID2D1Multithread, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Multithread_Enter(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1Multithread.VTable, @ptrCast(self.vtable)).Enter(@as(*const ID2D1Multithread, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Multithread_Leave(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1Multithread.VTable, @ptrCast(self.vtable)).Leave(@as(*const ID2D1Multithread, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Matrix4x3F = extern struct {
    __AnonymousBase_d2d1_1helper_L45_C31: D2D_MATRIX_4X3_F,
};

pub const Matrix4x4F = extern struct {
    __AnonymousBase_d2d1_1helper_L97_C31: D2D_MATRIX_4X4_F,
};

pub const Matrix5x4F = extern struct {
    __AnonymousBase_d2d1_1helper_L472_C31: D2D_MATRIX_5X4_F,
};

pub const PD2D1_PROPERTY_SET_FUNCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        effect: ?*IUnknown,
        data: [*:0]const u8,
        dataSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        effect: ?*IUnknown,
        data: [*:0]const u8,
        dataSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PD2D1_PROPERTY_GET_FUNCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        effect: ?*IUnknown,
        data: ?[*:0]u8,
        dataSize: u32,
        actualSize: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        effect: ?*IUnknown,
        data: ?[*:0]u8,
        dataSize: u32,
        actualSize: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const D2D1_CHANGE_TYPE = enum(u32) {
    NONE = 0,
    PROPERTIES = 1,
    CONTEXT = 2,
    GRAPH = 3,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        PROPERTIES: u1 = 0,
        CONTEXT: u1 = 0,
        GRAPH: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_CHANGE_TYPE {
        return @as(D2D1_CHANGE_TYPE, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_CHANGE_TYPE.NONE) else 0)
            | (if (o.PROPERTIES == 1) @intFromEnum(D2D1_CHANGE_TYPE.PROPERTIES) else 0)
            | (if (o.CONTEXT == 1) @intFromEnum(D2D1_CHANGE_TYPE.CONTEXT) else 0)
            | (if (o.GRAPH == 1) @intFromEnum(D2D1_CHANGE_TYPE.GRAPH) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_CHANGE_TYPE.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_CHANGE_TYPE_NONE = D2D1_CHANGE_TYPE.NONE;
pub const D2D1_CHANGE_TYPE_PROPERTIES = D2D1_CHANGE_TYPE.PROPERTIES;
pub const D2D1_CHANGE_TYPE_CONTEXT = D2D1_CHANGE_TYPE.CONTEXT;
pub const D2D1_CHANGE_TYPE_GRAPH = D2D1_CHANGE_TYPE.GRAPH;
pub const D2D1_CHANGE_TYPE_FORCE_DWORD = D2D1_CHANGE_TYPE.FORCE_DWORD;

pub const D2D1_PIXEL_OPTIONS = enum(u32) {
    NONE = 0,
    TRIVIAL_SAMPLING = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        TRIVIAL_SAMPLING: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_PIXEL_OPTIONS {
        return @as(D2D1_PIXEL_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_PIXEL_OPTIONS.NONE) else 0)
            | (if (o.TRIVIAL_SAMPLING == 1) @intFromEnum(D2D1_PIXEL_OPTIONS.TRIVIAL_SAMPLING) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_PIXEL_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_PIXEL_OPTIONS_NONE = D2D1_PIXEL_OPTIONS.NONE;
pub const D2D1_PIXEL_OPTIONS_TRIVIAL_SAMPLING = D2D1_PIXEL_OPTIONS.TRIVIAL_SAMPLING;
pub const D2D1_PIXEL_OPTIONS_FORCE_DWORD = D2D1_PIXEL_OPTIONS.FORCE_DWORD;

pub const D2D1_VERTEX_OPTIONS = enum(u32) {
    NONE = 0,
    DO_NOT_CLEAR = 1,
    USE_DEPTH_BUFFER = 2,
    ASSUME_NO_OVERLAP = 4,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DO_NOT_CLEAR: u1 = 0,
        USE_DEPTH_BUFFER: u1 = 0,
        ASSUME_NO_OVERLAP: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_VERTEX_OPTIONS {
        return @as(D2D1_VERTEX_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_VERTEX_OPTIONS.NONE) else 0)
            | (if (o.DO_NOT_CLEAR == 1) @intFromEnum(D2D1_VERTEX_OPTIONS.DO_NOT_CLEAR) else 0)
            | (if (o.USE_DEPTH_BUFFER == 1) @intFromEnum(D2D1_VERTEX_OPTIONS.USE_DEPTH_BUFFER) else 0)
            | (if (o.ASSUME_NO_OVERLAP == 1) @intFromEnum(D2D1_VERTEX_OPTIONS.ASSUME_NO_OVERLAP) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_VERTEX_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_VERTEX_OPTIONS_NONE = D2D1_VERTEX_OPTIONS.NONE;
pub const D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR = D2D1_VERTEX_OPTIONS.DO_NOT_CLEAR;
pub const D2D1_VERTEX_OPTIONS_USE_DEPTH_BUFFER = D2D1_VERTEX_OPTIONS.USE_DEPTH_BUFFER;
pub const D2D1_VERTEX_OPTIONS_ASSUME_NO_OVERLAP = D2D1_VERTEX_OPTIONS.ASSUME_NO_OVERLAP;
pub const D2D1_VERTEX_OPTIONS_FORCE_DWORD = D2D1_VERTEX_OPTIONS.FORCE_DWORD;

pub const D2D1_VERTEX_USAGE = enum(u32) {
    STATIC = 0,
    DYNAMIC = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_VERTEX_USAGE_STATIC = D2D1_VERTEX_USAGE.STATIC;
pub const D2D1_VERTEX_USAGE_DYNAMIC = D2D1_VERTEX_USAGE.DYNAMIC;
pub const D2D1_VERTEX_USAGE_FORCE_DWORD = D2D1_VERTEX_USAGE.FORCE_DWORD;

pub const D2D1_BLEND_OPERATION = enum(u32) {
    ADD = 1,
    SUBTRACT = 2,
    REV_SUBTRACT = 3,
    MIN = 4,
    MAX = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BLEND_OPERATION_ADD = D2D1_BLEND_OPERATION.ADD;
pub const D2D1_BLEND_OPERATION_SUBTRACT = D2D1_BLEND_OPERATION.SUBTRACT;
pub const D2D1_BLEND_OPERATION_REV_SUBTRACT = D2D1_BLEND_OPERATION.REV_SUBTRACT;
pub const D2D1_BLEND_OPERATION_MIN = D2D1_BLEND_OPERATION.MIN;
pub const D2D1_BLEND_OPERATION_MAX = D2D1_BLEND_OPERATION.MAX;
pub const D2D1_BLEND_OPERATION_FORCE_DWORD = D2D1_BLEND_OPERATION.FORCE_DWORD;

pub const D2D1_BLEND = enum(u32) {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    INV_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    INV_SRC_ALPHA = 6,
    DEST_ALPHA = 7,
    INV_DEST_ALPHA = 8,
    DEST_COLOR = 9,
    INV_DEST_COLOR = 10,
    SRC_ALPHA_SAT = 11,
    BLEND_FACTOR = 14,
    INV_BLEND_FACTOR = 15,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_BLEND_ZERO = D2D1_BLEND.ZERO;
pub const D2D1_BLEND_ONE = D2D1_BLEND.ONE;
pub const D2D1_BLEND_SRC_COLOR = D2D1_BLEND.SRC_COLOR;
pub const D2D1_BLEND_INV_SRC_COLOR = D2D1_BLEND.INV_SRC_COLOR;
pub const D2D1_BLEND_SRC_ALPHA = D2D1_BLEND.SRC_ALPHA;
pub const D2D1_BLEND_INV_SRC_ALPHA = D2D1_BLEND.INV_SRC_ALPHA;
pub const D2D1_BLEND_DEST_ALPHA = D2D1_BLEND.DEST_ALPHA;
pub const D2D1_BLEND_INV_DEST_ALPHA = D2D1_BLEND.INV_DEST_ALPHA;
pub const D2D1_BLEND_DEST_COLOR = D2D1_BLEND.DEST_COLOR;
pub const D2D1_BLEND_INV_DEST_COLOR = D2D1_BLEND.INV_DEST_COLOR;
pub const D2D1_BLEND_SRC_ALPHA_SAT = D2D1_BLEND.SRC_ALPHA_SAT;
pub const D2D1_BLEND_BLEND_FACTOR = D2D1_BLEND.BLEND_FACTOR;
pub const D2D1_BLEND_INV_BLEND_FACTOR = D2D1_BLEND.INV_BLEND_FACTOR;
pub const D2D1_BLEND_FORCE_DWORD = D2D1_BLEND.FORCE_DWORD;

pub const D2D1_CHANNEL_DEPTH = enum(u32) {
    DEFAULT = 0,
    @"1" = 1,
    @"4" = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CHANNEL_DEPTH_DEFAULT = D2D1_CHANNEL_DEPTH.DEFAULT;
pub const D2D1_CHANNEL_DEPTH_1 = D2D1_CHANNEL_DEPTH.@"1";
pub const D2D1_CHANNEL_DEPTH_4 = D2D1_CHANNEL_DEPTH.@"4";
pub const D2D1_CHANNEL_DEPTH_FORCE_DWORD = D2D1_CHANNEL_DEPTH.FORCE_DWORD;

pub const D2D1_FILTER = enum(u32) {
    MIN_MAG_MIP_POINT = 0,
    MIN_MAG_POINT_MIP_LINEAR = 1,
    MIN_POINT_MAG_LINEAR_MIP_POINT = 4,
    MIN_POINT_MAG_MIP_LINEAR = 5,
    MIN_LINEAR_MAG_MIP_POINT = 16,
    MIN_LINEAR_MAG_POINT_MIP_LINEAR = 17,
    MIN_MAG_LINEAR_MIP_POINT = 20,
    MIN_MAG_MIP_LINEAR = 21,
    ANISOTROPIC = 85,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_FILTER_MIN_MAG_MIP_POINT = D2D1_FILTER.MIN_MAG_MIP_POINT;
pub const D2D1_FILTER_MIN_MAG_POINT_MIP_LINEAR = D2D1_FILTER.MIN_MAG_POINT_MIP_LINEAR;
pub const D2D1_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = D2D1_FILTER.MIN_POINT_MAG_LINEAR_MIP_POINT;
pub const D2D1_FILTER_MIN_POINT_MAG_MIP_LINEAR = D2D1_FILTER.MIN_POINT_MAG_MIP_LINEAR;
pub const D2D1_FILTER_MIN_LINEAR_MAG_MIP_POINT = D2D1_FILTER.MIN_LINEAR_MAG_MIP_POINT;
pub const D2D1_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = D2D1_FILTER.MIN_LINEAR_MAG_POINT_MIP_LINEAR;
pub const D2D1_FILTER_MIN_MAG_LINEAR_MIP_POINT = D2D1_FILTER.MIN_MAG_LINEAR_MIP_POINT;
pub const D2D1_FILTER_MIN_MAG_MIP_LINEAR = D2D1_FILTER.MIN_MAG_MIP_LINEAR;
pub const D2D1_FILTER_ANISOTROPIC = D2D1_FILTER.ANISOTROPIC;
pub const D2D1_FILTER_FORCE_DWORD = D2D1_FILTER.FORCE_DWORD;

pub const D2D1_FEATURE = enum(u32) {
    DOUBLES = 0,
    D3D10_X_HARDWARE_OPTIONS = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_FEATURE_DOUBLES = D2D1_FEATURE.DOUBLES;
pub const D2D1_FEATURE_D3D10_X_HARDWARE_OPTIONS = D2D1_FEATURE.D3D10_X_HARDWARE_OPTIONS;
pub const D2D1_FEATURE_FORCE_DWORD = D2D1_FEATURE.FORCE_DWORD;

pub const D2D1_PROPERTY_BINDING = extern struct {
    propertyName: ?[*:0]const u16,
    setFunction: ?PD2D1_PROPERTY_SET_FUNCTION,
    getFunction: ?PD2D1_PROPERTY_GET_FUNCTION,
};

pub const D2D1_RESOURCE_TEXTURE_PROPERTIES = extern struct {
    extents: ?*const u32,
    dimensions: u32,
    bufferPrecision: D2D1_BUFFER_PRECISION,
    channelDepth: D2D1_CHANNEL_DEPTH,
    filter: D2D1_FILTER,
    extendModes: ?*const D2D1_EXTEND_MODE,
};

pub const D2D1_INPUT_ELEMENT_DESC = extern struct {
    semanticName: ?[*:0]const u8,
    semanticIndex: u32,
    format: DXGI_FORMAT,
    inputSlot: u32,
    alignedByteOffset: u32,
};

pub const D2D1_VERTEX_BUFFER_PROPERTIES = extern struct {
    inputCount: u32,
    usage: D2D1_VERTEX_USAGE,
    data: ?*const u8,
    byteWidth: u32,
};

pub const D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES = extern struct {
    shaderBufferWithInputSignature: ?*const u8,
    shaderBufferSize: u32,
    inputElements: ?*const D2D1_INPUT_ELEMENT_DESC,
    elementCount: u32,
    stride: u32,
};

pub const D2D1_VERTEX_RANGE = extern struct {
    startVertex: u32,
    vertexCount: u32,
};

pub const D2D1_BLEND_DESCRIPTION = extern struct {
    sourceBlend: D2D1_BLEND,
    destinationBlend: D2D1_BLEND,
    blendOperation: D2D1_BLEND_OPERATION,
    sourceBlendAlpha: D2D1_BLEND,
    destinationBlendAlpha: D2D1_BLEND,
    blendOperationAlpha: D2D1_BLEND_OPERATION,
    blendFactor: [4]f32,
};

pub const D2D1_INPUT_DESCRIPTION = extern struct {
    filter: D2D1_FILTER,
    levelOfDetailCount: u32,
};

pub const D2D1_FEATURE_DATA_DOUBLES = extern struct {
    doublePrecisionFloatShaderOps: BOOL,
};

pub const D2D1_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS = extern struct {
    computeShaders_Plus_RawAndStructuredBuffers_Via_Shader_4_x: BOOL,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1VertexBuffer_Value = Guid.initString("9b8b1336-00a5-4668-92b7-ced5d8bf9b7b");
pub const IID_ID2D1VertexBuffer = &IID_ID2D1VertexBuffer_Value;
pub const ID2D1VertexBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1VertexBuffer,
                data: ?*?*u8,
                bufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1VertexBuffer,
                data: ?*?*u8,
                bufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1VertexBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1VertexBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1VertexBuffer_Map(self: *const T, data: ?*?*u8, bufferSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1VertexBuffer.VTable, @ptrCast(self.vtable)).Map(@as(*const ID2D1VertexBuffer, @ptrCast(self)), data, bufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1VertexBuffer_Unmap(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1VertexBuffer.VTable, @ptrCast(self.vtable)).Unmap(@as(*const ID2D1VertexBuffer, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1ResourceTexture_Value = Guid.initString("688d15c3-02b0-438d-b13a-d1b44c32c39a");
pub const IID_ID2D1ResourceTexture = &IID_ID2D1ResourceTexture_Value;
pub const ID2D1ResourceTexture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ResourceTexture,
                minimumExtents: ?[*]const u32,
                maximimumExtents: ?[*]const u32,
                strides: ?*const u32,
                dimensions: u32,
                data: [*:0]const u8,
                dataCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ResourceTexture,
                minimumExtents: ?[*]const u32,
                maximimumExtents: ?[*]const u32,
                strides: ?*const u32,
                dimensions: u32,
                data: [*:0]const u8,
                dataCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ResourceTexture_Update(self: *const T, minimumExtents: ?[*]const u32, maximimumExtents: ?[*]const u32, strides: ?*const u32, dimensions: u32, data: [*:0]const u8, dataCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ResourceTexture.VTable, @ptrCast(self.vtable)).Update(@as(*const ID2D1ResourceTexture, @ptrCast(self)), minimumExtents, maximimumExtents, strides, dimensions, data, dataCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1RenderInfo_Value = Guid.initString("519ae1bd-d19a-420d-b849-364f594776b7");
pub const IID_ID2D1RenderInfo = &IID_ID2D1RenderInfo_Value;
pub const ID2D1RenderInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInputDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderInfo,
                inputIndex: u32,
                inputDescription: D2D1_INPUT_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderInfo,
                inputIndex: u32,
                inputDescription: D2D1_INPUT_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderInfo,
                bufferPrecision: D2D1_BUFFER_PRECISION,
                channelDepth: D2D1_CHANNEL_DEPTH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1RenderInfo,
                bufferPrecision: D2D1_BUFFER_PRECISION,
                channelDepth: D2D1_CHANNEL_DEPTH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderInfo,
                isCached: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderInfo,
                isCached: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetInstructionCountHint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1RenderInfo,
                instructionCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1RenderInfo,
                instructionCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderInfo_SetInputDescription(self: *const T, inputIndex: u32, inputDescription: D2D1_INPUT_DESCRIPTION) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderInfo.VTable, @ptrCast(self.vtable)).SetInputDescription(@as(*const ID2D1RenderInfo, @ptrCast(self)), inputIndex, inputDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderInfo_SetOutputBuffer(self: *const T, bufferPrecision: D2D1_BUFFER_PRECISION, channelDepth: D2D1_CHANNEL_DEPTH) callconv(.Inline) HRESULT {
            return @as(*const ID2D1RenderInfo.VTable, @ptrCast(self.vtable)).SetOutputBuffer(@as(*const ID2D1RenderInfo, @ptrCast(self)), bufferPrecision, channelDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderInfo_SetCached(self: *const T, isCached: BOOL) callconv(.Inline) void {
            return @as(*const ID2D1RenderInfo.VTable, @ptrCast(self.vtable)).SetCached(@as(*const ID2D1RenderInfo, @ptrCast(self)), isCached);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1RenderInfo_SetInstructionCountHint(self: *const T, instructionCount: u32) callconv(.Inline) void {
            return @as(*const ID2D1RenderInfo.VTable, @ptrCast(self.vtable)).SetInstructionCountHint(@as(*const ID2D1RenderInfo, @ptrCast(self)), instructionCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1DrawInfo_Value = Guid.initString("693ce632-7f2f-45de-93fe-18d88b37aa21");
pub const IID_ID2D1DrawInfo = &IID_ID2D1DrawInfo_Value;
pub const ID2D1DrawInfo = extern struct {
    pub const VTable = extern struct {
        base: ID2D1RenderInfo.VTable,
        SetPixelShaderConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawInfo,
                buffer: [*:0]const u8,
                bufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DrawInfo,
                buffer: [*:0]const u8,
                bufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResourceTexture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawInfo,
                textureIndex: u32,
                resourceTexture: ?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DrawInfo,
                textureIndex: u32,
                resourceTexture: ?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVertexShaderConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawInfo,
                buffer: [*:0]const u8,
                bufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DrawInfo,
                buffer: [*:0]const u8,
                bufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPixelShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawInfo,
                shaderId: ?*const Guid,
                pixelOptions: D2D1_PIXEL_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DrawInfo,
                shaderId: ?*const Guid,
                pixelOptions: D2D1_PIXEL_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVertexProcessing: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawInfo,
                vertexBuffer: ?*ID2D1VertexBuffer,
                vertexOptions: D2D1_VERTEX_OPTIONS,
                blendDescription: ?*const D2D1_BLEND_DESCRIPTION,
                vertexRange: ?*const D2D1_VERTEX_RANGE,
                vertexShader: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DrawInfo,
                vertexBuffer: ?*ID2D1VertexBuffer,
                vertexOptions: D2D1_VERTEX_OPTIONS,
                blendDescription: ?*const D2D1_BLEND_DESCRIPTION,
                vertexRange: ?*const D2D1_VERTEX_RANGE,
                vertexShader: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1RenderInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawInfo_SetPixelShaderConstantBuffer(self: *const T, buffer: [*:0]const u8, bufferCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DrawInfo.VTable, @ptrCast(self.vtable)).SetPixelShaderConstantBuffer(@as(*const ID2D1DrawInfo, @ptrCast(self)), buffer, bufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawInfo_SetResourceTexture(self: *const T, textureIndex: u32, resourceTexture: ?*ID2D1ResourceTexture) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DrawInfo.VTable, @ptrCast(self.vtable)).SetResourceTexture(@as(*const ID2D1DrawInfo, @ptrCast(self)), textureIndex, resourceTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawInfo_SetVertexShaderConstantBuffer(self: *const T, buffer: [*:0]const u8, bufferCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DrawInfo.VTable, @ptrCast(self.vtable)).SetVertexShaderConstantBuffer(@as(*const ID2D1DrawInfo, @ptrCast(self)), buffer, bufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawInfo_SetPixelShader(self: *const T, shaderId: ?*const Guid, pixelOptions: D2D1_PIXEL_OPTIONS) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DrawInfo.VTable, @ptrCast(self.vtable)).SetPixelShader(@as(*const ID2D1DrawInfo, @ptrCast(self)), shaderId, pixelOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawInfo_SetVertexProcessing(self: *const T, vertexBuffer: ?*ID2D1VertexBuffer, vertexOptions: D2D1_VERTEX_OPTIONS, blendDescription: ?*const D2D1_BLEND_DESCRIPTION, vertexRange: ?*const D2D1_VERTEX_RANGE, vertexShader: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DrawInfo.VTable, @ptrCast(self.vtable)).SetVertexProcessing(@as(*const ID2D1DrawInfo, @ptrCast(self)), vertexBuffer, vertexOptions, blendDescription, vertexRange, vertexShader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1ComputeInfo_Value = Guid.initString("5598b14b-9fd7-48b7-9bdb-8f0964eb38bc");
pub const IID_ID2D1ComputeInfo = &IID_ID2D1ComputeInfo_Value;
pub const ID2D1ComputeInfo = extern struct {
    pub const VTable = extern struct {
        base: ID2D1RenderInfo.VTable,
        SetComputeShaderConstantBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ComputeInfo,
                buffer: [*:0]const u8,
                bufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ComputeInfo,
                buffer: [*:0]const u8,
                bufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetComputeShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ComputeInfo,
                shaderId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ComputeInfo,
                shaderId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetResourceTexture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ComputeInfo,
                textureIndex: u32,
                resourceTexture: ?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ComputeInfo,
                textureIndex: u32,
                resourceTexture: ?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1RenderInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ComputeInfo_SetComputeShaderConstantBuffer(self: *const T, buffer: [*:0]const u8, bufferCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ComputeInfo.VTable, @ptrCast(self.vtable)).SetComputeShaderConstantBuffer(@as(*const ID2D1ComputeInfo, @ptrCast(self)), buffer, bufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ComputeInfo_SetComputeShader(self: *const T, shaderId: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ComputeInfo.VTable, @ptrCast(self.vtable)).SetComputeShader(@as(*const ID2D1ComputeInfo, @ptrCast(self)), shaderId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ComputeInfo_SetResourceTexture(self: *const T, textureIndex: u32, resourceTexture: ?*ID2D1ResourceTexture) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ComputeInfo.VTable, @ptrCast(self.vtable)).SetResourceTexture(@as(*const ID2D1ComputeInfo, @ptrCast(self)), textureIndex, resourceTexture);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1TransformNode_Value = Guid.initString("b2efe1e7-729f-4102-949f-505fa21bf666");
pub const IID_ID2D1TransformNode = &IID_ID2D1TransformNode_Value;
pub const ID2D1TransformNode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformNode_GetInputCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1TransformNode.VTable, @ptrCast(self.vtable)).GetInputCount(@as(*const ID2D1TransformNode, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1TransformGraph_Value = Guid.initString("13d29038-c3e6-4034-9081-13b53a417992");
pub const IID_ID2D1TransformGraph = &IID_ID2D1TransformGraph_Value;
pub const ID2D1TransformGraph = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetSingleTransformNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                node: ?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                fromNode: ?*ID2D1TransformNode,
                toNode: ?*ID2D1TransformNode,
                toNodeInputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                fromNode: ?*ID2D1TransformNode,
                toNode: ?*ID2D1TransformNode,
                toNodeInputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectToEffectInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                toEffectInputIndex: u32,
                node: ?*ID2D1TransformNode,
                toNodeInputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                toEffectInputIndex: u32,
                node: ?*ID2D1TransformNode,
                toNodeInputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPassthroughGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformGraph,
                effectInputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1TransformGraph,
                effectInputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_GetInputCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).GetInputCount(@as(*const ID2D1TransformGraph, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_SetSingleTransformNode(self: *const T, node: ?*ID2D1TransformNode) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).SetSingleTransformNode(@as(*const ID2D1TransformGraph, @ptrCast(self)), node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_AddNode(self: *const T, node: ?*ID2D1TransformNode) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).AddNode(@as(*const ID2D1TransformGraph, @ptrCast(self)), node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_RemoveNode(self: *const T, node: ?*ID2D1TransformNode) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).RemoveNode(@as(*const ID2D1TransformGraph, @ptrCast(self)), node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_SetOutputNode(self: *const T, node: ?*ID2D1TransformNode) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).SetOutputNode(@as(*const ID2D1TransformGraph, @ptrCast(self)), node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_ConnectNode(self: *const T, fromNode: ?*ID2D1TransformNode, toNode: ?*ID2D1TransformNode, toNodeInputIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).ConnectNode(@as(*const ID2D1TransformGraph, @ptrCast(self)), fromNode, toNode, toNodeInputIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_ConnectToEffectInput(self: *const T, toEffectInputIndex: u32, node: ?*ID2D1TransformNode, toNodeInputIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).ConnectToEffectInput(@as(*const ID2D1TransformGraph, @ptrCast(self)), toEffectInputIndex, node, toNodeInputIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_Clear(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).Clear(@as(*const ID2D1TransformGraph, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformGraph_SetPassthroughGraph(self: *const T, effectInputIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1TransformGraph.VTable, @ptrCast(self.vtable)).SetPassthroughGraph(@as(*const ID2D1TransformGraph, @ptrCast(self)), effectInputIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1Transform_Value = Guid.initString("ef1a287d-342a-4f76-8fdb-da0d6ea9f92b");
pub const IID_ID2D1Transform = &IID_ID2D1Transform_Value;
pub const ID2D1Transform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1TransformNode.VTable,
        MapOutputRectToInputRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Transform,
                outputRect: ?*const RECT,
                inputRects: [*]RECT,
                inputRectsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Transform,
                outputRect: ?*const RECT,
                inputRects: [*]RECT,
                inputRectsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapInputRectsToOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Transform,
                inputRects: [*]const RECT,
                inputOpaqueSubRects: [*]const RECT,
                inputRectCount: u32,
                outputRect: ?*RECT,
                outputOpaqueSubRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Transform,
                inputRects: [*]const RECT,
                inputOpaqueSubRects: [*]const RECT,
                inputRectCount: u32,
                outputRect: ?*RECT,
                outputOpaqueSubRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapInvalidRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Transform,
                inputIndex: u32,
                invalidInputRect: RECT,
                invalidOutputRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Transform,
                inputIndex: u32,
                invalidInputRect: RECT,
                invalidOutputRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1TransformNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Transform_MapOutputRectToInputRects(self: *const T, outputRect: ?*const RECT, inputRects: [*]RECT, inputRectsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Transform.VTable, @ptrCast(self.vtable)).MapOutputRectToInputRects(@as(*const ID2D1Transform, @ptrCast(self)), outputRect, inputRects, inputRectsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Transform_MapInputRectsToOutputRect(self: *const T, inputRects: [*]const RECT, inputOpaqueSubRects: [*]const RECT, inputRectCount: u32, outputRect: ?*RECT, outputOpaqueSubRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Transform.VTable, @ptrCast(self.vtable)).MapInputRectsToOutputRect(@as(*const ID2D1Transform, @ptrCast(self)), inputRects, inputOpaqueSubRects, inputRectCount, outputRect, outputOpaqueSubRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Transform_MapInvalidRect(self: *const T, inputIndex: u32, invalidInputRect: RECT, invalidOutputRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Transform.VTable, @ptrCast(self.vtable)).MapInvalidRect(@as(*const ID2D1Transform, @ptrCast(self)), inputIndex, invalidInputRect, invalidOutputRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1DrawTransform_Value = Guid.initString("36bfdcb6-9739-435d-a30d-a653beff6a6f");
pub const IID_ID2D1DrawTransform = &IID_ID2D1DrawTransform_Value;
pub const ID2D1DrawTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Transform.VTable,
        SetDrawInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DrawTransform,
                drawInfo: ?*ID2D1DrawInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DrawTransform,
                drawInfo: ?*ID2D1DrawInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Transform.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DrawTransform_SetDrawInfo(self: *const T, drawInfo: ?*ID2D1DrawInfo) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DrawTransform.VTable, @ptrCast(self.vtable)).SetDrawInfo(@as(*const ID2D1DrawTransform, @ptrCast(self)), drawInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1ComputeTransform_Value = Guid.initString("0d85573c-01e3-4f7d-bfd9-0d60608bf3c3");
pub const IID_ID2D1ComputeTransform = &IID_ID2D1ComputeTransform_Value;
pub const ID2D1ComputeTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Transform.VTable,
        SetComputeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ComputeTransform,
                computeInfo: ?*ID2D1ComputeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ComputeTransform,
                computeInfo: ?*ID2D1ComputeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CalculateThreadgroups: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ComputeTransform,
                outputRect: ?*const RECT,
                dimensionX: ?*u32,
                dimensionY: ?*u32,
                dimensionZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ComputeTransform,
                outputRect: ?*const RECT,
                dimensionX: ?*u32,
                dimensionY: ?*u32,
                dimensionZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Transform.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ComputeTransform_SetComputeInfo(self: *const T, computeInfo: ?*ID2D1ComputeInfo) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ComputeTransform.VTable, @ptrCast(self.vtable)).SetComputeInfo(@as(*const ID2D1ComputeTransform, @ptrCast(self)), computeInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ComputeTransform_CalculateThreadgroups(self: *const T, outputRect: ?*const RECT, dimensionX: ?*u32, dimensionY: ?*u32, dimensionZ: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ComputeTransform.VTable, @ptrCast(self.vtable)).CalculateThreadgroups(@as(*const ID2D1ComputeTransform, @ptrCast(self)), outputRect, dimensionX, dimensionY, dimensionZ);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1AnalysisTransform_Value = Guid.initString("0359dc30-95e6-4568-9055-27720d130e93");
pub const IID_ID2D1AnalysisTransform = &IID_ID2D1AnalysisTransform_Value;
pub const ID2D1AnalysisTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProcessAnalysisResults: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1AnalysisTransform,
                analysisData: [*:0]const u8,
                analysisDataCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1AnalysisTransform,
                analysisData: [*:0]const u8,
                analysisDataCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1AnalysisTransform_ProcessAnalysisResults(self: *const T, analysisData: [*:0]const u8, analysisDataCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1AnalysisTransform.VTable, @ptrCast(self.vtable)).ProcessAnalysisResults(@as(*const ID2D1AnalysisTransform, @ptrCast(self)), analysisData, analysisDataCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1SourceTransform_Value = Guid.initString("db1800dd-0c34-4cf9-be90-31cc0a5653e1");
pub const IID_ID2D1SourceTransform = &IID_ID2D1SourceTransform_Value;
pub const ID2D1SourceTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Transform.VTable,
        SetRenderInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SourceTransform,
                renderInfo: ?*ID2D1RenderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SourceTransform,
                renderInfo: ?*ID2D1RenderInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Draw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SourceTransform,
                target: ?*ID2D1Bitmap1,
                drawRect: ?*const RECT,
                targetOrigin: D2D_POINT_2U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SourceTransform,
                target: ?*ID2D1Bitmap1,
                drawRect: ?*const RECT,
                targetOrigin: D2D_POINT_2U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Transform.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SourceTransform_SetRenderInfo(self: *const T, renderInfo: ?*ID2D1RenderInfo) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SourceTransform.VTable, @ptrCast(self.vtable)).SetRenderInfo(@as(*const ID2D1SourceTransform, @ptrCast(self)), renderInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SourceTransform_Draw(self: *const T, target: ?*ID2D1Bitmap1, drawRect: ?*const RECT, targetOrigin: D2D_POINT_2U) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SourceTransform.VTable, @ptrCast(self.vtable)).Draw(@as(*const ID2D1SourceTransform, @ptrCast(self)), target, drawRect, targetOrigin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1ConcreteTransform_Value = Guid.initString("1a799d8a-69f7-4e4c-9fed-437ccc6684cc");
pub const IID_ID2D1ConcreteTransform = &IID_ID2D1ConcreteTransform_Value;
pub const ID2D1ConcreteTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1TransformNode.VTable,
        SetOutputBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ConcreteTransform,
                bufferPrecision: D2D1_BUFFER_PRECISION,
                channelDepth: D2D1_CHANNEL_DEPTH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ConcreteTransform,
                bufferPrecision: D2D1_BUFFER_PRECISION,
                channelDepth: D2D1_CHANNEL_DEPTH,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ConcreteTransform,
                isCached: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ConcreteTransform,
                isCached: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1TransformNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ConcreteTransform_SetOutputBuffer(self: *const T, bufferPrecision: D2D1_BUFFER_PRECISION, channelDepth: D2D1_CHANNEL_DEPTH) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ConcreteTransform.VTable, @ptrCast(self.vtable)).SetOutputBuffer(@as(*const ID2D1ConcreteTransform, @ptrCast(self)), bufferPrecision, channelDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ConcreteTransform_SetCached(self: *const T, isCached: BOOL) callconv(.Inline) void {
            return @as(*const ID2D1ConcreteTransform.VTable, @ptrCast(self.vtable)).SetCached(@as(*const ID2D1ConcreteTransform, @ptrCast(self)), isCached);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1BlendTransform_Value = Guid.initString("63ac0b32-ba44-450f-8806-7f4ca1ff2f1b");
pub const IID_ID2D1BlendTransform = &IID_ID2D1BlendTransform_Value;
pub const ID2D1BlendTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1ConcreteTransform.VTable,
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BlendTransform,
                description: ?*const D2D1_BLEND_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BlendTransform,
                description: ?*const D2D1_BLEND_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BlendTransform,
                description: ?*D2D1_BLEND_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BlendTransform,
                description: ?*D2D1_BLEND_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1ConcreteTransform.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BlendTransform_SetDescription(self: *const T, description: ?*const D2D1_BLEND_DESCRIPTION) callconv(.Inline) void {
            return @as(*const ID2D1BlendTransform.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const ID2D1BlendTransform, @ptrCast(self)), description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BlendTransform_GetDescription(self: *const T, description: ?*D2D1_BLEND_DESCRIPTION) callconv(.Inline) void {
            return @as(*const ID2D1BlendTransform.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const ID2D1BlendTransform, @ptrCast(self)), description);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1BorderTransform_Value = Guid.initString("4998735c-3a19-473c-9781-656847e3a347");
pub const IID_ID2D1BorderTransform = &IID_ID2D1BorderTransform_Value;
pub const ID2D1BorderTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1ConcreteTransform.VTable,
        SetExtendModeX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BorderTransform,
                extendMode: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BorderTransform,
                extendMode: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetExtendModeY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BorderTransform,
                extendMode: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BorderTransform,
                extendMode: D2D1_EXTEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetExtendModeX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BorderTransform,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1BorderTransform,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
        GetExtendModeY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BorderTransform,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
            else => *const fn(
                self: *const ID2D1BorderTransform,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_EXTEND_MODE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1ConcreteTransform.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BorderTransform_SetExtendModeX(self: *const T, extendMode: D2D1_EXTEND_MODE) callconv(.Inline) void {
            return @as(*const ID2D1BorderTransform.VTable, @ptrCast(self.vtable)).SetExtendModeX(@as(*const ID2D1BorderTransform, @ptrCast(self)), extendMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BorderTransform_SetExtendModeY(self: *const T, extendMode: D2D1_EXTEND_MODE) callconv(.Inline) void {
            return @as(*const ID2D1BorderTransform.VTable, @ptrCast(self.vtable)).SetExtendModeY(@as(*const ID2D1BorderTransform, @ptrCast(self)), extendMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BorderTransform_GetExtendModeX(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1BorderTransform.VTable, @ptrCast(self.vtable)).GetExtendModeX(@as(*const ID2D1BorderTransform, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BorderTransform_GetExtendModeY(self: *const T) callconv(.Inline) D2D1_EXTEND_MODE {
            return @as(*const ID2D1BorderTransform.VTable, @ptrCast(self.vtable)).GetExtendModeY(@as(*const ID2D1BorderTransform, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1OffsetTransform_Value = Guid.initString("3fe6adea-7643-4f53-bd14-a0ce63f24042");
pub const IID_ID2D1OffsetTransform = &IID_ID2D1OffsetTransform_Value;
pub const ID2D1OffsetTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1TransformNode.VTable,
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1OffsetTransform,
                offset: POINT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1OffsetTransform,
                offset: POINT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1OffsetTransform,
            ) callconv(@import("std").os.windows.WINAPI) POINT,
            else => *const fn(
                self: *const ID2D1OffsetTransform,
            ) callconv(@import("std").os.windows.WINAPI) POINT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1TransformNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1OffsetTransform_SetOffset(self: *const T, offset: POINT) callconv(.Inline) void {
            return @as(*const ID2D1OffsetTransform.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const ID2D1OffsetTransform, @ptrCast(self)), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1OffsetTransform_GetOffset(self: *const T) callconv(.Inline) POINT {
            return @as(*const ID2D1OffsetTransform.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const ID2D1OffsetTransform, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1BoundsAdjustmentTransform_Value = Guid.initString("90f732e2-5092-4606-a819-8651970baccd");
pub const IID_ID2D1BoundsAdjustmentTransform = &IID_ID2D1BoundsAdjustmentTransform_Value;
pub const ID2D1BoundsAdjustmentTransform = extern struct {
    pub const VTable = extern struct {
        base: ID2D1TransformNode.VTable,
        SetOutputBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BoundsAdjustmentTransform,
                outputBounds: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BoundsAdjustmentTransform,
                outputBounds: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetOutputBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1BoundsAdjustmentTransform,
                outputBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1BoundsAdjustmentTransform,
                outputBounds: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1TransformNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BoundsAdjustmentTransform_SetOutputBounds(self: *const T, outputBounds: ?*const RECT) callconv(.Inline) void {
            return @as(*const ID2D1BoundsAdjustmentTransform.VTable, @ptrCast(self.vtable)).SetOutputBounds(@as(*const ID2D1BoundsAdjustmentTransform, @ptrCast(self)), outputBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1BoundsAdjustmentTransform_GetOutputBounds(self: *const T, outputBounds: ?*RECT) callconv(.Inline) void {
            return @as(*const ID2D1BoundsAdjustmentTransform.VTable, @ptrCast(self.vtable)).GetOutputBounds(@as(*const ID2D1BoundsAdjustmentTransform, @ptrCast(self)), outputBounds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1EffectImpl_Value = Guid.initString("a248fd3f-3e6c-4e63-9f03-7f68ecc91db9");
pub const IID_ID2D1EffectImpl = &IID_ID2D1EffectImpl_Value;
pub const ID2D1EffectImpl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectImpl,
                effectContext: ?*ID2D1EffectContext,
                transformGraph: ?*ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectImpl,
                effectContext: ?*ID2D1EffectContext,
                transformGraph: ?*ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareForRender: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectImpl,
                changeType: D2D1_CHANGE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectImpl,
                changeType: D2D1_CHANGE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectImpl,
                transformGraph: ?*ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectImpl,
                transformGraph: ?*ID2D1TransformGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectImpl_Initialize(self: *const T, effectContext: ?*ID2D1EffectContext, transformGraph: ?*ID2D1TransformGraph) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectImpl.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ID2D1EffectImpl, @ptrCast(self)), effectContext, transformGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectImpl_PrepareForRender(self: *const T, changeType: D2D1_CHANGE_TYPE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectImpl.VTable, @ptrCast(self.vtable)).PrepareForRender(@as(*const ID2D1EffectImpl, @ptrCast(self)), changeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectImpl_SetGraph(self: *const T, transformGraph: ?*ID2D1TransformGraph) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectImpl.VTable, @ptrCast(self.vtable)).SetGraph(@as(*const ID2D1EffectImpl, @ptrCast(self)), transformGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ID2D1EffectContext_Value = Guid.initString("3d9f916b-27dc-4ad7-b4f1-64945340f563");
pub const IID_ID2D1EffectContext = &IID_ID2D1EffectContext_Value;
pub const ID2D1EffectContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDpi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1EffectContext,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                effectId: ?*const Guid,
                effect: ?*?*ID2D1Effect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                effectId: ?*const Guid,
                effect: ?*?*ID2D1Effect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumSupportedFeatureLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                featureLevels: [*]const D3D_FEATURE_LEVEL,
                featureLevelsCount: u32,
                maximumSupportedFeatureLevel: ?*D3D_FEATURE_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                featureLevels: [*]const D3D_FEATURE_LEVEL,
                featureLevelsCount: u32,
                maximumSupportedFeatureLevel: ?*D3D_FEATURE_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTransformNodeFromEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                effect: ?*ID2D1Effect,
                transformNode: ?*?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                effect: ?*ID2D1Effect,
                transformNode: ?*?*ID2D1TransformNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBlendTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                numInputs: u32,
                blendDescription: ?*const D2D1_BLEND_DESCRIPTION,
                transform: ?*?*ID2D1BlendTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                numInputs: u32,
                blendDescription: ?*const D2D1_BLEND_DESCRIPTION,
                transform: ?*?*ID2D1BlendTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBorderTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                extendModeX: D2D1_EXTEND_MODE,
                extendModeY: D2D1_EXTEND_MODE,
                transform: ?*?*ID2D1BorderTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                extendModeX: D2D1_EXTEND_MODE,
                extendModeY: D2D1_EXTEND_MODE,
                transform: ?*?*ID2D1BorderTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateOffsetTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                offset: POINT,
                transform: ?*?*ID2D1OffsetTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                offset: POINT,
                transform: ?*?*ID2D1OffsetTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBoundsAdjustmentTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                outputRectangle: ?*const RECT,
                transform: ?*?*ID2D1BoundsAdjustmentTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                outputRectangle: ?*const RECT,
                transform: ?*?*ID2D1BoundsAdjustmentTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadPixelShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                shaderId: ?*const Guid,
                shaderBuffer: [*:0]const u8,
                shaderBufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                shaderId: ?*const Guid,
                shaderBuffer: [*:0]const u8,
                shaderBufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadVertexShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                shaderBuffer: [*:0]const u8,
                shaderBufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                shaderBuffer: [*:0]const u8,
                shaderBufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadComputeShader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                shaderBuffer: [*:0]const u8,
                shaderBufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                shaderBuffer: [*:0]const u8,
                shaderBufferCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsShaderLoaded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                shaderId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1EffectContext,
                shaderId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        CreateResourceTexture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                resourceTextureProperties: ?*const D2D1_RESOURCE_TEXTURE_PROPERTIES,
                data: ?[*:0]const u8,
                strides: ?*const u32,
                dataSize: u32,
                resourceTexture: ?*?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                resourceTextureProperties: ?*const D2D1_RESOURCE_TEXTURE_PROPERTIES,
                data: ?[*:0]const u8,
                strides: ?*const u32,
                dataSize: u32,
                resourceTexture: ?*?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindResourceTexture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                resourceTexture: ?*?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                resourceTexture: ?*?*ID2D1ResourceTexture,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVertexBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                vertexBufferProperties: ?*const D2D1_VERTEX_BUFFER_PROPERTIES,
                resourceId: ?*const Guid,
                customVertexBufferProperties: ?*const D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES,
                buffer: ?*?*ID2D1VertexBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                vertexBufferProperties: ?*const D2D1_VERTEX_BUFFER_PROPERTIES,
                resourceId: ?*const Guid,
                customVertexBufferProperties: ?*const D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES,
                buffer: ?*?*ID2D1VertexBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindVertexBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                buffer: ?*?*ID2D1VertexBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                resourceId: ?*const Guid,
                buffer: ?*?*ID2D1VertexBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                space: D2D1_COLOR_SPACE,
                profile: ?[*:0]const u8,
                profileSize: u32,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                space: D2D1_COLOR_SPACE,
                profile: ?[*:0]const u8,
                profileSize: u32,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContextFromFilename: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                filename: ?[*:0]const u16,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                filename: ?[*:0]const u16,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContextFromWicColorContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                wicColorContext: ?*IWICColorContext,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                wicColorContext: ?*IWICColorContext,
                colorContext: ?*?*ID2D1ColorContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckFeatureSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                feature: D2D1_FEATURE,
                // TODO: what to do with BytesParamIndex 2?
                featureSupportData: ?*anyopaque,
                featureSupportDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext,
                feature: D2D1_FEATURE,
                // TODO: what to do with BytesParamIndex 2?
                featureSupportData: ?*anyopaque,
                featureSupportDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsBufferPrecisionSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext,
                bufferPrecision: D2D1_BUFFER_PRECISION,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1EffectContext,
                bufferPrecision: D2D1_BUFFER_PRECISION,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_GetDpi(self: *const T, dpiX: ?*f32, dpiY: ?*f32) callconv(.Inline) void {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).GetDpi(@as(*const ID2D1EffectContext, @ptrCast(self)), dpiX, dpiY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateEffect(self: *const T, effectId: ?*const Guid, effect: ?*?*ID2D1Effect) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateEffect(@as(*const ID2D1EffectContext, @ptrCast(self)), effectId, effect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_GetMaximumSupportedFeatureLevel(self: *const T, featureLevels: [*]const D3D_FEATURE_LEVEL, featureLevelsCount: u32, maximumSupportedFeatureLevel: ?*D3D_FEATURE_LEVEL) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).GetMaximumSupportedFeatureLevel(@as(*const ID2D1EffectContext, @ptrCast(self)), featureLevels, featureLevelsCount, maximumSupportedFeatureLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateTransformNodeFromEffect(self: *const T, effect: ?*ID2D1Effect, transformNode: ?*?*ID2D1TransformNode) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateTransformNodeFromEffect(@as(*const ID2D1EffectContext, @ptrCast(self)), effect, transformNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateBlendTransform(self: *const T, numInputs: u32, blendDescription: ?*const D2D1_BLEND_DESCRIPTION, transform: ?*?*ID2D1BlendTransform) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateBlendTransform(@as(*const ID2D1EffectContext, @ptrCast(self)), numInputs, blendDescription, transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateBorderTransform(self: *const T, extendModeX: D2D1_EXTEND_MODE, extendModeY: D2D1_EXTEND_MODE, transform: ?*?*ID2D1BorderTransform) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateBorderTransform(@as(*const ID2D1EffectContext, @ptrCast(self)), extendModeX, extendModeY, transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateOffsetTransform(self: *const T, offset: POINT, transform: ?*?*ID2D1OffsetTransform) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateOffsetTransform(@as(*const ID2D1EffectContext, @ptrCast(self)), offset, transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateBoundsAdjustmentTransform(self: *const T, outputRectangle: ?*const RECT, transform: ?*?*ID2D1BoundsAdjustmentTransform) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateBoundsAdjustmentTransform(@as(*const ID2D1EffectContext, @ptrCast(self)), outputRectangle, transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_LoadPixelShader(self: *const T, shaderId: ?*const Guid, shaderBuffer: [*:0]const u8, shaderBufferCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).LoadPixelShader(@as(*const ID2D1EffectContext, @ptrCast(self)), shaderId, shaderBuffer, shaderBufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_LoadVertexShader(self: *const T, resourceId: ?*const Guid, shaderBuffer: [*:0]const u8, shaderBufferCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).LoadVertexShader(@as(*const ID2D1EffectContext, @ptrCast(self)), resourceId, shaderBuffer, shaderBufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_LoadComputeShader(self: *const T, resourceId: ?*const Guid, shaderBuffer: [*:0]const u8, shaderBufferCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).LoadComputeShader(@as(*const ID2D1EffectContext, @ptrCast(self)), resourceId, shaderBuffer, shaderBufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_IsShaderLoaded(self: *const T, shaderId: ?*const Guid) callconv(.Inline) BOOL {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).IsShaderLoaded(@as(*const ID2D1EffectContext, @ptrCast(self)), shaderId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateResourceTexture(self: *const T, resourceId: ?*const Guid, resourceTextureProperties: ?*const D2D1_RESOURCE_TEXTURE_PROPERTIES, data: ?[*:0]const u8, strides: ?*const u32, dataSize: u32, resourceTexture: ?*?*ID2D1ResourceTexture) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateResourceTexture(@as(*const ID2D1EffectContext, @ptrCast(self)), resourceId, resourceTextureProperties, data, strides, dataSize, resourceTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_FindResourceTexture(self: *const T, resourceId: ?*const Guid, resourceTexture: ?*?*ID2D1ResourceTexture) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).FindResourceTexture(@as(*const ID2D1EffectContext, @ptrCast(self)), resourceId, resourceTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateVertexBuffer(self: *const T, vertexBufferProperties: ?*const D2D1_VERTEX_BUFFER_PROPERTIES, resourceId: ?*const Guid, customVertexBufferProperties: ?*const D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES, buffer: ?*?*ID2D1VertexBuffer) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateVertexBuffer(@as(*const ID2D1EffectContext, @ptrCast(self)), vertexBufferProperties, resourceId, customVertexBufferProperties, buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_FindVertexBuffer(self: *const T, resourceId: ?*const Guid, buffer: ?*?*ID2D1VertexBuffer) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).FindVertexBuffer(@as(*const ID2D1EffectContext, @ptrCast(self)), resourceId, buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateColorContext(self: *const T, space: D2D1_COLOR_SPACE, profile: ?[*:0]const u8, profileSize: u32, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateColorContext(@as(*const ID2D1EffectContext, @ptrCast(self)), space, profile, profileSize, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateColorContextFromFilename(self: *const T, filename: ?[*:0]const u16, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateColorContextFromFilename(@as(*const ID2D1EffectContext, @ptrCast(self)), filename, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CreateColorContextFromWicColorContext(self: *const T, wicColorContext: ?*IWICColorContext, colorContext: ?*?*ID2D1ColorContext) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CreateColorContextFromWicColorContext(@as(*const ID2D1EffectContext, @ptrCast(self)), wicColorContext, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_CheckFeatureSupport(self: *const T, feature: D2D1_FEATURE, featureSupportData: ?*anyopaque, featureSupportDataSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).CheckFeatureSupport(@as(*const ID2D1EffectContext, @ptrCast(self)), feature, featureSupportData, featureSupportDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext_IsBufferPrecisionSupported(self: *const T, bufferPrecision: D2D1_BUFFER_PRECISION) callconv(.Inline) BOOL {
            return @as(*const ID2D1EffectContext.VTable, @ptrCast(self.vtable)).IsBufferPrecisionSupported(@as(*const ID2D1EffectContext, @ptrCast(self)), bufferPrecision);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D2D1_YCBCR_PROP = enum(u32) {
    CHROMA_SUBSAMPLING = 0,
    TRANSFORM_MATRIX = 1,
    INTERPOLATION_MODE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_YCBCR_PROP_CHROMA_SUBSAMPLING = D2D1_YCBCR_PROP.CHROMA_SUBSAMPLING;
pub const D2D1_YCBCR_PROP_TRANSFORM_MATRIX = D2D1_YCBCR_PROP.TRANSFORM_MATRIX;
pub const D2D1_YCBCR_PROP_INTERPOLATION_MODE = D2D1_YCBCR_PROP.INTERPOLATION_MODE;
pub const D2D1_YCBCR_PROP_FORCE_DWORD = D2D1_YCBCR_PROP.FORCE_DWORD;

pub const D2D1_YCBCR_CHROMA_SUBSAMPLING = enum(u32) {
    AUTO = 0,
    @"420" = 1,
    @"422" = 2,
    @"444" = 3,
    @"440" = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_YCBCR_CHROMA_SUBSAMPLING_AUTO = D2D1_YCBCR_CHROMA_SUBSAMPLING.AUTO;
pub const D2D1_YCBCR_CHROMA_SUBSAMPLING_420 = D2D1_YCBCR_CHROMA_SUBSAMPLING.@"420";
pub const D2D1_YCBCR_CHROMA_SUBSAMPLING_422 = D2D1_YCBCR_CHROMA_SUBSAMPLING.@"422";
pub const D2D1_YCBCR_CHROMA_SUBSAMPLING_444 = D2D1_YCBCR_CHROMA_SUBSAMPLING.@"444";
pub const D2D1_YCBCR_CHROMA_SUBSAMPLING_440 = D2D1_YCBCR_CHROMA_SUBSAMPLING.@"440";
pub const D2D1_YCBCR_CHROMA_SUBSAMPLING_FORCE_DWORD = D2D1_YCBCR_CHROMA_SUBSAMPLING.FORCE_DWORD;

pub const D2D1_YCBCR_INTERPOLATION_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    HIGH_QUALITY_CUBIC = 5,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_YCBCR_INTERPOLATION_MODE_NEAREST_NEIGHBOR = D2D1_YCBCR_INTERPOLATION_MODE.NEAREST_NEIGHBOR;
pub const D2D1_YCBCR_INTERPOLATION_MODE_LINEAR = D2D1_YCBCR_INTERPOLATION_MODE.LINEAR;
pub const D2D1_YCBCR_INTERPOLATION_MODE_CUBIC = D2D1_YCBCR_INTERPOLATION_MODE.CUBIC;
pub const D2D1_YCBCR_INTERPOLATION_MODE_MULTI_SAMPLE_LINEAR = D2D1_YCBCR_INTERPOLATION_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_YCBCR_INTERPOLATION_MODE_ANISOTROPIC = D2D1_YCBCR_INTERPOLATION_MODE.ANISOTROPIC;
pub const D2D1_YCBCR_INTERPOLATION_MODE_HIGH_QUALITY_CUBIC = D2D1_YCBCR_INTERPOLATION_MODE.HIGH_QUALITY_CUBIC;
pub const D2D1_YCBCR_INTERPOLATION_MODE_FORCE_DWORD = D2D1_YCBCR_INTERPOLATION_MODE.FORCE_DWORD;

pub const D2D1_CONTRAST_PROP = enum(u32) {
    CONTRAST = 0,
    CLAMP_INPUT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CONTRAST_PROP_CONTRAST = D2D1_CONTRAST_PROP.CONTRAST;
pub const D2D1_CONTRAST_PROP_CLAMP_INPUT = D2D1_CONTRAST_PROP.CLAMP_INPUT;
pub const D2D1_CONTRAST_PROP_FORCE_DWORD = D2D1_CONTRAST_PROP.FORCE_DWORD;

pub const D2D1_RGBTOHUE_PROP = enum(u32) {
    OUTPUT_COLOR_SPACE = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_RGBTOHUE_PROP_OUTPUT_COLOR_SPACE = D2D1_RGBTOHUE_PROP.OUTPUT_COLOR_SPACE;
pub const D2D1_RGBTOHUE_PROP_FORCE_DWORD = D2D1_RGBTOHUE_PROP.FORCE_DWORD;

pub const D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE = enum(u32) {
    HUE_SATURATION_VALUE = 0,
    HUE_SATURATION_LIGHTNESS = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_VALUE = D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE.HUE_SATURATION_VALUE;
pub const D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS = D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE.HUE_SATURATION_LIGHTNESS;
pub const D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE_FORCE_DWORD = D2D1_RGBTOHUE_OUTPUT_COLOR_SPACE.FORCE_DWORD;

pub const D2D1_HUETORGB_PROP = enum(u32) {
    INPUT_COLOR_SPACE = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HUETORGB_PROP_INPUT_COLOR_SPACE = D2D1_HUETORGB_PROP.INPUT_COLOR_SPACE;
pub const D2D1_HUETORGB_PROP_FORCE_DWORD = D2D1_HUETORGB_PROP.FORCE_DWORD;

pub const D2D1_HUETORGB_INPUT_COLOR_SPACE = enum(u32) {
    HUE_SATURATION_VALUE = 0,
    HUE_SATURATION_LIGHTNESS = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_VALUE = D2D1_HUETORGB_INPUT_COLOR_SPACE.HUE_SATURATION_VALUE;
pub const D2D1_HUETORGB_INPUT_COLOR_SPACE_HUE_SATURATION_LIGHTNESS = D2D1_HUETORGB_INPUT_COLOR_SPACE.HUE_SATURATION_LIGHTNESS;
pub const D2D1_HUETORGB_INPUT_COLOR_SPACE_FORCE_DWORD = D2D1_HUETORGB_INPUT_COLOR_SPACE.FORCE_DWORD;

pub const D2D1_CHROMAKEY_PROP = enum(u32) {
    COLOR = 0,
    TOLERANCE = 1,
    INVERT_ALPHA = 2,
    FEATHER = 3,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CHROMAKEY_PROP_COLOR = D2D1_CHROMAKEY_PROP.COLOR;
pub const D2D1_CHROMAKEY_PROP_TOLERANCE = D2D1_CHROMAKEY_PROP.TOLERANCE;
pub const D2D1_CHROMAKEY_PROP_INVERT_ALPHA = D2D1_CHROMAKEY_PROP.INVERT_ALPHA;
pub const D2D1_CHROMAKEY_PROP_FEATHER = D2D1_CHROMAKEY_PROP.FEATHER;
pub const D2D1_CHROMAKEY_PROP_FORCE_DWORD = D2D1_CHROMAKEY_PROP.FORCE_DWORD;

pub const D2D1_EMBOSS_PROP = enum(u32) {
    HEIGHT = 0,
    DIRECTION = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_EMBOSS_PROP_HEIGHT = D2D1_EMBOSS_PROP.HEIGHT;
pub const D2D1_EMBOSS_PROP_DIRECTION = D2D1_EMBOSS_PROP.DIRECTION;
pub const D2D1_EMBOSS_PROP_FORCE_DWORD = D2D1_EMBOSS_PROP.FORCE_DWORD;

pub const D2D1_EXPOSURE_PROP = enum(u32) {
    EXPOSURE_VALUE = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_EXPOSURE_PROP_EXPOSURE_VALUE = D2D1_EXPOSURE_PROP.EXPOSURE_VALUE;
pub const D2D1_EXPOSURE_PROP_FORCE_DWORD = D2D1_EXPOSURE_PROP.FORCE_DWORD;

pub const D2D1_POSTERIZE_PROP = enum(u32) {
    RED_VALUE_COUNT = 0,
    GREEN_VALUE_COUNT = 1,
    BLUE_VALUE_COUNT = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_POSTERIZE_PROP_RED_VALUE_COUNT = D2D1_POSTERIZE_PROP.RED_VALUE_COUNT;
pub const D2D1_POSTERIZE_PROP_GREEN_VALUE_COUNT = D2D1_POSTERIZE_PROP.GREEN_VALUE_COUNT;
pub const D2D1_POSTERIZE_PROP_BLUE_VALUE_COUNT = D2D1_POSTERIZE_PROP.BLUE_VALUE_COUNT;
pub const D2D1_POSTERIZE_PROP_FORCE_DWORD = D2D1_POSTERIZE_PROP.FORCE_DWORD;

pub const D2D1_SEPIA_PROP = enum(u32) {
    INTENSITY = 0,
    ALPHA_MODE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SEPIA_PROP_INTENSITY = D2D1_SEPIA_PROP.INTENSITY;
pub const D2D1_SEPIA_PROP_ALPHA_MODE = D2D1_SEPIA_PROP.ALPHA_MODE;
pub const D2D1_SEPIA_PROP_FORCE_DWORD = D2D1_SEPIA_PROP.FORCE_DWORD;

pub const D2D1_SHARPEN_PROP = enum(u32) {
    SHARPNESS = 0,
    THRESHOLD = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SHARPEN_PROP_SHARPNESS = D2D1_SHARPEN_PROP.SHARPNESS;
pub const D2D1_SHARPEN_PROP_THRESHOLD = D2D1_SHARPEN_PROP.THRESHOLD;
pub const D2D1_SHARPEN_PROP_FORCE_DWORD = D2D1_SHARPEN_PROP.FORCE_DWORD;

pub const D2D1_STRAIGHTEN_PROP = enum(u32) {
    ANGLE = 0,
    MAINTAIN_SIZE = 1,
    SCALE_MODE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_STRAIGHTEN_PROP_ANGLE = D2D1_STRAIGHTEN_PROP.ANGLE;
pub const D2D1_STRAIGHTEN_PROP_MAINTAIN_SIZE = D2D1_STRAIGHTEN_PROP.MAINTAIN_SIZE;
pub const D2D1_STRAIGHTEN_PROP_SCALE_MODE = D2D1_STRAIGHTEN_PROP.SCALE_MODE;
pub const D2D1_STRAIGHTEN_PROP_FORCE_DWORD = D2D1_STRAIGHTEN_PROP.FORCE_DWORD;

pub const D2D1_STRAIGHTEN_SCALE_MODE = enum(u32) {
    NEAREST_NEIGHBOR = 0,
    LINEAR = 1,
    CUBIC = 2,
    MULTI_SAMPLE_LINEAR = 3,
    ANISOTROPIC = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_STRAIGHTEN_SCALE_MODE_NEAREST_NEIGHBOR = D2D1_STRAIGHTEN_SCALE_MODE.NEAREST_NEIGHBOR;
pub const D2D1_STRAIGHTEN_SCALE_MODE_LINEAR = D2D1_STRAIGHTEN_SCALE_MODE.LINEAR;
pub const D2D1_STRAIGHTEN_SCALE_MODE_CUBIC = D2D1_STRAIGHTEN_SCALE_MODE.CUBIC;
pub const D2D1_STRAIGHTEN_SCALE_MODE_MULTI_SAMPLE_LINEAR = D2D1_STRAIGHTEN_SCALE_MODE.MULTI_SAMPLE_LINEAR;
pub const D2D1_STRAIGHTEN_SCALE_MODE_ANISOTROPIC = D2D1_STRAIGHTEN_SCALE_MODE.ANISOTROPIC;
pub const D2D1_STRAIGHTEN_SCALE_MODE_FORCE_DWORD = D2D1_STRAIGHTEN_SCALE_MODE.FORCE_DWORD;

pub const D2D1_TEMPERATUREANDTINT_PROP = enum(u32) {
    TEMPERATURE = 0,
    TINT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_TEMPERATUREANDTINT_PROP_TEMPERATURE = D2D1_TEMPERATUREANDTINT_PROP.TEMPERATURE;
pub const D2D1_TEMPERATUREANDTINT_PROP_TINT = D2D1_TEMPERATUREANDTINT_PROP.TINT;
pub const D2D1_TEMPERATUREANDTINT_PROP_FORCE_DWORD = D2D1_TEMPERATUREANDTINT_PROP.FORCE_DWORD;

pub const D2D1_VIGNETTE_PROP = enum(u32) {
    COLOR = 0,
    TRANSITION_SIZE = 1,
    STRENGTH = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_VIGNETTE_PROP_COLOR = D2D1_VIGNETTE_PROP.COLOR;
pub const D2D1_VIGNETTE_PROP_TRANSITION_SIZE = D2D1_VIGNETTE_PROP.TRANSITION_SIZE;
pub const D2D1_VIGNETTE_PROP_STRENGTH = D2D1_VIGNETTE_PROP.STRENGTH;
pub const D2D1_VIGNETTE_PROP_FORCE_DWORD = D2D1_VIGNETTE_PROP.FORCE_DWORD;

pub const D2D1_EDGEDETECTION_PROP = enum(u32) {
    STRENGTH = 0,
    BLUR_RADIUS = 1,
    MODE = 2,
    OVERLAY_EDGES = 3,
    ALPHA_MODE = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_EDGEDETECTION_PROP_STRENGTH = D2D1_EDGEDETECTION_PROP.STRENGTH;
pub const D2D1_EDGEDETECTION_PROP_BLUR_RADIUS = D2D1_EDGEDETECTION_PROP.BLUR_RADIUS;
pub const D2D1_EDGEDETECTION_PROP_MODE = D2D1_EDGEDETECTION_PROP.MODE;
pub const D2D1_EDGEDETECTION_PROP_OVERLAY_EDGES = D2D1_EDGEDETECTION_PROP.OVERLAY_EDGES;
pub const D2D1_EDGEDETECTION_PROP_ALPHA_MODE = D2D1_EDGEDETECTION_PROP.ALPHA_MODE;
pub const D2D1_EDGEDETECTION_PROP_FORCE_DWORD = D2D1_EDGEDETECTION_PROP.FORCE_DWORD;

pub const D2D1_EDGEDETECTION_MODE = enum(u32) {
    SOBEL = 0,
    PREWITT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_EDGEDETECTION_MODE_SOBEL = D2D1_EDGEDETECTION_MODE.SOBEL;
pub const D2D1_EDGEDETECTION_MODE_PREWITT = D2D1_EDGEDETECTION_MODE.PREWITT;
pub const D2D1_EDGEDETECTION_MODE_FORCE_DWORD = D2D1_EDGEDETECTION_MODE.FORCE_DWORD;

pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP = enum(u32) {
    HIGHLIGHTS = 0,
    SHADOWS = 1,
    CLARITY = 2,
    INPUT_GAMMA = 3,
    MASK_BLUR_RADIUS = 4,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP_HIGHLIGHTS = D2D1_HIGHLIGHTSANDSHADOWS_PROP.HIGHLIGHTS;
pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP_SHADOWS = D2D1_HIGHLIGHTSANDSHADOWS_PROP.SHADOWS;
pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP_CLARITY = D2D1_HIGHLIGHTSANDSHADOWS_PROP.CLARITY;
pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP_INPUT_GAMMA = D2D1_HIGHLIGHTSANDSHADOWS_PROP.INPUT_GAMMA;
pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP_MASK_BLUR_RADIUS = D2D1_HIGHLIGHTSANDSHADOWS_PROP.MASK_BLUR_RADIUS;
pub const D2D1_HIGHLIGHTSANDSHADOWS_PROP_FORCE_DWORD = D2D1_HIGHLIGHTSANDSHADOWS_PROP.FORCE_DWORD;

pub const D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA = enum(u32) {
    LINEAR = 0,
    SRGB = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_LINEAR = D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA.LINEAR;
pub const D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_SRGB = D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA.SRGB;
pub const D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA_FORCE_DWORD = D2D1_HIGHLIGHTSANDSHADOWS_INPUT_GAMMA.FORCE_DWORD;

pub const D2D1_LOOKUPTABLE3D_PROP = enum(u32) {
    LUT = 0,
    ALPHA_MODE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_LOOKUPTABLE3D_PROP_LUT = D2D1_LOOKUPTABLE3D_PROP.LUT;
pub const D2D1_LOOKUPTABLE3D_PROP_ALPHA_MODE = D2D1_LOOKUPTABLE3D_PROP.ALPHA_MODE;
pub const D2D1_LOOKUPTABLE3D_PROP_FORCE_DWORD = D2D1_LOOKUPTABLE3D_PROP.FORCE_DWORD;

pub const D2D1_OPACITY_PROP = enum(u32) {
    OPACITY = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_OPACITY_PROP_OPACITY = D2D1_OPACITY_PROP.OPACITY;
pub const D2D1_OPACITY_PROP_FORCE_DWORD = D2D1_OPACITY_PROP.FORCE_DWORD;

pub const D2D1_CROSSFADE_PROP = enum(u32) {
    WEIGHT = 0,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_CROSSFADE_PROP_WEIGHT = D2D1_CROSSFADE_PROP.WEIGHT;
pub const D2D1_CROSSFADE_PROP_FORCE_DWORD = D2D1_CROSSFADE_PROP.FORCE_DWORD;

pub const D2D1_TINT_PROP = enum(u32) {
    COLOR = 0,
    CLAMP_OUTPUT = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_TINT_PROP_COLOR = D2D1_TINT_PROP.COLOR;
pub const D2D1_TINT_PROP_CLAMP_OUTPUT = D2D1_TINT_PROP.CLAMP_OUTPUT;
pub const D2D1_TINT_PROP_FORCE_DWORD = D2D1_TINT_PROP.FORCE_DWORD;

pub const D2D1_WHITELEVELADJUSTMENT_PROP = enum(u32) {
    INPUT_WHITE_LEVEL = 0,
    OUTPUT_WHITE_LEVEL = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_WHITELEVELADJUSTMENT_PROP_INPUT_WHITE_LEVEL = D2D1_WHITELEVELADJUSTMENT_PROP.INPUT_WHITE_LEVEL;
pub const D2D1_WHITELEVELADJUSTMENT_PROP_OUTPUT_WHITE_LEVEL = D2D1_WHITELEVELADJUSTMENT_PROP.OUTPUT_WHITE_LEVEL;
pub const D2D1_WHITELEVELADJUSTMENT_PROP_FORCE_DWORD = D2D1_WHITELEVELADJUSTMENT_PROP.FORCE_DWORD;

pub const D2D1_HDRTONEMAP_PROP = enum(u32) {
    INPUT_MAX_LUMINANCE = 0,
    OUTPUT_MAX_LUMINANCE = 1,
    DISPLAY_MODE = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HDRTONEMAP_PROP_INPUT_MAX_LUMINANCE = D2D1_HDRTONEMAP_PROP.INPUT_MAX_LUMINANCE;
pub const D2D1_HDRTONEMAP_PROP_OUTPUT_MAX_LUMINANCE = D2D1_HDRTONEMAP_PROP.OUTPUT_MAX_LUMINANCE;
pub const D2D1_HDRTONEMAP_PROP_DISPLAY_MODE = D2D1_HDRTONEMAP_PROP.DISPLAY_MODE;
pub const D2D1_HDRTONEMAP_PROP_FORCE_DWORD = D2D1_HDRTONEMAP_PROP.FORCE_DWORD;

pub const D2D1_HDRTONEMAP_DISPLAY_MODE = enum(u32) {
    SDR = 0,
    HDR = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_HDRTONEMAP_DISPLAY_MODE_SDR = D2D1_HDRTONEMAP_DISPLAY_MODE.SDR;
pub const D2D1_HDRTONEMAP_DISPLAY_MODE_HDR = D2D1_HDRTONEMAP_DISPLAY_MODE.HDR;
pub const D2D1_HDRTONEMAP_DISPLAY_MODE_FORCE_DWORD = D2D1_HDRTONEMAP_DISPLAY_MODE.FORCE_DWORD;

pub const D2D1_RENDERING_PRIORITY = enum(u32) {
    NORMAL = 0,
    LOW = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_RENDERING_PRIORITY_NORMAL = D2D1_RENDERING_PRIORITY.NORMAL;
pub const D2D1_RENDERING_PRIORITY_LOW = D2D1_RENDERING_PRIORITY.LOW;
pub const D2D1_RENDERING_PRIORITY_FORCE_DWORD = D2D1_RENDERING_PRIORITY.FORCE_DWORD;

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1GeometryRealization_Value = Guid.initString("a16907d7-bc02-4801-99e8-8cf7f485f774");
pub const IID_ID2D1GeometryRealization = &IID_ID2D1GeometryRealization_Value;
pub const ID2D1GeometryRealization = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1DeviceContext1_Value = Guid.initString("d37f57e4-6908-459f-a199-e72f24f79987");
pub const IID_ID2D1DeviceContext1 = &IID_ID2D1DeviceContext1_Value;
pub const ID2D1DeviceContext1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DeviceContext.VTable,
        CreateFilledGeometryRealization: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext1,
                geometry: ?*ID2D1Geometry,
                flatteningTolerance: f32,
                geometryRealization: ?*?*ID2D1GeometryRealization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext1,
                geometry: ?*ID2D1Geometry,
                flatteningTolerance: f32,
                geometryRealization: ?*?*ID2D1GeometryRealization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStrokedGeometryRealization: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext1,
                geometry: ?*ID2D1Geometry,
                flatteningTolerance: f32,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                geometryRealization: ?*?*ID2D1GeometryRealization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext1,
                geometry: ?*ID2D1Geometry,
                flatteningTolerance: f32,
                strokeWidth: f32,
                strokeStyle: ?*ID2D1StrokeStyle,
                geometryRealization: ?*?*ID2D1GeometryRealization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawGeometryRealization: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext1,
                geometryRealization: ?*ID2D1GeometryRealization,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext1,
                geometryRealization: ?*ID2D1GeometryRealization,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DeviceContext.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext1_CreateFilledGeometryRealization(self: *const T, geometry: ?*ID2D1Geometry, flatteningTolerance: f32, geometryRealization: ?*?*ID2D1GeometryRealization) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext1.VTable, @ptrCast(self.vtable)).CreateFilledGeometryRealization(@as(*const ID2D1DeviceContext1, @ptrCast(self)), geometry, flatteningTolerance, geometryRealization);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext1_CreateStrokedGeometryRealization(self: *const T, geometry: ?*ID2D1Geometry, flatteningTolerance: f32, strokeWidth: f32, strokeStyle: ?*ID2D1StrokeStyle, geometryRealization: ?*?*ID2D1GeometryRealization) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext1.VTable, @ptrCast(self.vtable)).CreateStrokedGeometryRealization(@as(*const ID2D1DeviceContext1, @ptrCast(self)), geometry, flatteningTolerance, strokeWidth, strokeStyle, geometryRealization);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext1_DrawGeometryRealization(self: *const T, geometryRealization: ?*ID2D1GeometryRealization, brush: ?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext1.VTable, @ptrCast(self.vtable)).DrawGeometryRealization(@as(*const ID2D1DeviceContext1, @ptrCast(self)), geometryRealization, brush);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1Device1_Value = Guid.initString("d21768e1-23a4-4823-a14b-7c3eba85d658");
pub const IID_ID2D1Device1 = &IID_ID2D1Device1_Value;
pub const ID2D1Device1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Device.VTable,
        GetRenderingPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_RENDERING_PRIORITY,
            else => *const fn(
                self: *const ID2D1Device1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_RENDERING_PRIORITY,
        },
        SetRenderingPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device1,
                renderingPriority: D2D1_RENDERING_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Device1,
                renderingPriority: D2D1_RENDERING_PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device1,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext1: ?*?*ID2D1DeviceContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device1,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext1: ?*?*ID2D1DeviceContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Device.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device1_GetRenderingPriority(self: *const T) callconv(.Inline) D2D1_RENDERING_PRIORITY {
            return @as(*const ID2D1Device1.VTable, @ptrCast(self.vtable)).GetRenderingPriority(@as(*const ID2D1Device1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device1_SetRenderingPriority(self: *const T, renderingPriority: D2D1_RENDERING_PRIORITY) callconv(.Inline) void {
            return @as(*const ID2D1Device1.VTable, @ptrCast(self.vtable)).SetRenderingPriority(@as(*const ID2D1Device1, @ptrCast(self)), renderingPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device1_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext1: ?*?*ID2D1DeviceContext1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device1.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device1, @ptrCast(self)), options, deviceContext1);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1Factory2_Value = Guid.initString("94f81a73-9212-4376-9c58-b16a3a0d3992");
pub const IID_ID2D1Factory2 = &IID_ID2D1Factory2_Value;
pub const ID2D1Factory2 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory1.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory2,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice1: ?*?*ID2D1Device1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory2,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice1: ?*?*ID2D1Device1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory2_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice1: ?*?*ID2D1Device1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory2.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory2, @ptrCast(self)), dxgiDevice, d2dDevice1);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1CommandSink1_Value = Guid.initString("9eb767fd-4269-4467-b8c2-eb30cb305743");
pub const IID_ID2D1CommandSink1 = &IID_ID2D1CommandSink1_Value;
pub const ID2D1CommandSink1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1CommandSink.VTable,
        SetPrimitiveBlend1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink1,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink1,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1CommandSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink1_SetPrimitiveBlend1(self: *const T, primitiveBlend: D2D1_PRIMITIVE_BLEND) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink1.VTable, @ptrCast(self.vtable)).SetPrimitiveBlend1(@as(*const ID2D1CommandSink1, @ptrCast(self)), primitiveBlend);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D2D1_SVG_PAINT_TYPE = enum(u32) {
    NONE = 0,
    COLOR = 1,
    CURRENT_COLOR = 2,
    URI = 3,
    URI_NONE = 4,
    URI_COLOR = 5,
    URI_CURRENT_COLOR = 6,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_PAINT_TYPE_NONE = D2D1_SVG_PAINT_TYPE.NONE;
pub const D2D1_SVG_PAINT_TYPE_COLOR = D2D1_SVG_PAINT_TYPE.COLOR;
pub const D2D1_SVG_PAINT_TYPE_CURRENT_COLOR = D2D1_SVG_PAINT_TYPE.CURRENT_COLOR;
pub const D2D1_SVG_PAINT_TYPE_URI = D2D1_SVG_PAINT_TYPE.URI;
pub const D2D1_SVG_PAINT_TYPE_URI_NONE = D2D1_SVG_PAINT_TYPE.URI_NONE;
pub const D2D1_SVG_PAINT_TYPE_URI_COLOR = D2D1_SVG_PAINT_TYPE.URI_COLOR;
pub const D2D1_SVG_PAINT_TYPE_URI_CURRENT_COLOR = D2D1_SVG_PAINT_TYPE.URI_CURRENT_COLOR;
pub const D2D1_SVG_PAINT_TYPE_FORCE_DWORD = D2D1_SVG_PAINT_TYPE.FORCE_DWORD;

pub const D2D1_SVG_LENGTH_UNITS = enum(u32) {
    NUMBER = 0,
    PERCENTAGE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_LENGTH_UNITS_NUMBER = D2D1_SVG_LENGTH_UNITS.NUMBER;
pub const D2D1_SVG_LENGTH_UNITS_PERCENTAGE = D2D1_SVG_LENGTH_UNITS.PERCENTAGE;
pub const D2D1_SVG_LENGTH_UNITS_FORCE_DWORD = D2D1_SVG_LENGTH_UNITS.FORCE_DWORD;

pub const D2D1_SVG_DISPLAY = enum(u32) {
    INLINE = 0,
    NONE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_DISPLAY_INLINE = D2D1_SVG_DISPLAY.INLINE;
pub const D2D1_SVG_DISPLAY_NONE = D2D1_SVG_DISPLAY.NONE;
pub const D2D1_SVG_DISPLAY_FORCE_DWORD = D2D1_SVG_DISPLAY.FORCE_DWORD;

pub const D2D1_SVG_VISIBILITY = enum(u32) {
    VISIBLE = 0,
    HIDDEN = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_VISIBILITY_VISIBLE = D2D1_SVG_VISIBILITY.VISIBLE;
pub const D2D1_SVG_VISIBILITY_HIDDEN = D2D1_SVG_VISIBILITY.HIDDEN;
pub const D2D1_SVG_VISIBILITY_FORCE_DWORD = D2D1_SVG_VISIBILITY.FORCE_DWORD;

pub const D2D1_SVG_OVERFLOW = enum(u32) {
    VISIBLE = 0,
    HIDDEN = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_OVERFLOW_VISIBLE = D2D1_SVG_OVERFLOW.VISIBLE;
pub const D2D1_SVG_OVERFLOW_HIDDEN = D2D1_SVG_OVERFLOW.HIDDEN;
pub const D2D1_SVG_OVERFLOW_FORCE_DWORD = D2D1_SVG_OVERFLOW.FORCE_DWORD;

pub const D2D1_SVG_LINE_CAP = enum(u32) {
    BUTT = 0,
    SQUARE = 1,
    ROUND = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_LINE_CAP_BUTT = D2D1_SVG_LINE_CAP.BUTT;
pub const D2D1_SVG_LINE_CAP_SQUARE = D2D1_SVG_LINE_CAP.SQUARE;
pub const D2D1_SVG_LINE_CAP_ROUND = D2D1_SVG_LINE_CAP.ROUND;
pub const D2D1_SVG_LINE_CAP_FORCE_DWORD = D2D1_SVG_LINE_CAP.FORCE_DWORD;

pub const D2D1_SVG_LINE_JOIN = enum(u32) {
    BEVEL = 1,
    MITER = 3,
    ROUND = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_LINE_JOIN_BEVEL = D2D1_SVG_LINE_JOIN.BEVEL;
pub const D2D1_SVG_LINE_JOIN_MITER = D2D1_SVG_LINE_JOIN.MITER;
pub const D2D1_SVG_LINE_JOIN_ROUND = D2D1_SVG_LINE_JOIN.ROUND;
pub const D2D1_SVG_LINE_JOIN_FORCE_DWORD = D2D1_SVG_LINE_JOIN.FORCE_DWORD;

pub const D2D1_SVG_ASPECT_ALIGN = enum(u32) {
    NONE = 0,
    X_MIN_Y_MIN = 1,
    X_MID_Y_MIN = 2,
    X_MAX_Y_MIN = 3,
    X_MIN_Y_MID = 4,
    X_MID_Y_MID = 5,
    X_MAX_Y_MID = 6,
    X_MIN_Y_MAX = 7,
    X_MID_Y_MAX = 8,
    X_MAX_Y_MAX = 9,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_ASPECT_ALIGN_NONE = D2D1_SVG_ASPECT_ALIGN.NONE;
pub const D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MIN = D2D1_SVG_ASPECT_ALIGN.X_MIN_Y_MIN;
pub const D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MIN = D2D1_SVG_ASPECT_ALIGN.X_MID_Y_MIN;
pub const D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MIN = D2D1_SVG_ASPECT_ALIGN.X_MAX_Y_MIN;
pub const D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MID = D2D1_SVG_ASPECT_ALIGN.X_MIN_Y_MID;
pub const D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MID = D2D1_SVG_ASPECT_ALIGN.X_MID_Y_MID;
pub const D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MID = D2D1_SVG_ASPECT_ALIGN.X_MAX_Y_MID;
pub const D2D1_SVG_ASPECT_ALIGN_X_MIN_Y_MAX = D2D1_SVG_ASPECT_ALIGN.X_MIN_Y_MAX;
pub const D2D1_SVG_ASPECT_ALIGN_X_MID_Y_MAX = D2D1_SVG_ASPECT_ALIGN.X_MID_Y_MAX;
pub const D2D1_SVG_ASPECT_ALIGN_X_MAX_Y_MAX = D2D1_SVG_ASPECT_ALIGN.X_MAX_Y_MAX;
pub const D2D1_SVG_ASPECT_ALIGN_FORCE_DWORD = D2D1_SVG_ASPECT_ALIGN.FORCE_DWORD;

pub const D2D1_SVG_ASPECT_SCALING = enum(u32) {
    MEET = 0,
    SLICE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_ASPECT_SCALING_MEET = D2D1_SVG_ASPECT_SCALING.MEET;
pub const D2D1_SVG_ASPECT_SCALING_SLICE = D2D1_SVG_ASPECT_SCALING.SLICE;
pub const D2D1_SVG_ASPECT_SCALING_FORCE_DWORD = D2D1_SVG_ASPECT_SCALING.FORCE_DWORD;

pub const D2D1_SVG_PATH_COMMAND = enum(u32) {
    CLOSE_PATH = 0,
    MOVE_ABSOLUTE = 1,
    MOVE_RELATIVE = 2,
    LINE_ABSOLUTE = 3,
    LINE_RELATIVE = 4,
    CUBIC_ABSOLUTE = 5,
    CUBIC_RELATIVE = 6,
    QUADRADIC_ABSOLUTE = 7,
    QUADRADIC_RELATIVE = 8,
    ARC_ABSOLUTE = 9,
    ARC_RELATIVE = 10,
    HORIZONTAL_ABSOLUTE = 11,
    HORIZONTAL_RELATIVE = 12,
    VERTICAL_ABSOLUTE = 13,
    VERTICAL_RELATIVE = 14,
    CUBIC_SMOOTH_ABSOLUTE = 15,
    CUBIC_SMOOTH_RELATIVE = 16,
    QUADRADIC_SMOOTH_ABSOLUTE = 17,
    QUADRADIC_SMOOTH_RELATIVE = 18,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_PATH_COMMAND_CLOSE_PATH = D2D1_SVG_PATH_COMMAND.CLOSE_PATH;
pub const D2D1_SVG_PATH_COMMAND_MOVE_ABSOLUTE = D2D1_SVG_PATH_COMMAND.MOVE_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_MOVE_RELATIVE = D2D1_SVG_PATH_COMMAND.MOVE_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_LINE_ABSOLUTE = D2D1_SVG_PATH_COMMAND.LINE_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_LINE_RELATIVE = D2D1_SVG_PATH_COMMAND.LINE_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_CUBIC_ABSOLUTE = D2D1_SVG_PATH_COMMAND.CUBIC_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_CUBIC_RELATIVE = D2D1_SVG_PATH_COMMAND.CUBIC_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_QUADRADIC_ABSOLUTE = D2D1_SVG_PATH_COMMAND.QUADRADIC_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_QUADRADIC_RELATIVE = D2D1_SVG_PATH_COMMAND.QUADRADIC_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_ARC_ABSOLUTE = D2D1_SVG_PATH_COMMAND.ARC_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_ARC_RELATIVE = D2D1_SVG_PATH_COMMAND.ARC_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_HORIZONTAL_ABSOLUTE = D2D1_SVG_PATH_COMMAND.HORIZONTAL_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_HORIZONTAL_RELATIVE = D2D1_SVG_PATH_COMMAND.HORIZONTAL_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_VERTICAL_ABSOLUTE = D2D1_SVG_PATH_COMMAND.VERTICAL_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_VERTICAL_RELATIVE = D2D1_SVG_PATH_COMMAND.VERTICAL_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_CUBIC_SMOOTH_ABSOLUTE = D2D1_SVG_PATH_COMMAND.CUBIC_SMOOTH_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_CUBIC_SMOOTH_RELATIVE = D2D1_SVG_PATH_COMMAND.CUBIC_SMOOTH_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_QUADRADIC_SMOOTH_ABSOLUTE = D2D1_SVG_PATH_COMMAND.QUADRADIC_SMOOTH_ABSOLUTE;
pub const D2D1_SVG_PATH_COMMAND_QUADRADIC_SMOOTH_RELATIVE = D2D1_SVG_PATH_COMMAND.QUADRADIC_SMOOTH_RELATIVE;
pub const D2D1_SVG_PATH_COMMAND_FORCE_DWORD = D2D1_SVG_PATH_COMMAND.FORCE_DWORD;

pub const D2D1_SVG_UNIT_TYPE = enum(u32) {
    USER_SPACE_ON_USE = 0,
    OBJECT_BOUNDING_BOX = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_UNIT_TYPE_USER_SPACE_ON_USE = D2D1_SVG_UNIT_TYPE.USER_SPACE_ON_USE;
pub const D2D1_SVG_UNIT_TYPE_OBJECT_BOUNDING_BOX = D2D1_SVG_UNIT_TYPE.OBJECT_BOUNDING_BOX;
pub const D2D1_SVG_UNIT_TYPE_FORCE_DWORD = D2D1_SVG_UNIT_TYPE.FORCE_DWORD;

pub const D2D1_SVG_ATTRIBUTE_STRING_TYPE = enum(u32) {
    SVG = 0,
    ID = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_ATTRIBUTE_STRING_TYPE_SVG = D2D1_SVG_ATTRIBUTE_STRING_TYPE.SVG;
pub const D2D1_SVG_ATTRIBUTE_STRING_TYPE_ID = D2D1_SVG_ATTRIBUTE_STRING_TYPE.ID;
pub const D2D1_SVG_ATTRIBUTE_STRING_TYPE_FORCE_DWORD = D2D1_SVG_ATTRIBUTE_STRING_TYPE.FORCE_DWORD;

pub const D2D1_SVG_ATTRIBUTE_POD_TYPE = enum(u32) {
    FLOAT = 0,
    COLOR = 1,
    FILL_MODE = 2,
    DISPLAY = 3,
    OVERFLOW = 4,
    LINE_CAP = 5,
    LINE_JOIN = 6,
    VISIBILITY = 7,
    MATRIX = 8,
    UNIT_TYPE = 9,
    EXTEND_MODE = 10,
    PRESERVE_ASPECT_RATIO = 11,
    VIEWBOX = 12,
    LENGTH = 13,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_FLOAT = D2D1_SVG_ATTRIBUTE_POD_TYPE.FLOAT;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_COLOR = D2D1_SVG_ATTRIBUTE_POD_TYPE.COLOR;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_FILL_MODE = D2D1_SVG_ATTRIBUTE_POD_TYPE.FILL_MODE;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_DISPLAY = D2D1_SVG_ATTRIBUTE_POD_TYPE.DISPLAY;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_OVERFLOW = D2D1_SVG_ATTRIBUTE_POD_TYPE.OVERFLOW;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_LINE_CAP = D2D1_SVG_ATTRIBUTE_POD_TYPE.LINE_CAP;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_LINE_JOIN = D2D1_SVG_ATTRIBUTE_POD_TYPE.LINE_JOIN;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_VISIBILITY = D2D1_SVG_ATTRIBUTE_POD_TYPE.VISIBILITY;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_MATRIX = D2D1_SVG_ATTRIBUTE_POD_TYPE.MATRIX;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_UNIT_TYPE = D2D1_SVG_ATTRIBUTE_POD_TYPE.UNIT_TYPE;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_EXTEND_MODE = D2D1_SVG_ATTRIBUTE_POD_TYPE.EXTEND_MODE;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_PRESERVE_ASPECT_RATIO = D2D1_SVG_ATTRIBUTE_POD_TYPE.PRESERVE_ASPECT_RATIO;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_VIEWBOX = D2D1_SVG_ATTRIBUTE_POD_TYPE.VIEWBOX;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_LENGTH = D2D1_SVG_ATTRIBUTE_POD_TYPE.LENGTH;
pub const D2D1_SVG_ATTRIBUTE_POD_TYPE_FORCE_DWORD = D2D1_SVG_ATTRIBUTE_POD_TYPE.FORCE_DWORD;

pub const D2D1_SVG_LENGTH = extern struct {
    value: f32,
    units: D2D1_SVG_LENGTH_UNITS,
};

pub const D2D1_SVG_PRESERVE_ASPECT_RATIO = extern struct {
    @"defer": BOOL,
    @"align": D2D1_SVG_ASPECT_ALIGN,
    meetOrSlice: D2D1_SVG_ASPECT_SCALING,
};

pub const D2D1_SVG_VIEWBOX = extern struct {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
};

const IID_ID2D1SvgAttribute_Value = Guid.initString("c9cdb0dd-f8c9-4e70-b7c2-301c80292c5e");
pub const IID_ID2D1SvgAttribute = &IID_ID2D1SvgAttribute_Value;
pub const ID2D1SvgAttribute = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgAttribute,
                element: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgAttribute,
                element: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgAttribute,
                attribute: ?*?*ID2D1SvgAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgAttribute,
                attribute: ?*?*ID2D1SvgAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgAttribute_GetElement(self: *const T, element: ?*?*ID2D1SvgElement) callconv(.Inline) void {
            return @as(*const ID2D1SvgAttribute.VTable, @ptrCast(self.vtable)).GetElement(@as(*const ID2D1SvgAttribute, @ptrCast(self)), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgAttribute_Clone(self: *const T, attribute: ?*?*ID2D1SvgAttribute) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgAttribute.VTable, @ptrCast(self.vtable)).Clone(@as(*const ID2D1SvgAttribute, @ptrCast(self)), attribute);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgPaint_Value = Guid.initString("d59bab0a-68a2-455b-a5dc-9eb2854e2490");
pub const IID_ID2D1SvgPaint = &IID_ID2D1SvgPaint_Value;
pub const ID2D1SvgPaint = extern struct {
    pub const VTable = extern struct {
        base: ID2D1SvgAttribute.VTable,
        SetPaintType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
                paintType: D2D1_SVG_PAINT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPaint,
                paintType: D2D1_SVG_PAINT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPaintType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_SVG_PAINT_TYPE,
            else => *const fn(
                self: *const ID2D1SvgPaint,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_SVG_PAINT_TYPE,
        },
        SetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
                color: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPaint,
                color: ?*const D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
                color: ?*D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgPaint,
                color: ?*D2D1_COLOR_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
                id: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPaint,
                id: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
                id: [*:0]u16,
                idCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPaint,
                id: [*:0]u16,
                idCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPaint,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgPaint,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1SvgAttribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_SetPaintType(self: *const T, paintType: D2D1_SVG_PAINT_TYPE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).SetPaintType(@as(*const ID2D1SvgPaint, @ptrCast(self)), paintType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_GetPaintType(self: *const T) callconv(.Inline) D2D1_SVG_PAINT_TYPE {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).GetPaintType(@as(*const ID2D1SvgPaint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_SetColor(self: *const T, color: ?*const D2D1_COLOR_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).SetColor(@as(*const ID2D1SvgPaint, @ptrCast(self)), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_GetColor(self: *const T, color: ?*D2D1_COLOR_F) callconv(.Inline) void {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).GetColor(@as(*const ID2D1SvgPaint, @ptrCast(self)), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_SetId(self: *const T, id: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).SetId(@as(*const ID2D1SvgPaint, @ptrCast(self)), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_GetId(self: *const T, id: [*:0]u16, idCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).GetId(@as(*const ID2D1SvgPaint, @ptrCast(self)), id, idCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPaint_GetIdLength(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgPaint.VTable, @ptrCast(self.vtable)).GetIdLength(@as(*const ID2D1SvgPaint, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgStrokeDashArray_Value = Guid.initString("f1c0ca52-92a3-4f00-b4ce-f35691efd9d9");
pub const IID_ID2D1SvgStrokeDashArray = &IID_ID2D1SvgStrokeDashArray_Value;
pub const ID2D1SvgStrokeDashArray = extern struct {
    pub const VTable = extern struct {
        base: ID2D1SvgAttribute.VTable,
        RemoveDashesAtEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateDashes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]const D2D1_SVG_LENGTH,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]const D2D1_SVG_LENGTH,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateDashes1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]const f32,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]const f32,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDashes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]D2D1_SVG_LENGTH,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]D2D1_SVG_LENGTH,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDashes1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]f32,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgStrokeDashArray,
                dashes: [*]f32,
                dashesCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDashesCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgStrokeDashArray,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgStrokeDashArray,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1SvgAttribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgStrokeDashArray_RemoveDashesAtEnd(self: *const T, dashesCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgStrokeDashArray.VTable, @ptrCast(self.vtable)).RemoveDashesAtEnd(@as(*const ID2D1SvgStrokeDashArray, @ptrCast(self)), dashesCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgStrokeDashArray_UpdateDashes(self: *const T, dashes: [*]const D2D1_SVG_LENGTH, dashesCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgStrokeDashArray.VTable, @ptrCast(self.vtable)).UpdateDashes(@as(*const ID2D1SvgStrokeDashArray, @ptrCast(self)), dashes, dashesCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgStrokeDashArray_UpdateDashes1(self: *const T, dashes: [*]const f32, dashesCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgStrokeDashArray.VTable, @ptrCast(self.vtable)).UpdateDashes(@as(*const ID2D1SvgStrokeDashArray, @ptrCast(self)), dashes, dashesCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgStrokeDashArray_GetDashes(self: *const T, dashes: [*]D2D1_SVG_LENGTH, dashesCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgStrokeDashArray.VTable, @ptrCast(self.vtable)).GetDashes(@as(*const ID2D1SvgStrokeDashArray, @ptrCast(self)), dashes, dashesCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgStrokeDashArray_GetDashes1(self: *const T, dashes: [*]f32, dashesCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgStrokeDashArray.VTable, @ptrCast(self.vtable)).GetDashes(@as(*const ID2D1SvgStrokeDashArray, @ptrCast(self)), dashes, dashesCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgStrokeDashArray_GetDashesCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgStrokeDashArray.VTable, @ptrCast(self.vtable)).GetDashesCount(@as(*const ID2D1SvgStrokeDashArray, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgPointCollection_Value = Guid.initString("9dbe4c0d-3572-4dd9-9825-5530813bb712");
pub const IID_ID2D1SvgPointCollection = &IID_ID2D1SvgPointCollection_Value;
pub const ID2D1SvgPointCollection = extern struct {
    pub const VTable = extern struct {
        base: ID2D1SvgAttribute.VTable,
        RemovePointsAtEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPointCollection,
                pointsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPointCollection,
                pointsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdatePoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPointCollection,
                points: [*]const D2D_POINT_2F,
                pointsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPointCollection,
                points: [*]const D2D_POINT_2F,
                pointsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPointCollection,
                points: [*]D2D_POINT_2F,
                pointsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPointCollection,
                points: [*]D2D_POINT_2F,
                pointsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPointsCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPointCollection,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgPointCollection,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1SvgAttribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPointCollection_RemovePointsAtEnd(self: *const T, pointsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPointCollection.VTable, @ptrCast(self.vtable)).RemovePointsAtEnd(@as(*const ID2D1SvgPointCollection, @ptrCast(self)), pointsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPointCollection_UpdatePoints(self: *const T, points: [*]const D2D_POINT_2F, pointsCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPointCollection.VTable, @ptrCast(self.vtable)).UpdatePoints(@as(*const ID2D1SvgPointCollection, @ptrCast(self)), points, pointsCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPointCollection_GetPoints(self: *const T, points: [*]D2D_POINT_2F, pointsCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPointCollection.VTable, @ptrCast(self.vtable)).GetPoints(@as(*const ID2D1SvgPointCollection, @ptrCast(self)), points, pointsCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPointCollection_GetPointsCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgPointCollection.VTable, @ptrCast(self.vtable)).GetPointsCount(@as(*const ID2D1SvgPointCollection, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgPathData_Value = Guid.initString("c095e4f4-bb98-43d6-9745-4d1b84ec9888");
pub const IID_ID2D1SvgPathData = &IID_ID2D1SvgPathData_Value;
pub const ID2D1SvgPathData = extern struct {
    pub const VTable = extern struct {
        base: ID2D1SvgAttribute.VTable,
        RemoveSegmentDataAtEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                dataCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                dataCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateSegmentData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                data: [*]const f32,
                dataCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                data: [*]const f32,
                dataCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSegmentData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                data: [*]f32,
                dataCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                data: [*]f32,
                dataCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSegmentDataCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgPathData,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        RemoveCommandsAtEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                commandsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                commandsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                commands: [*]const D2D1_SVG_PATH_COMMAND,
                commandsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                commands: [*]const D2D1_SVG_PATH_COMMAND,
                commandsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                commands: [*]D2D1_SVG_PATH_COMMAND,
                commandsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                commands: [*]D2D1_SVG_PATH_COMMAND,
                commandsCount: u32,
                startIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommandsCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgPathData,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        CreatePathGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgPathData,
                fillMode: D2D1_FILL_MODE,
                pathGeometry: ?*?*ID2D1PathGeometry1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgPathData,
                fillMode: D2D1_FILL_MODE,
                pathGeometry: ?*?*ID2D1PathGeometry1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1SvgAttribute.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_RemoveSegmentDataAtEnd(self: *const T, dataCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).RemoveSegmentDataAtEnd(@as(*const ID2D1SvgPathData, @ptrCast(self)), dataCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_UpdateSegmentData(self: *const T, data: [*]const f32, dataCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).UpdateSegmentData(@as(*const ID2D1SvgPathData, @ptrCast(self)), data, dataCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_GetSegmentData(self: *const T, data: [*]f32, dataCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).GetSegmentData(@as(*const ID2D1SvgPathData, @ptrCast(self)), data, dataCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_GetSegmentDataCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).GetSegmentDataCount(@as(*const ID2D1SvgPathData, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_RemoveCommandsAtEnd(self: *const T, commandsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).RemoveCommandsAtEnd(@as(*const ID2D1SvgPathData, @ptrCast(self)), commandsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_UpdateCommands(self: *const T, commands: [*]const D2D1_SVG_PATH_COMMAND, commandsCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).UpdateCommands(@as(*const ID2D1SvgPathData, @ptrCast(self)), commands, commandsCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_GetCommands(self: *const T, commands: [*]D2D1_SVG_PATH_COMMAND, commandsCount: u32, startIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).GetCommands(@as(*const ID2D1SvgPathData, @ptrCast(self)), commands, commandsCount, startIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_GetCommandsCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).GetCommandsCount(@as(*const ID2D1SvgPathData, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgPathData_CreatePathGeometry(self: *const T, fillMode: D2D1_FILL_MODE, pathGeometry: ?*?*ID2D1PathGeometry1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgPathData.VTable, @ptrCast(self.vtable)).CreatePathGeometry(@as(*const ID2D1SvgPathData, @ptrCast(self)), fillMode, pathGeometry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgElement_Value = Guid.initString("ac7b67a6-183e-49c1-a823-0ebe40b0db29");
pub const IID_ID2D1SvgElement = &IID_ID2D1SvgElement_Value;
pub const ID2D1SvgElement = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                document: ?*?*ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgElement,
                document: ?*?*ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetTagName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: [*:0]u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: [*:0]u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTagNameLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        IsTextContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                parent: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgElement,
                parent: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        HasChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetFirstChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                child: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgElement,
                child: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetLastChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                child: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgElement,
                child: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPreviousChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                referenceChild: ?*ID2D1SvgElement,
                previousChild: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                referenceChild: ?*ID2D1SvgElement,
                previousChild: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                referenceChild: ?*ID2D1SvgElement,
                nextChild: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                referenceChild: ?*ID2D1SvgElement,
                nextChild: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertChildBefore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                newChild: ?*ID2D1SvgElement,
                referenceChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                newChild: ?*ID2D1SvgElement,
                referenceChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                newChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                newChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplaceChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                newChild: ?*ID2D1SvgElement,
                oldChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                newChild: ?*ID2D1SvgElement,
                oldChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                oldChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                oldChild: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                tagName: ?[*:0]const u16,
                newChild: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                tagName: ?[*:0]const u16,
                newChild: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAttributeSpecified: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                inherited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                inherited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetSpecifiedAttributeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetSpecifiedAttributeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                index: u32,
                name: [*:0]u16,
                nameCount: u32,
                inherited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                index: u32,
                name: [*:0]u16,
                nameCount: u32,
                inherited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecifiedAttributeNameLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                index: u32,
                nameLength: ?*u32,
                inherited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                index: u32,
                nameLength: ?*u32,
                inherited: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: [*:0]const u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: [*:0]const u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: [*:0]u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: [*:0]u16,
                nameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextValueLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        SetAttributeValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                value: ?*ID2D1SvgAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                value: ?*ID2D1SvgAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttributeValue1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_POD_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                value: ?*const anyopaque,
                valueSizeInBytes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_POD_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                value: ?*const anyopaque,
                valueSizeInBytes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttributeValue2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_STRING_TYPE,
                value: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_STRING_TYPE,
                value: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                riid: ?*const Guid,
                value: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                riid: ?*const Guid,
                value: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValue1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_POD_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                value: ?*anyopaque,
                valueSizeInBytes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_POD_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                value: ?*anyopaque,
                valueSizeInBytes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValue2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_STRING_TYPE,
                value: [*:0]u16,
                valueCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_STRING_TYPE,
                value: [*:0]u16,
                valueCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeValueLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_STRING_TYPE,
                valueLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgElement,
                name: ?[*:0]const u16,
                type: D2D1_SVG_ATTRIBUTE_STRING_TYPE,
                valueLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetDocument(self: *const T, document: ?*?*ID2D1SvgDocument) callconv(.Inline) void {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const ID2D1SvgElement, @ptrCast(self)), document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetTagName(self: *const T, name: [*:0]u16, nameCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetTagName(@as(*const ID2D1SvgElement, @ptrCast(self)), name, nameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetTagNameLength(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetTagNameLength(@as(*const ID2D1SvgElement, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_IsTextContent(self: *const T) callconv(.Inline) BOOL {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).IsTextContent(@as(*const ID2D1SvgElement, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetParent(self: *const T, parent: ?*?*ID2D1SvgElement) callconv(.Inline) void {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetParent(@as(*const ID2D1SvgElement, @ptrCast(self)), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_HasChildren(self: *const T) callconv(.Inline) BOOL {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).HasChildren(@as(*const ID2D1SvgElement, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetFirstChild(self: *const T, child: ?*?*ID2D1SvgElement) callconv(.Inline) void {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetFirstChild(@as(*const ID2D1SvgElement, @ptrCast(self)), child);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetLastChild(self: *const T, child: ?*?*ID2D1SvgElement) callconv(.Inline) void {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetLastChild(@as(*const ID2D1SvgElement, @ptrCast(self)), child);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetPreviousChild(self: *const T, referenceChild: ?*ID2D1SvgElement, previousChild: ?*?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetPreviousChild(@as(*const ID2D1SvgElement, @ptrCast(self)), referenceChild, previousChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetNextChild(self: *const T, referenceChild: ?*ID2D1SvgElement, nextChild: ?*?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetNextChild(@as(*const ID2D1SvgElement, @ptrCast(self)), referenceChild, nextChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_InsertChildBefore(self: *const T, newChild: ?*ID2D1SvgElement, referenceChild: ?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).InsertChildBefore(@as(*const ID2D1SvgElement, @ptrCast(self)), newChild, referenceChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_AppendChild(self: *const T, newChild: ?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).AppendChild(@as(*const ID2D1SvgElement, @ptrCast(self)), newChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_ReplaceChild(self: *const T, newChild: ?*ID2D1SvgElement, oldChild: ?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).ReplaceChild(@as(*const ID2D1SvgElement, @ptrCast(self)), newChild, oldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_RemoveChild(self: *const T, oldChild: ?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).RemoveChild(@as(*const ID2D1SvgElement, @ptrCast(self)), oldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_CreateChild(self: *const T, tagName: ?[*:0]const u16, newChild: ?*?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).CreateChild(@as(*const ID2D1SvgElement, @ptrCast(self)), tagName, newChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_IsAttributeSpecified(self: *const T, name: ?[*:0]const u16, inherited: ?*BOOL) callconv(.Inline) BOOL {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).IsAttributeSpecified(@as(*const ID2D1SvgElement, @ptrCast(self)), name, inherited);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetSpecifiedAttributeCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetSpecifiedAttributeCount(@as(*const ID2D1SvgElement, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetSpecifiedAttributeName(self: *const T, index: u32, name: [*:0]u16, nameCount: u32, inherited: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetSpecifiedAttributeName(@as(*const ID2D1SvgElement, @ptrCast(self)), index, name, nameCount, inherited);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetSpecifiedAttributeNameLength(self: *const T, index: u32, nameLength: ?*u32, inherited: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetSpecifiedAttributeNameLength(@as(*const ID2D1SvgElement, @ptrCast(self)), index, nameLength, inherited);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_RemoveAttribute(self: *const T, name: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).RemoveAttribute(@as(*const ID2D1SvgElement, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_SetTextValue(self: *const T, name: [*:0]const u16, nameCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).SetTextValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, nameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetTextValue(self: *const T, name: [*:0]u16, nameCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetTextValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, nameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetTextValueLength(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetTextValueLength(@as(*const ID2D1SvgElement, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_SetAttributeValue(self: *const T, name: ?[*:0]const u16, value: ?*ID2D1SvgAttribute) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).SetAttributeValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_SetAttributeValue1(self: *const T, name: ?[*:0]const u16, type_: D2D1_SVG_ATTRIBUTE_POD_TYPE, value: ?*const anyopaque, valueSizeInBytes: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).SetAttributeValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, type_, value, valueSizeInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_SetAttributeValue2(self: *const T, name: ?[*:0]const u16, type_: D2D1_SVG_ATTRIBUTE_STRING_TYPE, value: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).SetAttributeValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, type_, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetAttributeValue(self: *const T, name: ?[*:0]const u16, riid: ?*const Guid, value: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetAttributeValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, riid, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetAttributeValue1(self: *const T, name: ?[*:0]const u16, type_: D2D1_SVG_ATTRIBUTE_POD_TYPE, value: ?*anyopaque, valueSizeInBytes: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetAttributeValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, type_, value, valueSizeInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetAttributeValue2(self: *const T, name: ?[*:0]const u16, type_: D2D1_SVG_ATTRIBUTE_STRING_TYPE, value: [*:0]u16, valueCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetAttributeValue(@as(*const ID2D1SvgElement, @ptrCast(self)), name, type_, value, valueCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgElement_GetAttributeValueLength(self: *const T, name: ?[*:0]const u16, type_: D2D1_SVG_ATTRIBUTE_STRING_TYPE, valueLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgElement.VTable, @ptrCast(self.vtable)).GetAttributeValueLength(@as(*const ID2D1SvgElement, @ptrCast(self)), name, type_, valueLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgDocument_Value = Guid.initString("86b88e4d-afa4-4d7b-88e4-68a51c4a0aec");
pub const IID_ID2D1SvgDocument = &IID_ID2D1SvgDocument_Value;
pub const ID2D1SvgDocument = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        SetViewportSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                viewportSize: D2D_SIZE_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                viewportSize: D2D_SIZE_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewportSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
            else => *const fn(
                self: *const ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) D2D_SIZE_F,
        },
        SetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                root: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                root: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                root: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                root: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FindElementById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                id: ?[*:0]const u16,
                svgElement: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                id: ?[*:0]const u16,
                svgElement: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                outputXmlStream: ?*IStream,
                subtree: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                outputXmlStream: ?*IStream,
                subtree: ?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deserialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                inputXmlStream: ?*IStream,
                subtree: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                inputXmlStream: ?*IStream,
                subtree: ?*?*ID2D1SvgElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                paintType: D2D1_SVG_PAINT_TYPE,
                color: ?*const D2D1_COLOR_F,
                id: ?[*:0]const u16,
                paint: ?*?*ID2D1SvgPaint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                paintType: D2D1_SVG_PAINT_TYPE,
                color: ?*const D2D1_COLOR_F,
                id: ?[*:0]const u16,
                paint: ?*?*ID2D1SvgPaint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStrokeDashArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                dashes: ?[*]const D2D1_SVG_LENGTH,
                dashesCount: u32,
                strokeDashArray: ?*?*ID2D1SvgStrokeDashArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                dashes: ?[*]const D2D1_SVG_LENGTH,
                dashesCount: u32,
                strokeDashArray: ?*?*ID2D1SvgStrokeDashArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePointCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                points: ?[*]const D2D_POINT_2F,
                pointsCount: u32,
                pointCollection: ?*?*ID2D1SvgPointCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                points: ?[*]const D2D_POINT_2F,
                pointsCount: u32,
                pointCollection: ?*?*ID2D1SvgPointCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePathData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgDocument,
                segmentData: ?[*]const f32,
                segmentDataCount: u32,
                commands: ?[*]const D2D1_SVG_PATH_COMMAND,
                commandsCount: u32,
                pathData: ?*?*ID2D1SvgPathData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgDocument,
                segmentData: ?[*]const f32,
                segmentDataCount: u32,
                commands: ?[*]const D2D1_SVG_PATH_COMMAND,
                commandsCount: u32,
                pathData: ?*?*ID2D1SvgPathData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_SetViewportSize(self: *const T, viewportSize: D2D_SIZE_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).SetViewportSize(@as(*const ID2D1SvgDocument, @ptrCast(self)), viewportSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_GetViewportSize(self: *const T) callconv(.Inline) D2D_SIZE_F {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).GetViewportSize(@as(*const ID2D1SvgDocument, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_SetRoot(self: *const T, root: ?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).SetRoot(@as(*const ID2D1SvgDocument, @ptrCast(self)), root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_GetRoot(self: *const T, root: ?*?*ID2D1SvgElement) callconv(.Inline) void {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).GetRoot(@as(*const ID2D1SvgDocument, @ptrCast(self)), root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_FindElementById(self: *const T, id: ?[*:0]const u16, svgElement: ?*?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).FindElementById(@as(*const ID2D1SvgDocument, @ptrCast(self)), id, svgElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_Serialize(self: *const T, outputXmlStream: ?*IStream, subtree: ?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).Serialize(@as(*const ID2D1SvgDocument, @ptrCast(self)), outputXmlStream, subtree);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_Deserialize(self: *const T, inputXmlStream: ?*IStream, subtree: ?*?*ID2D1SvgElement) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).Deserialize(@as(*const ID2D1SvgDocument, @ptrCast(self)), inputXmlStream, subtree);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_CreatePaint(self: *const T, paintType: D2D1_SVG_PAINT_TYPE, color: ?*const D2D1_COLOR_F, id: ?[*:0]const u16, paint: ?*?*ID2D1SvgPaint) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).CreatePaint(@as(*const ID2D1SvgDocument, @ptrCast(self)), paintType, color, id, paint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_CreateStrokeDashArray(self: *const T, dashes: ?[*]const D2D1_SVG_LENGTH, dashesCount: u32, strokeDashArray: ?*?*ID2D1SvgStrokeDashArray) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).CreateStrokeDashArray(@as(*const ID2D1SvgDocument, @ptrCast(self)), dashes, dashesCount, strokeDashArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_CreatePointCollection(self: *const T, points: ?[*]const D2D_POINT_2F, pointsCount: u32, pointCollection: ?*?*ID2D1SvgPointCollection) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).CreatePointCollection(@as(*const ID2D1SvgDocument, @ptrCast(self)), points, pointsCount, pointCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgDocument_CreatePathData(self: *const T, segmentData: ?[*]const f32, segmentDataCount: u32, commands: ?[*]const D2D1_SVG_PATH_COMMAND, commandsCount: u32, pathData: ?*?*ID2D1SvgPathData) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgDocument.VTable, @ptrCast(self.vtable)).CreatePathData(@as(*const ID2D1SvgDocument, @ptrCast(self)), segmentData, segmentDataCount, commands, commandsCount, pathData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D2D1_INK_NIB_SHAPE = enum(u32) {
    ROUND = 0,
    SQUARE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_INK_NIB_SHAPE_ROUND = D2D1_INK_NIB_SHAPE.ROUND;
pub const D2D1_INK_NIB_SHAPE_SQUARE = D2D1_INK_NIB_SHAPE.SQUARE;
pub const D2D1_INK_NIB_SHAPE_FORCE_DWORD = D2D1_INK_NIB_SHAPE.FORCE_DWORD;

pub const D2D1_ORIENTATION = enum(u32) {
    DEFAULT = 1,
    FLIP_HORIZONTAL = 2,
    ROTATE_CLOCKWISE180 = 3,
    ROTATE_CLOCKWISE180_FLIP_HORIZONTAL = 4,
    ROTATE_CLOCKWISE90_FLIP_HORIZONTAL = 5,
    ROTATE_CLOCKWISE270 = 6,
    ROTATE_CLOCKWISE270_FLIP_HORIZONTAL = 7,
    ROTATE_CLOCKWISE90 = 8,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_ORIENTATION_DEFAULT = D2D1_ORIENTATION.DEFAULT;
pub const D2D1_ORIENTATION_FLIP_HORIZONTAL = D2D1_ORIENTATION.FLIP_HORIZONTAL;
pub const D2D1_ORIENTATION_ROTATE_CLOCKWISE180 = D2D1_ORIENTATION.ROTATE_CLOCKWISE180;
pub const D2D1_ORIENTATION_ROTATE_CLOCKWISE180_FLIP_HORIZONTAL = D2D1_ORIENTATION.ROTATE_CLOCKWISE180_FLIP_HORIZONTAL;
pub const D2D1_ORIENTATION_ROTATE_CLOCKWISE90_FLIP_HORIZONTAL = D2D1_ORIENTATION.ROTATE_CLOCKWISE90_FLIP_HORIZONTAL;
pub const D2D1_ORIENTATION_ROTATE_CLOCKWISE270 = D2D1_ORIENTATION.ROTATE_CLOCKWISE270;
pub const D2D1_ORIENTATION_ROTATE_CLOCKWISE270_FLIP_HORIZONTAL = D2D1_ORIENTATION.ROTATE_CLOCKWISE270_FLIP_HORIZONTAL;
pub const D2D1_ORIENTATION_ROTATE_CLOCKWISE90 = D2D1_ORIENTATION.ROTATE_CLOCKWISE90;
pub const D2D1_ORIENTATION_FORCE_DWORD = D2D1_ORIENTATION.FORCE_DWORD;

pub const D2D1_IMAGE_SOURCE_LOADING_OPTIONS = enum(u32) {
    NONE = 0,
    RELEASE_SOURCE = 1,
    CACHE_ON_DEMAND = 2,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        RELEASE_SOURCE: u1 = 0,
        CACHE_ON_DEMAND: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_IMAGE_SOURCE_LOADING_OPTIONS {
        return @as(D2D1_IMAGE_SOURCE_LOADING_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_IMAGE_SOURCE_LOADING_OPTIONS.NONE) else 0)
            | (if (o.RELEASE_SOURCE == 1) @intFromEnum(D2D1_IMAGE_SOURCE_LOADING_OPTIONS.RELEASE_SOURCE) else 0)
            | (if (o.CACHE_ON_DEMAND == 1) @intFromEnum(D2D1_IMAGE_SOURCE_LOADING_OPTIONS.CACHE_ON_DEMAND) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_IMAGE_SOURCE_LOADING_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE = D2D1_IMAGE_SOURCE_LOADING_OPTIONS.NONE;
pub const D2D1_IMAGE_SOURCE_LOADING_OPTIONS_RELEASE_SOURCE = D2D1_IMAGE_SOURCE_LOADING_OPTIONS.RELEASE_SOURCE;
pub const D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND = D2D1_IMAGE_SOURCE_LOADING_OPTIONS.CACHE_ON_DEMAND;
pub const D2D1_IMAGE_SOURCE_LOADING_OPTIONS_FORCE_DWORD = D2D1_IMAGE_SOURCE_LOADING_OPTIONS.FORCE_DWORD;

pub const D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS = enum(u32) {
    NONE = 0,
    LOW_QUALITY_PRIMARY_CONVERSION = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        LOW_QUALITY_PRIMARY_CONVERSION: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS {
        return @as(D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS.NONE) else 0)
            | (if (o.LOW_QUALITY_PRIMARY_CONVERSION == 1) @intFromEnum(D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS.LOW_QUALITY_PRIMARY_CONVERSION) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_NONE = D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS.NONE;
pub const D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_LOW_QUALITY_PRIMARY_CONVERSION = D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS.LOW_QUALITY_PRIMARY_CONVERSION;
pub const D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS_FORCE_DWORD = D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS.FORCE_DWORD;

pub const D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS = enum(u32) {
    NONE = 0,
    DISABLE_DPI_SCALE = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DISABLE_DPI_SCALE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS {
        return @as(D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS.NONE) else 0)
            | (if (o.DISABLE_DPI_SCALE == 1) @intFromEnum(D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS.DISABLE_DPI_SCALE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_NONE = D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS.NONE;
pub const D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_DISABLE_DPI_SCALE = D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS.DISABLE_DPI_SCALE;
pub const D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS_FORCE_DWORD = D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS.FORCE_DWORD;

pub const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES = extern struct {
    orientation: D2D1_ORIENTATION,
    scaleX: f32,
    scaleY: f32,
    interpolationMode: D2D1_INTERPOLATION_MODE,
    options: D2D1_TRANSFORMED_IMAGE_SOURCE_OPTIONS,
};

pub const D2D1_INK_POINT = extern struct {
    x: f32,
    y: f32,
    radius: f32,
};

pub const D2D1_INK_BEZIER_SEGMENT = extern struct {
    point1: D2D1_INK_POINT,
    point2: D2D1_INK_POINT,
    point3: D2D1_INK_POINT,
};

pub const D2D1_INK_STYLE_PROPERTIES = extern struct {
    nibShape: D2D1_INK_NIB_SHAPE,
    nibTransform: D2D_MATRIX_3X2_F,
};

pub const D2D1_PATCH_EDGE_MODE = enum(u32) {
    ALIASED = 0,
    ANTIALIASED = 1,
    ALIASED_INFLATED = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_PATCH_EDGE_MODE_ALIASED = D2D1_PATCH_EDGE_MODE.ALIASED;
pub const D2D1_PATCH_EDGE_MODE_ANTIALIASED = D2D1_PATCH_EDGE_MODE.ANTIALIASED;
pub const D2D1_PATCH_EDGE_MODE_ALIASED_INFLATED = D2D1_PATCH_EDGE_MODE.ALIASED_INFLATED;
pub const D2D1_PATCH_EDGE_MODE_FORCE_DWORD = D2D1_PATCH_EDGE_MODE.FORCE_DWORD;

pub const D2D1_GRADIENT_MESH_PATCH = extern struct {
    point00: D2D_POINT_2F,
    point01: D2D_POINT_2F,
    point02: D2D_POINT_2F,
    point03: D2D_POINT_2F,
    point10: D2D_POINT_2F,
    point11: D2D_POINT_2F,
    point12: D2D_POINT_2F,
    point13: D2D_POINT_2F,
    point20: D2D_POINT_2F,
    point21: D2D_POINT_2F,
    point22: D2D_POINT_2F,
    point23: D2D_POINT_2F,
    point30: D2D_POINT_2F,
    point31: D2D_POINT_2F,
    point32: D2D_POINT_2F,
    point33: D2D_POINT_2F,
    color00: D2D1_COLOR_F,
    color03: D2D1_COLOR_F,
    color30: D2D1_COLOR_F,
    color33: D2D1_COLOR_F,
    topEdgeMode: D2D1_PATCH_EDGE_MODE,
    leftEdgeMode: D2D1_PATCH_EDGE_MODE,
    bottomEdgeMode: D2D1_PATCH_EDGE_MODE,
    rightEdgeMode: D2D1_PATCH_EDGE_MODE,
};

pub const D2D1_SPRITE_OPTIONS = enum(u32) {
    NONE = 0,
    CLAMP_TO_SOURCE_RECTANGLE = 1,
    FORCE_DWORD = 4294967295,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CLAMP_TO_SOURCE_RECTANGLE: u1 = 0,
        FORCE_DWORD: u1 = 0,
    }) D2D1_SPRITE_OPTIONS {
        return @as(D2D1_SPRITE_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(D2D1_SPRITE_OPTIONS.NONE) else 0)
            | (if (o.CLAMP_TO_SOURCE_RECTANGLE == 1) @intFromEnum(D2D1_SPRITE_OPTIONS.CLAMP_TO_SOURCE_RECTANGLE) else 0)
            | (if (o.FORCE_DWORD == 1) @intFromEnum(D2D1_SPRITE_OPTIONS.FORCE_DWORD) else 0)
        ));
    }
};
pub const D2D1_SPRITE_OPTIONS_NONE = D2D1_SPRITE_OPTIONS.NONE;
pub const D2D1_SPRITE_OPTIONS_CLAMP_TO_SOURCE_RECTANGLE = D2D1_SPRITE_OPTIONS.CLAMP_TO_SOURCE_RECTANGLE;
pub const D2D1_SPRITE_OPTIONS_FORCE_DWORD = D2D1_SPRITE_OPTIONS.FORCE_DWORD;

pub const D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION = enum(u32) {
    DEFAULT = 0,
    DISABLE = 1,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DEFAULT = D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION.DEFAULT;
pub const D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_DISABLE = D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION.DISABLE;
pub const D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION_FORCE_DWORD = D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION.FORCE_DWORD;

pub const D2D1_GAMMA1 = enum(u32) {
    G22 = 0,
    G10 = 1,
    G2084 = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_GAMMA1_G22 = D2D1_GAMMA1.G22;
pub const D2D1_GAMMA1_G10 = D2D1_GAMMA1.G10;
pub const D2D1_GAMMA1_G2084 = D2D1_GAMMA1.G2084;
pub const D2D1_GAMMA1_FORCE_DWORD = D2D1_GAMMA1.FORCE_DWORD;

pub const D2D1_SIMPLE_COLOR_PROFILE = extern struct {
    redPrimary: D2D_POINT_2F,
    greenPrimary: D2D_POINT_2F,
    bluePrimary: D2D_POINT_2F,
    whitePointXZ: D2D_POINT_2F,
    gamma: D2D1_GAMMA1,
};

pub const D2D1_COLOR_CONTEXT_TYPE = enum(u32) {
    ICC = 0,
    SIMPLE = 1,
    DXGI = 2,
    FORCE_DWORD = 4294967295,
};
pub const D2D1_COLOR_CONTEXT_TYPE_ICC = D2D1_COLOR_CONTEXT_TYPE.ICC;
pub const D2D1_COLOR_CONTEXT_TYPE_SIMPLE = D2D1_COLOR_CONTEXT_TYPE.SIMPLE;
pub const D2D1_COLOR_CONTEXT_TYPE_DXGI = D2D1_COLOR_CONTEXT_TYPE.DXGI;
pub const D2D1_COLOR_CONTEXT_TYPE_FORCE_DWORD = D2D1_COLOR_CONTEXT_TYPE.FORCE_DWORD;

const IID_ID2D1InkStyle_Value = Guid.initString("bae8b344-23fc-4071-8cb5-d05d6f073848");
pub const IID_ID2D1InkStyle = &IID_ID2D1InkStyle_Value;
pub const ID2D1InkStyle = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        SetNibTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1InkStyle,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1InkStyle,
                transform: ?*const D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetNibTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1InkStyle,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1InkStyle,
                transform: ?*D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetNibShape: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1InkStyle,
                nibShape: D2D1_INK_NIB_SHAPE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1InkStyle,
                nibShape: D2D1_INK_NIB_SHAPE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetNibShape: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INK_NIB_SHAPE,
            else => *const fn(
                self: *const ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INK_NIB_SHAPE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1InkStyle_SetNibTransform(self: *const T, transform: ?*const D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1InkStyle.VTable, @ptrCast(self.vtable)).SetNibTransform(@as(*const ID2D1InkStyle, @ptrCast(self)), transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1InkStyle_GetNibTransform(self: *const T, transform: ?*D2D_MATRIX_3X2_F) callconv(.Inline) void {
            return @as(*const ID2D1InkStyle.VTable, @ptrCast(self.vtable)).GetNibTransform(@as(*const ID2D1InkStyle, @ptrCast(self)), transform);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1InkStyle_SetNibShape(self: *const T, nibShape: D2D1_INK_NIB_SHAPE) callconv(.Inline) void {
            return @as(*const ID2D1InkStyle.VTable, @ptrCast(self.vtable)).SetNibShape(@as(*const ID2D1InkStyle, @ptrCast(self)), nibShape);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1InkStyle_GetNibShape(self: *const T) callconv(.Inline) D2D1_INK_NIB_SHAPE {
            return @as(*const ID2D1InkStyle.VTable, @ptrCast(self.vtable)).GetNibShape(@as(*const ID2D1InkStyle, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Ink_Value = Guid.initString("b499923b-7029-478f-a8b3-432c7c5f5312");
pub const IID_ID2D1Ink = &IID_ID2D1Ink_Value;
pub const ID2D1Ink = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        SetStartPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                startPoint: ?*const D2D1_INK_POINT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Ink,
                startPoint: ?*const D2D1_INK_POINT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetStartPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INK_POINT,
            else => *const fn(
                self: *const ID2D1Ink,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_INK_POINT,
        },
        AddSegments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                segments: [*]const D2D1_INK_BEZIER_SEGMENT,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                segments: [*]const D2D1_INK_BEZIER_SEGMENT,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSegmentsAtEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSegments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                startSegment: u32,
                segments: [*]const D2D1_INK_BEZIER_SEGMENT,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                startSegment: u32,
                segments: [*]const D2D1_INK_BEZIER_SEGMENT,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSegmentAtEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                segment: ?*const D2D1_INK_BEZIER_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                segment: ?*const D2D1_INK_BEZIER_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSegmentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1Ink,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetSegments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                startSegment: u32,
                segments: [*]D2D1_INK_BEZIER_SEGMENT,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                startSegment: u32,
                segments: [*]D2D1_INK_BEZIER_SEGMENT,
                segmentsCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StreamAsGeometry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                inkStyle: ?*ID2D1InkStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                inkStyle: ?*ID2D1InkStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                flatteningTolerance: f32,
                geometrySink: ?*ID2D1SimplifiedGeometrySink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Ink,
                inkStyle: ?*ID2D1InkStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Ink,
                inkStyle: ?*ID2D1InkStyle,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_SetStartPoint(self: *const T, startPoint: ?*const D2D1_INK_POINT) callconv(.Inline) void {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).SetStartPoint(@as(*const ID2D1Ink, @ptrCast(self)), startPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_GetStartPoint(self: *const T) callconv(.Inline) D2D1_INK_POINT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).GetStartPoint(@as(*const ID2D1Ink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_AddSegments(self: *const T, segments: [*]const D2D1_INK_BEZIER_SEGMENT, segmentsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).AddSegments(@as(*const ID2D1Ink, @ptrCast(self)), segments, segmentsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_RemoveSegmentsAtEnd(self: *const T, segmentsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).RemoveSegmentsAtEnd(@as(*const ID2D1Ink, @ptrCast(self)), segmentsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_SetSegments(self: *const T, startSegment: u32, segments: [*]const D2D1_INK_BEZIER_SEGMENT, segmentsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).SetSegments(@as(*const ID2D1Ink, @ptrCast(self)), startSegment, segments, segmentsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_SetSegmentAtEnd(self: *const T, segment: ?*const D2D1_INK_BEZIER_SEGMENT) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).SetSegmentAtEnd(@as(*const ID2D1Ink, @ptrCast(self)), segment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_GetSegmentCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).GetSegmentCount(@as(*const ID2D1Ink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_GetSegments(self: *const T, startSegment: u32, segments: [*]D2D1_INK_BEZIER_SEGMENT, segmentsCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).GetSegments(@as(*const ID2D1Ink, @ptrCast(self)), startSegment, segments, segmentsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_StreamAsGeometry(self: *const T, inkStyle: ?*ID2D1InkStyle, worldTransform: ?*const D2D_MATRIX_3X2_F, flatteningTolerance: f32, geometrySink: ?*ID2D1SimplifiedGeometrySink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).StreamAsGeometry(@as(*const ID2D1Ink, @ptrCast(self)), inkStyle, worldTransform, flatteningTolerance, geometrySink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Ink_GetBounds(self: *const T, inkStyle: ?*ID2D1InkStyle, worldTransform: ?*const D2D_MATRIX_3X2_F, bounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Ink.VTable, @ptrCast(self.vtable)).GetBounds(@as(*const ID2D1Ink, @ptrCast(self)), inkStyle, worldTransform, bounds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1GradientMesh_Value = Guid.initString("f292e401-c050-4cde-83d7-04962d3b23c2");
pub const IID_ID2D1GradientMesh = &IID_ID2D1GradientMesh_Value;
pub const ID2D1GradientMesh = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        GetPatchCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetPatches: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GradientMesh,
                startIndex: u32,
                patches: [*]D2D1_GRADIENT_MESH_PATCH,
                patchesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GradientMesh,
                startIndex: u32,
                patches: [*]D2D1_GRADIENT_MESH_PATCH,
                patchesCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientMesh_GetPatchCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1GradientMesh.VTable, @ptrCast(self.vtable)).GetPatchCount(@as(*const ID2D1GradientMesh, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GradientMesh_GetPatches(self: *const T, startIndex: u32, patches: [*]D2D1_GRADIENT_MESH_PATCH, patchesCount: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GradientMesh.VTable, @ptrCast(self.vtable)).GetPatches(@as(*const ID2D1GradientMesh, @ptrCast(self)), startIndex, patches, patchesCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_ID2D1ImageSource_Value = Guid.initString("c9b664e5-74a1-4378-9ac2-eefc37a3f4d8");
pub const IID_ID2D1ImageSource = &IID_ID2D1ImageSource_Value;
pub const ID2D1ImageSource = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Image.VTable,
        OfferResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ImageSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TryReclaimResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageSource,
                resourcesDiscarded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ImageSource,
                resourcesDiscarded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Image.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageSource_OfferResources(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ImageSource.VTable, @ptrCast(self.vtable)).OfferResources(@as(*const ID2D1ImageSource, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageSource_TryReclaimResources(self: *const T, resourcesDiscarded: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ImageSource.VTable, @ptrCast(self.vtable)).TryReclaimResources(@as(*const ID2D1ImageSource, @ptrCast(self)), resourcesDiscarded);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1ImageSourceFromWic_Value = Guid.initString("77395441-1c8f-4555-8683-f50dab0fe792");
pub const IID_ID2D1ImageSourceFromWic = &IID_ID2D1ImageSourceFromWic_Value;
pub const ID2D1ImageSourceFromWic = extern struct {
    pub const VTable = extern struct {
        base: ID2D1ImageSource.VTable,
        EnsureCached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageSourceFromWic,
                rectangleToFill: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ImageSourceFromWic,
                rectangleToFill: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TrimCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageSourceFromWic,
                rectangleToPreserve: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ImageSourceFromWic,
                rectangleToPreserve: ?*const D2D_RECT_U,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ImageSourceFromWic,
                wicBitmapSource: ?*?*IWICBitmapSource,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1ImageSourceFromWic,
                wicBitmapSource: ?*?*IWICBitmapSource,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1ImageSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageSourceFromWic_EnsureCached(self: *const T, rectangleToFill: ?*const D2D_RECT_U) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ImageSourceFromWic.VTable, @ptrCast(self.vtable)).EnsureCached(@as(*const ID2D1ImageSourceFromWic, @ptrCast(self)), rectangleToFill);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageSourceFromWic_TrimCache(self: *const T, rectangleToPreserve: ?*const D2D_RECT_U) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ImageSourceFromWic.VTable, @ptrCast(self.vtable)).TrimCache(@as(*const ID2D1ImageSourceFromWic, @ptrCast(self)), rectangleToPreserve);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ImageSourceFromWic_GetSource(self: *const T, wicBitmapSource: ?*?*IWICBitmapSource) callconv(.Inline) void {
            return @as(*const ID2D1ImageSourceFromWic.VTable, @ptrCast(self.vtable)).GetSource(@as(*const ID2D1ImageSourceFromWic, @ptrCast(self)), wicBitmapSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1TransformedImageSource_Value = Guid.initString("7f1f79e5-2796-416c-8f55-700f911445e5");
pub const IID_ID2D1TransformedImageSource = &IID_ID2D1TransformedImageSource_Value;
pub const ID2D1TransformedImageSource = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Image.VTable,
        GetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformedImageSource,
                imageSource: ?*?*ID2D1ImageSource,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1TransformedImageSource,
                imageSource: ?*?*ID2D1ImageSource,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1TransformedImageSource,
                properties: ?*D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1TransformedImageSource,
                properties: ?*D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Image.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformedImageSource_GetSource(self: *const T, imageSource: ?*?*ID2D1ImageSource) callconv(.Inline) void {
            return @as(*const ID2D1TransformedImageSource.VTable, @ptrCast(self.vtable)).GetSource(@as(*const ID2D1TransformedImageSource, @ptrCast(self)), imageSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1TransformedImageSource_GetProperties(self: *const T, properties: ?*D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES) callconv(.Inline) void {
            return @as(*const ID2D1TransformedImageSource.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const ID2D1TransformedImageSource, @ptrCast(self)), properties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1LookupTable3D_Value = Guid.initString("53dd9855-a3b0-4d5b-82e1-26e25c5e5797");
pub const IID_ID2D1LookupTable3D = &IID_ID2D1LookupTable3D_Value;
pub const ID2D1LookupTable3D = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_ID2D1DeviceContext2_Value = Guid.initString("394ea6a3-0c34-4321-950b-6ca20f0be6c7");
pub const IID_ID2D1DeviceContext2 = &IID_ID2D1DeviceContext2_Value;
pub const ID2D1DeviceContext2 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DeviceContext1.VTable,
        CreateInk: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                startPoint: ?*const D2D1_INK_POINT,
                ink: ?*?*ID2D1Ink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                startPoint: ?*const D2D1_INK_POINT,
                ink: ?*?*ID2D1Ink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInkStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                inkStyleProperties: ?*const D2D1_INK_STYLE_PROPERTIES,
                inkStyle: ?*?*ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                inkStyleProperties: ?*const D2D1_INK_STYLE_PROPERTIES,
                inkStyle: ?*?*ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateGradientMesh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                patches: [*]const D2D1_GRADIENT_MESH_PATCH,
                patchesCount: u32,
                gradientMesh: ?*?*ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                patches: [*]const D2D1_GRADIENT_MESH_PATCH,
                patchesCount: u32,
                gradientMesh: ?*?*ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateImageSourceFromWic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                wicBitmapSource: ?*IWICBitmapSource,
                loadingOptions: D2D1_IMAGE_SOURCE_LOADING_OPTIONS,
                alphaMode: D2D1_ALPHA_MODE,
                imageSource: ?*?*ID2D1ImageSourceFromWic,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                wicBitmapSource: ?*IWICBitmapSource,
                loadingOptions: D2D1_IMAGE_SOURCE_LOADING_OPTIONS,
                alphaMode: D2D1_ALPHA_MODE,
                imageSource: ?*?*ID2D1ImageSourceFromWic,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateLookupTable3D: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                precision: D2D1_BUFFER_PRECISION,
                extents: *[3]u32,
                data: [*:0]const u8,
                dataCount: u32,
                strides: *[2]u32,
                lookupTable: ?*?*ID2D1LookupTable3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                precision: D2D1_BUFFER_PRECISION,
                extents: *[3]u32,
                data: [*:0]const u8,
                dataCount: u32,
                strides: *[2]u32,
                lookupTable: ?*?*ID2D1LookupTable3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateImageSourceFromDxgi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                surfaces: [*]?*IDXGISurface,
                surfaceCount: u32,
                colorSpace: DXGI_COLOR_SPACE_TYPE,
                options: D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS,
                imageSource: ?*?*ID2D1ImageSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                surfaces: [*]?*IDXGISurface,
                surfaceCount: u32,
                colorSpace: DXGI_COLOR_SPACE_TYPE,
                options: D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS,
                imageSource: ?*?*ID2D1ImageSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGradientMeshWorldBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                gradientMesh: ?*ID2D1GradientMesh,
                pBounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                gradientMesh: ?*ID2D1GradientMesh,
                pBounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawInk: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                ink: ?*ID2D1Ink,
                brush: ?*ID2D1Brush,
                inkStyle: ?*ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                ink: ?*ID2D1Ink,
                brush: ?*ID2D1Brush,
                inkStyle: ?*ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawGradientMesh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                gradientMesh: ?*ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                gradientMesh: ?*ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawGdiMetafile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                gdiMetafile: ?*ID2D1GdiMetafile,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                gdiMetafile: ?*ID2D1GdiMetafile,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateTransformedImageSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext2,
                imageSource: ?*ID2D1ImageSource,
                properties: ?*const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES,
                transformedImageSource: ?*?*ID2D1TransformedImageSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext2,
                imageSource: ?*ID2D1ImageSource,
                properties: ?*const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES,
                transformedImageSource: ?*?*ID2D1TransformedImageSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DeviceContext1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateInk(self: *const T, startPoint: ?*const D2D1_INK_POINT, ink: ?*?*ID2D1Ink) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateInk(@as(*const ID2D1DeviceContext2, @ptrCast(self)), startPoint, ink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateInkStyle(self: *const T, inkStyleProperties: ?*const D2D1_INK_STYLE_PROPERTIES, inkStyle: ?*?*ID2D1InkStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateInkStyle(@as(*const ID2D1DeviceContext2, @ptrCast(self)), inkStyleProperties, inkStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateGradientMesh(self: *const T, patches: [*]const D2D1_GRADIENT_MESH_PATCH, patchesCount: u32, gradientMesh: ?*?*ID2D1GradientMesh) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateGradientMesh(@as(*const ID2D1DeviceContext2, @ptrCast(self)), patches, patchesCount, gradientMesh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateImageSourceFromWic(self: *const T, wicBitmapSource: ?*IWICBitmapSource, loadingOptions: D2D1_IMAGE_SOURCE_LOADING_OPTIONS, alphaMode: D2D1_ALPHA_MODE, imageSource: ?*?*ID2D1ImageSourceFromWic) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateImageSourceFromWic(@as(*const ID2D1DeviceContext2, @ptrCast(self)), wicBitmapSource, loadingOptions, alphaMode, imageSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateLookupTable3D(self: *const T, precision: D2D1_BUFFER_PRECISION, extents: *[3]u32, data: [*:0]const u8, dataCount: u32, strides: *[2]u32, lookupTable: ?*?*ID2D1LookupTable3D) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateLookupTable3D(@as(*const ID2D1DeviceContext2, @ptrCast(self)), precision, extents, data, dataCount, strides, lookupTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateImageSourceFromDxgi(self: *const T, surfaces: [*]?*IDXGISurface, surfaceCount: u32, colorSpace: DXGI_COLOR_SPACE_TYPE, options: D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS, imageSource: ?*?*ID2D1ImageSource) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateImageSourceFromDxgi(@as(*const ID2D1DeviceContext2, @ptrCast(self)), surfaces, surfaceCount, colorSpace, options, imageSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_GetGradientMeshWorldBounds(self: *const T, gradientMesh: ?*ID2D1GradientMesh, pBounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).GetGradientMeshWorldBounds(@as(*const ID2D1DeviceContext2, @ptrCast(self)), gradientMesh, pBounds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_DrawInk(self: *const T, ink: ?*ID2D1Ink, brush: ?*ID2D1Brush, inkStyle: ?*ID2D1InkStyle) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).DrawInk(@as(*const ID2D1DeviceContext2, @ptrCast(self)), ink, brush, inkStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_DrawGradientMesh(self: *const T, gradientMesh: ?*ID2D1GradientMesh) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).DrawGradientMesh(@as(*const ID2D1DeviceContext2, @ptrCast(self)), gradientMesh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_DrawGdiMetafile(self: *const T, gdiMetafile: ?*ID2D1GdiMetafile, destinationRectangle: ?*const D2D_RECT_F, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).DrawGdiMetafile(@as(*const ID2D1DeviceContext2, @ptrCast(self)), gdiMetafile, destinationRectangle, sourceRectangle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext2_CreateTransformedImageSource(self: *const T, imageSource: ?*ID2D1ImageSource, properties: ?*const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES, transformedImageSource: ?*?*ID2D1TransformedImageSource) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext2.VTable, @ptrCast(self.vtable)).CreateTransformedImageSource(@as(*const ID2D1DeviceContext2, @ptrCast(self)), imageSource, properties, transformedImageSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Device2_Value = Guid.initString("a44472e1-8dfb-4e60-8492-6e2861c9ca8b");
pub const IID_ID2D1Device2 = &IID_ID2D1Device2_Value;
pub const ID2D1Device2 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Device1.VTable,
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device2,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext2: ?*?*ID2D1DeviceContext2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device2,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext2: ?*?*ID2D1DeviceContext2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushDeviceContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device2,
                bitmap: ?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Device2,
                bitmap: ?*ID2D1Bitmap,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetDxgiDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device2,
                dxgiDevice: ?*?*IDXGIDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device2,
                dxgiDevice: ?*?*IDXGIDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Device1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device2_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext2: ?*?*ID2D1DeviceContext2) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device2.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device2, @ptrCast(self)), options, deviceContext2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device2_FlushDeviceContexts(self: *const T, bitmap: ?*ID2D1Bitmap) callconv(.Inline) void {
            return @as(*const ID2D1Device2.VTable, @ptrCast(self.vtable)).FlushDeviceContexts(@as(*const ID2D1Device2, @ptrCast(self)), bitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device2_GetDxgiDevice(self: *const T, dxgiDevice: ?*?*IDXGIDevice) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device2.VTable, @ptrCast(self.vtable)).GetDxgiDevice(@as(*const ID2D1Device2, @ptrCast(self)), dxgiDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Factory3_Value = Guid.initString("0869759f-4f00-413f-b03e-2bda45404d0f");
pub const IID_ID2D1Factory3 = &IID_ID2D1Factory3_Value;
pub const ID2D1Factory3 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory2.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory3,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice2: ?*?*ID2D1Device2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory3,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice2: ?*?*ID2D1Device2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory3_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice2: ?*?*ID2D1Device2) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory3.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory3, @ptrCast(self)), dxgiDevice, d2dDevice2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_ID2D1CommandSink2_Value = Guid.initString("3bab440e-417e-47df-a2e2-bc0be6a00916");
pub const IID_ID2D1CommandSink2 = &IID_ID2D1CommandSink2_Value;
pub const ID2D1CommandSink2 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1CommandSink1.VTable,
        DrawInk: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink2,
                ink: ?*ID2D1Ink,
                brush: ?*ID2D1Brush,
                inkStyle: ?*ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink2,
                ink: ?*ID2D1Ink,
                brush: ?*ID2D1Brush,
                inkStyle: ?*ID2D1InkStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawGradientMesh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink2,
                gradientMesh: ?*ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink2,
                gradientMesh: ?*ID2D1GradientMesh,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawGdiMetafile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink2,
                gdiMetafile: ?*ID2D1GdiMetafile,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink2,
                gdiMetafile: ?*ID2D1GdiMetafile,
                destinationRectangle: ?*const D2D_RECT_F,
                sourceRectangle: ?*const D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1CommandSink1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink2_DrawInk(self: *const T, ink: ?*ID2D1Ink, brush: ?*ID2D1Brush, inkStyle: ?*ID2D1InkStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink2.VTable, @ptrCast(self.vtable)).DrawInk(@as(*const ID2D1CommandSink2, @ptrCast(self)), ink, brush, inkStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink2_DrawGradientMesh(self: *const T, gradientMesh: ?*ID2D1GradientMesh) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink2.VTable, @ptrCast(self.vtable)).DrawGradientMesh(@as(*const ID2D1CommandSink2, @ptrCast(self)), gradientMesh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink2_DrawGdiMetafile(self: *const T, gdiMetafile: ?*ID2D1GdiMetafile, destinationRectangle: ?*const D2D_RECT_F, sourceRectangle: ?*const D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink2.VTable, @ptrCast(self.vtable)).DrawGdiMetafile(@as(*const ID2D1CommandSink2, @ptrCast(self)), gdiMetafile, destinationRectangle, sourceRectangle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_ID2D1GdiMetafile1_Value = Guid.initString("2e69f9e8-dd3f-4bf9-95ba-c04f49d788df");
pub const IID_ID2D1GdiMetafile1 = &IID_ID2D1GdiMetafile1_Value;
pub const ID2D1GdiMetafile1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1GdiMetafile.VTable,
        GetDpi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiMetafile1,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiMetafile1,
                dpiX: ?*f32,
                dpiY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiMetafile1,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiMetafile1,
                bounds: ?*D2D_RECT_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1GdiMetafile.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiMetafile1_GetDpi(self: *const T, dpiX: ?*f32, dpiY: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiMetafile1.VTable, @ptrCast(self.vtable)).GetDpi(@as(*const ID2D1GdiMetafile1, @ptrCast(self)), dpiX, dpiY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiMetafile1_GetSourceBounds(self: *const T, bounds: ?*D2D_RECT_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiMetafile1.VTable, @ptrCast(self.vtable)).GetSourceBounds(@as(*const ID2D1GdiMetafile1, @ptrCast(self)), bounds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_ID2D1GdiMetafileSink1_Value = Guid.initString("fd0ecb6b-91e6-411e-8655-395e760f91b4");
pub const IID_ID2D1GdiMetafileSink1 = &IID_ID2D1GdiMetafileSink1_Value;
pub const ID2D1GdiMetafileSink1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1GdiMetafileSink.VTable,
        ProcessRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1GdiMetafileSink1,
                recordType: u32,
                recordData: ?*const anyopaque,
                recordDataSize: u32,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1GdiMetafileSink1,
                recordType: u32,
                recordData: ?*const anyopaque,
                recordDataSize: u32,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1GdiMetafileSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1GdiMetafileSink1_ProcessRecord(self: *const T, recordType: u32, recordData: ?*const anyopaque, recordDataSize: u32, flags: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1GdiMetafileSink1.VTable, @ptrCast(self.vtable)).ProcessRecord(@as(*const ID2D1GdiMetafileSink1, @ptrCast(self)), recordType, recordData, recordDataSize, flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SpriteBatch_Value = Guid.initString("4dc583bf-3a10-438a-8722-e9765224f1f1");
pub const IID_ID2D1SpriteBatch = &IID_ID2D1SpriteBatch_Value;
pub const ID2D1SpriteBatch = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        AddSprites: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SpriteBatch,
                spriteCount: u32,
                destinationRectangles: ?*const D2D_RECT_F,
                sourceRectangles: ?*const D2D_RECT_U,
                colors: ?*const D2D1_COLOR_F,
                transforms: ?*const D2D_MATRIX_3X2_F,
                destinationRectanglesStride: u32,
                sourceRectanglesStride: u32,
                colorsStride: u32,
                transformsStride: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SpriteBatch,
                spriteCount: u32,
                destinationRectangles: ?*const D2D_RECT_F,
                sourceRectangles: ?*const D2D_RECT_U,
                colors: ?*const D2D1_COLOR_F,
                transforms: ?*const D2D_MATRIX_3X2_F,
                destinationRectanglesStride: u32,
                sourceRectanglesStride: u32,
                colorsStride: u32,
                transformsStride: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSprites: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                destinationRectangles: ?*const D2D_RECT_F,
                sourceRectangles: ?*const D2D_RECT_U,
                colors: ?*const D2D1_COLOR_F,
                transforms: ?*const D2D_MATRIX_3X2_F,
                destinationRectanglesStride: u32,
                sourceRectanglesStride: u32,
                colorsStride: u32,
                transformsStride: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                destinationRectangles: ?*const D2D_RECT_F,
                sourceRectangles: ?*const D2D_RECT_U,
                colors: ?*const D2D1_COLOR_F,
                transforms: ?*const D2D_MATRIX_3X2_F,
                destinationRectanglesStride: u32,
                sourceRectanglesStride: u32,
                colorsStride: u32,
                transformsStride: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSprites: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                destinationRectangles: ?[*]D2D_RECT_F,
                sourceRectangles: ?[*]D2D_RECT_U,
                colors: ?[*]D2D1_COLOR_F,
                transforms: ?[*]D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                destinationRectangles: ?[*]D2D_RECT_F,
                sourceRectangles: ?[*]D2D_RECT_U,
                colors: ?[*]D2D1_COLOR_F,
                transforms: ?[*]D2D_MATRIX_3X2_F,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpriteCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SpriteBatch,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SpriteBatch,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SpriteBatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SpriteBatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SpriteBatch_AddSprites(self: *const T, spriteCount: u32, destinationRectangles: ?*const D2D_RECT_F, sourceRectangles: ?*const D2D_RECT_U, colors: ?*const D2D1_COLOR_F, transforms: ?*const D2D_MATRIX_3X2_F, destinationRectanglesStride: u32, sourceRectanglesStride: u32, colorsStride: u32, transformsStride: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SpriteBatch.VTable, @ptrCast(self.vtable)).AddSprites(@as(*const ID2D1SpriteBatch, @ptrCast(self)), spriteCount, destinationRectangles, sourceRectangles, colors, transforms, destinationRectanglesStride, sourceRectanglesStride, colorsStride, transformsStride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SpriteBatch_SetSprites(self: *const T, startIndex: u32, spriteCount: u32, destinationRectangles: ?*const D2D_RECT_F, sourceRectangles: ?*const D2D_RECT_U, colors: ?*const D2D1_COLOR_F, transforms: ?*const D2D_MATRIX_3X2_F, destinationRectanglesStride: u32, sourceRectanglesStride: u32, colorsStride: u32, transformsStride: u32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SpriteBatch.VTable, @ptrCast(self.vtable)).SetSprites(@as(*const ID2D1SpriteBatch, @ptrCast(self)), startIndex, spriteCount, destinationRectangles, sourceRectangles, colors, transforms, destinationRectanglesStride, sourceRectanglesStride, colorsStride, transformsStride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SpriteBatch_GetSprites(self: *const T, startIndex: u32, spriteCount: u32, destinationRectangles: ?[*]D2D_RECT_F, sourceRectangles: ?[*]D2D_RECT_U, colors: ?[*]D2D1_COLOR_F, transforms: ?[*]D2D_MATRIX_3X2_F) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SpriteBatch.VTable, @ptrCast(self.vtable)).GetSprites(@as(*const ID2D1SpriteBatch, @ptrCast(self)), startIndex, spriteCount, destinationRectangles, sourceRectangles, colors, transforms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SpriteBatch_GetSpriteCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SpriteBatch.VTable, @ptrCast(self.vtable)).GetSpriteCount(@as(*const ID2D1SpriteBatch, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SpriteBatch_Clear(self: *const T) callconv(.Inline) void {
            return @as(*const ID2D1SpriteBatch.VTable, @ptrCast(self.vtable)).Clear(@as(*const ID2D1SpriteBatch, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1DeviceContext3_Value = Guid.initString("235a7496-8351-414c-bcd4-6672ab2d8e00");
pub const IID_ID2D1DeviceContext3 = &IID_ID2D1DeviceContext3_Value;
pub const ID2D1DeviceContext3 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DeviceContext2.VTable,
        CreateSpriteBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext3,
                spriteBatch: ?*?*ID2D1SpriteBatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext3,
                spriteBatch: ?*?*ID2D1SpriteBatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawSpriteBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext3,
                spriteBatch: ?*ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                bitmap: ?*ID2D1Bitmap,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
                spriteOptions: D2D1_SPRITE_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext3,
                spriteBatch: ?*ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                bitmap: ?*ID2D1Bitmap,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
                spriteOptions: D2D1_SPRITE_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DeviceContext2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext3_CreateSpriteBatch(self: *const T, spriteBatch: ?*?*ID2D1SpriteBatch) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext3.VTable, @ptrCast(self.vtable)).CreateSpriteBatch(@as(*const ID2D1DeviceContext3, @ptrCast(self)), spriteBatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext3_DrawSpriteBatch(self: *const T, spriteBatch: ?*ID2D1SpriteBatch, startIndex: u32, spriteCount: u32, bitmap: ?*ID2D1Bitmap, interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE, spriteOptions: D2D1_SPRITE_OPTIONS) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext3.VTable, @ptrCast(self.vtable)).DrawSpriteBatch(@as(*const ID2D1DeviceContext3, @ptrCast(self)), spriteBatch, startIndex, spriteCount, bitmap, interpolationMode, spriteOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Device3_Value = Guid.initString("852f2087-802c-4037-ab60-ff2e7ee6fc01");
pub const IID_ID2D1Device3 = &IID_ID2D1Device3_Value;
pub const ID2D1Device3 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Device2.VTable,
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device3,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext3: ?*?*ID2D1DeviceContext3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device3,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext3: ?*?*ID2D1DeviceContext3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Device2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device3_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext3: ?*?*ID2D1DeviceContext3) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device3.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device3, @ptrCast(self)), options, deviceContext3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Factory4_Value = Guid.initString("bd4ec2d2-0662-4bee-ba8e-6f29f032e096");
pub const IID_ID2D1Factory4 = &IID_ID2D1Factory4_Value;
pub const ID2D1Factory4 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory3.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory4,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice3: ?*?*ID2D1Device3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory4,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice3: ?*?*ID2D1Device3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory4_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice3: ?*?*ID2D1Device3) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory4.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory4, @ptrCast(self)), dxgiDevice, d2dDevice3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1CommandSink3_Value = Guid.initString("18079135-4cf3-4868-bc8e-06067e6d242d");
pub const IID_ID2D1CommandSink3 = &IID_ID2D1CommandSink3_Value;
pub const ID2D1CommandSink3 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1CommandSink2.VTable,
        DrawSpriteBatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink3,
                spriteBatch: ?*ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                bitmap: ?*ID2D1Bitmap,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
                spriteOptions: D2D1_SPRITE_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink3,
                spriteBatch: ?*ID2D1SpriteBatch,
                startIndex: u32,
                spriteCount: u32,
                bitmap: ?*ID2D1Bitmap,
                interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE,
                spriteOptions: D2D1_SPRITE_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1CommandSink2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink3_DrawSpriteBatch(self: *const T, spriteBatch: ?*ID2D1SpriteBatch, startIndex: u32, spriteCount: u32, bitmap: ?*ID2D1Bitmap, interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE, spriteOptions: D2D1_SPRITE_OPTIONS) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink3.VTable, @ptrCast(self.vtable)).DrawSpriteBatch(@as(*const ID2D1CommandSink3, @ptrCast(self)), spriteBatch, startIndex, spriteCount, bitmap, interpolationMode, spriteOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1SvgGlyphStyle_Value = Guid.initString("af671749-d241-4db8-8e41-dcc2e5c1a438");
pub const IID_ID2D1SvgGlyphStyle = &IID_ID2D1SvgGlyphStyle_Value;
pub const ID2D1SvgGlyphStyle = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Resource.VTable,
        SetFill: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFill: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*?*ID2D1Brush,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                dashes: ?[*]const f32,
                dashesCount: u32,
                dashOffset: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*ID2D1Brush,
                strokeWidth: f32,
                dashes: ?[*]const f32,
                dashesCount: u32,
                dashOffset: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStrokeDashesCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgGlyphStyle,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const ID2D1SvgGlyphStyle,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetStroke: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*?*ID2D1Brush,
                strokeWidth: ?*f32,
                dashes: ?[*]f32,
                dashesCount: u32,
                dashOffset: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1SvgGlyphStyle,
                brush: ?*?*ID2D1Brush,
                strokeWidth: ?*f32,
                dashes: ?[*]f32,
                dashesCount: u32,
                dashOffset: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Resource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgGlyphStyle_SetFill(self: *const T, brush: ?*ID2D1Brush) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgGlyphStyle.VTable, @ptrCast(self.vtable)).SetFill(@as(*const ID2D1SvgGlyphStyle, @ptrCast(self)), brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgGlyphStyle_GetFill(self: *const T, brush: ?*?*ID2D1Brush) callconv(.Inline) void {
            return @as(*const ID2D1SvgGlyphStyle.VTable, @ptrCast(self.vtable)).GetFill(@as(*const ID2D1SvgGlyphStyle, @ptrCast(self)), brush);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgGlyphStyle_SetStroke(self: *const T, brush: ?*ID2D1Brush, strokeWidth: f32, dashes: ?[*]const f32, dashesCount: u32, dashOffset: f32) callconv(.Inline) HRESULT {
            return @as(*const ID2D1SvgGlyphStyle.VTable, @ptrCast(self.vtable)).SetStroke(@as(*const ID2D1SvgGlyphStyle, @ptrCast(self)), brush, strokeWidth, dashes, dashesCount, dashOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgGlyphStyle_GetStrokeDashesCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const ID2D1SvgGlyphStyle.VTable, @ptrCast(self.vtable)).GetStrokeDashesCount(@as(*const ID2D1SvgGlyphStyle, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1SvgGlyphStyle_GetStroke(self: *const T, brush: ?*?*ID2D1Brush, strokeWidth: ?*f32, dashes: ?[*]f32, dashesCount: u32, dashOffset: ?*f32) callconv(.Inline) void {
            return @as(*const ID2D1SvgGlyphStyle.VTable, @ptrCast(self.vtable)).GetStroke(@as(*const ID2D1SvgGlyphStyle, @ptrCast(self)), brush, strokeWidth, dashes, dashesCount, dashOffset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1DeviceContext4_Value = Guid.initString("8c427831-3d90-4476-b647-c4fae349e4db");
pub const IID_ID2D1DeviceContext4 = &IID_ID2D1DeviceContext4_Value;
pub const ID2D1DeviceContext4 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DeviceContext3.VTable,
        CreateSvgGlyphStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                svgGlyphStyle: ?*?*ID2D1SvgGlyphStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                svgGlyphStyle: ?*?*ID2D1SvgGlyphStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                string: [*:0]const u16,
                stringLength: u32,
                textFormat: ?*IDWriteTextFormat,
                layoutRect: ?*const D2D_RECT_F,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                options: D2D1_DRAW_TEXT_OPTIONS,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                string: [*:0]const u16,
                stringLength: u32,
                textFormat: ?*IDWriteTextFormat,
                layoutRect: ?*const D2D_RECT_F,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                options: D2D1_DRAW_TEXT_OPTIONS,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawTextLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                origin: D2D_POINT_2F,
                textLayout: ?*IDWriteTextLayout,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                options: D2D1_DRAW_TEXT_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                origin: D2D_POINT_2F,
                textLayout: ?*IDWriteTextLayout,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                options: D2D1_DRAW_TEXT_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawColorBitmapGlyphRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                glyphImageFormat: DWRITE_GLYPH_IMAGE_FORMATS,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                measuringMode: DWRITE_MEASURING_MODE,
                bitmapSnapOption: D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                glyphImageFormat: DWRITE_GLYPH_IMAGE_FORMATS,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                measuringMode: DWRITE_MEASURING_MODE,
                bitmapSnapOption: D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DrawSvgGlyphRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                baselineOrigin: D2D_POINT_2F,
                glyphRun: ?*const DWRITE_GLYPH_RUN,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                measuringMode: DWRITE_MEASURING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetColorBitmapGlyphImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                glyphImageFormat: DWRITE_GLYPH_IMAGE_FORMATS,
                glyphOrigin: D2D_POINT_2F,
                fontFace: ?*IDWriteFontFace,
                fontEmSize: f32,
                glyphIndex: u16,
                isSideways: BOOL,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                dpiX: f32,
                dpiY: f32,
                glyphTransform: ?*D2D_MATRIX_3X2_F,
                glyphImage: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                glyphImageFormat: DWRITE_GLYPH_IMAGE_FORMATS,
                glyphOrigin: D2D_POINT_2F,
                fontFace: ?*IDWriteFontFace,
                fontEmSize: f32,
                glyphIndex: u16,
                isSideways: BOOL,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                dpiX: f32,
                dpiY: f32,
                glyphTransform: ?*D2D_MATRIX_3X2_F,
                glyphImage: ?*?*ID2D1Image,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSvgGlyphImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext4,
                glyphOrigin: D2D_POINT_2F,
                fontFace: ?*IDWriteFontFace,
                fontEmSize: f32,
                glyphIndex: u16,
                isSideways: BOOL,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                glyphTransform: ?*D2D_MATRIX_3X2_F,
                glyphImage: ?*?*ID2D1CommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext4,
                glyphOrigin: D2D_POINT_2F,
                fontFace: ?*IDWriteFontFace,
                fontEmSize: f32,
                glyphIndex: u16,
                isSideways: BOOL,
                worldTransform: ?*const D2D_MATRIX_3X2_F,
                defaultFillBrush: ?*ID2D1Brush,
                svgGlyphStyle: ?*ID2D1SvgGlyphStyle,
                colorPaletteIndex: u32,
                glyphTransform: ?*D2D_MATRIX_3X2_F,
                glyphImage: ?*?*ID2D1CommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DeviceContext3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_CreateSvgGlyphStyle(self: *const T, svgGlyphStyle: ?*?*ID2D1SvgGlyphStyle) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).CreateSvgGlyphStyle(@as(*const ID2D1DeviceContext4, @ptrCast(self)), svgGlyphStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_DrawText(self: *const T, string: [*:0]const u16, stringLength: u32, textFormat: ?*IDWriteTextFormat, layoutRect: ?*const D2D_RECT_F, defaultFillBrush: ?*ID2D1Brush, svgGlyphStyle: ?*ID2D1SvgGlyphStyle, colorPaletteIndex: u32, options: D2D1_DRAW_TEXT_OPTIONS, measuringMode: DWRITE_MEASURING_MODE) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).DrawText(@as(*const ID2D1DeviceContext4, @ptrCast(self)), string, stringLength, textFormat, layoutRect, defaultFillBrush, svgGlyphStyle, colorPaletteIndex, options, measuringMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_DrawTextLayout(self: *const T, origin: D2D_POINT_2F, textLayout: ?*IDWriteTextLayout, defaultFillBrush: ?*ID2D1Brush, svgGlyphStyle: ?*ID2D1SvgGlyphStyle, colorPaletteIndex: u32, options: D2D1_DRAW_TEXT_OPTIONS) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).DrawTextLayout(@as(*const ID2D1DeviceContext4, @ptrCast(self)), origin, textLayout, defaultFillBrush, svgGlyphStyle, colorPaletteIndex, options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_DrawColorBitmapGlyphRun(self: *const T, glyphImageFormat: DWRITE_GLYPH_IMAGE_FORMATS, baselineOrigin: D2D_POINT_2F, glyphRun: ?*const DWRITE_GLYPH_RUN, measuringMode: DWRITE_MEASURING_MODE, bitmapSnapOption: D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).DrawColorBitmapGlyphRun(@as(*const ID2D1DeviceContext4, @ptrCast(self)), glyphImageFormat, baselineOrigin, glyphRun, measuringMode, bitmapSnapOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_DrawSvgGlyphRun(self: *const T, baselineOrigin: D2D_POINT_2F, glyphRun: ?*const DWRITE_GLYPH_RUN, defaultFillBrush: ?*ID2D1Brush, svgGlyphStyle: ?*ID2D1SvgGlyphStyle, colorPaletteIndex: u32, measuringMode: DWRITE_MEASURING_MODE) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).DrawSvgGlyphRun(@as(*const ID2D1DeviceContext4, @ptrCast(self)), baselineOrigin, glyphRun, defaultFillBrush, svgGlyphStyle, colorPaletteIndex, measuringMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_GetColorBitmapGlyphImage(self: *const T, glyphImageFormat: DWRITE_GLYPH_IMAGE_FORMATS, glyphOrigin: D2D_POINT_2F, fontFace: ?*IDWriteFontFace, fontEmSize: f32, glyphIndex: u16, isSideways: BOOL, worldTransform: ?*const D2D_MATRIX_3X2_F, dpiX: f32, dpiY: f32, glyphTransform: ?*D2D_MATRIX_3X2_F, glyphImage: ?*?*ID2D1Image) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).GetColorBitmapGlyphImage(@as(*const ID2D1DeviceContext4, @ptrCast(self)), glyphImageFormat, glyphOrigin, fontFace, fontEmSize, glyphIndex, isSideways, worldTransform, dpiX, dpiY, glyphTransform, glyphImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext4_GetSvgGlyphImage(self: *const T, glyphOrigin: D2D_POINT_2F, fontFace: ?*IDWriteFontFace, fontEmSize: f32, glyphIndex: u16, isSideways: BOOL, worldTransform: ?*const D2D_MATRIX_3X2_F, defaultFillBrush: ?*ID2D1Brush, svgGlyphStyle: ?*ID2D1SvgGlyphStyle, colorPaletteIndex: u32, glyphTransform: ?*D2D_MATRIX_3X2_F, glyphImage: ?*?*ID2D1CommandList) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext4.VTable, @ptrCast(self.vtable)).GetSvgGlyphImage(@as(*const ID2D1DeviceContext4, @ptrCast(self)), glyphOrigin, fontFace, fontEmSize, glyphIndex, isSideways, worldTransform, defaultFillBrush, svgGlyphStyle, colorPaletteIndex, glyphTransform, glyphImage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Device4_Value = Guid.initString("d7bdb159-5683-4a46-bc9c-72dc720b858b");
pub const IID_ID2D1Device4 = &IID_ID2D1Device4_Value;
pub const ID2D1Device4 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Device3.VTable,
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device4,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext4: ?*?*ID2D1DeviceContext4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device4,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext4: ?*?*ID2D1DeviceContext4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaximumColorGlyphCacheMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device4,
                maximumInBytes: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1Device4,
                maximumInBytes: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMaximumColorGlyphCacheMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device4,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const ID2D1Device4,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Device3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device4_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext4: ?*?*ID2D1DeviceContext4) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device4.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device4, @ptrCast(self)), options, deviceContext4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device4_SetMaximumColorGlyphCacheMemory(self: *const T, maximumInBytes: u64) callconv(.Inline) void {
            return @as(*const ID2D1Device4.VTable, @ptrCast(self.vtable)).SetMaximumColorGlyphCacheMemory(@as(*const ID2D1Device4, @ptrCast(self)), maximumInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device4_GetMaximumColorGlyphCacheMemory(self: *const T) callconv(.Inline) u64 {
            return @as(*const ID2D1Device4.VTable, @ptrCast(self.vtable)).GetMaximumColorGlyphCacheMemory(@as(*const ID2D1Device4, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Factory5_Value = Guid.initString("c4349994-838e-4b0f-8cab-44997d9eeacc");
pub const IID_ID2D1Factory5 = &IID_ID2D1Factory5_Value;
pub const ID2D1Factory5 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory4.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory5,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice4: ?*?*ID2D1Device4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory5,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice4: ?*?*ID2D1Device4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory5_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice4: ?*?*ID2D1Device4) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory5.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory5, @ptrCast(self)), dxgiDevice, d2dDevice4);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1CommandSink4_Value = Guid.initString("c78a6519-40d6-4218-b2de-beeeb744bb3e");
pub const IID_ID2D1CommandSink4 = &IID_ID2D1CommandSink4_Value;
pub const ID2D1CommandSink4 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1CommandSink3.VTable,
        SetPrimitiveBlend2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink4,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink4,
                primitiveBlend: D2D1_PRIMITIVE_BLEND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1CommandSink3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink4_SetPrimitiveBlend2(self: *const T, primitiveBlend: D2D1_PRIMITIVE_BLEND) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink4.VTable, @ptrCast(self.vtable)).SetPrimitiveBlend2(@as(*const ID2D1CommandSink4, @ptrCast(self)), primitiveBlend);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1ColorContext1_Value = Guid.initString("1ab42875-c57f-4be9-bd85-9cd78d6f55ee");
pub const IID_ID2D1ColorContext1 = &IID_ID2D1ColorContext1_Value;
pub const ID2D1ColorContext1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1ColorContext.VTable,
        GetColorContextType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_CONTEXT_TYPE,
            else => *const fn(
                self: *const ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_CONTEXT_TYPE,
        },
        GetDXGIColorSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) DXGI_COLOR_SPACE_TYPE,
            else => *const fn(
                self: *const ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) DXGI_COLOR_SPACE_TYPE,
        },
        GetSimpleColorProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1ColorContext1,
                simpleProfile: ?*D2D1_SIMPLE_COLOR_PROFILE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1ColorContext1,
                simpleProfile: ?*D2D1_SIMPLE_COLOR_PROFILE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1ColorContext.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ColorContext1_GetColorContextType(self: *const T) callconv(.Inline) D2D1_COLOR_CONTEXT_TYPE {
            return @as(*const ID2D1ColorContext1.VTable, @ptrCast(self.vtable)).GetColorContextType(@as(*const ID2D1ColorContext1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ColorContext1_GetDXGIColorSpace(self: *const T) callconv(.Inline) DXGI_COLOR_SPACE_TYPE {
            return @as(*const ID2D1ColorContext1.VTable, @ptrCast(self.vtable)).GetDXGIColorSpace(@as(*const ID2D1ColorContext1, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1ColorContext1_GetSimpleColorProfile(self: *const T, simpleProfile: ?*D2D1_SIMPLE_COLOR_PROFILE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1ColorContext1.VTable, @ptrCast(self.vtable)).GetSimpleColorProfile(@as(*const ID2D1ColorContext1, @ptrCast(self)), simpleProfile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1DeviceContext5_Value = Guid.initString("7836d248-68cc-4df6-b9e8-de991bf62eb7");
pub const IID_ID2D1DeviceContext5 = &IID_ID2D1DeviceContext5_Value;
pub const ID2D1DeviceContext5 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DeviceContext4.VTable,
        CreateSvgDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext5,
                inputXmlStream: ?*IStream,
                viewportSize: D2D_SIZE_F,
                svgDocument: ?*?*ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext5,
                inputXmlStream: ?*IStream,
                viewportSize: D2D_SIZE_F,
                svgDocument: ?*?*ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawSvgDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext5,
                svgDocument: ?*ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext5,
                svgDocument: ?*ID2D1SvgDocument,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateColorContextFromDxgiColorSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext5,
                colorSpace: DXGI_COLOR_SPACE_TYPE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext5,
                colorSpace: DXGI_COLOR_SPACE_TYPE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContextFromSimpleColorProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext5,
                simpleProfile: ?*const D2D1_SIMPLE_COLOR_PROFILE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1DeviceContext5,
                simpleProfile: ?*const D2D1_SIMPLE_COLOR_PROFILE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DeviceContext4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext5_CreateSvgDocument(self: *const T, inputXmlStream: ?*IStream, viewportSize: D2D_SIZE_F, svgDocument: ?*?*ID2D1SvgDocument) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext5.VTable, @ptrCast(self.vtable)).CreateSvgDocument(@as(*const ID2D1DeviceContext5, @ptrCast(self)), inputXmlStream, viewportSize, svgDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext5_DrawSvgDocument(self: *const T, svgDocument: ?*ID2D1SvgDocument) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext5.VTable, @ptrCast(self.vtable)).DrawSvgDocument(@as(*const ID2D1DeviceContext5, @ptrCast(self)), svgDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext5_CreateColorContextFromDxgiColorSpace(self: *const T, colorSpace: DXGI_COLOR_SPACE_TYPE, colorContext: ?*?*ID2D1ColorContext1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext5.VTable, @ptrCast(self.vtable)).CreateColorContextFromDxgiColorSpace(@as(*const ID2D1DeviceContext5, @ptrCast(self)), colorSpace, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext5_CreateColorContextFromSimpleColorProfile(self: *const T, simpleProfile: ?*const D2D1_SIMPLE_COLOR_PROFILE, colorContext: ?*?*ID2D1ColorContext1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1DeviceContext5.VTable, @ptrCast(self.vtable)).CreateColorContextFromSimpleColorProfile(@as(*const ID2D1DeviceContext5, @ptrCast(self)), simpleProfile, colorContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Device5_Value = Guid.initString("d55ba0a4-6405-4694-aef5-08ee1a4358b4");
pub const IID_ID2D1Device5 = &IID_ID2D1Device5_Value;
pub const ID2D1Device5 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Device4.VTable,
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device5,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext5: ?*?*ID2D1DeviceContext5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device5,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext5: ?*?*ID2D1DeviceContext5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Device4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device5_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext5: ?*?*ID2D1DeviceContext5) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device5.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device5, @ptrCast(self)), options, deviceContext5);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Factory6_Value = Guid.initString("f9976f46-f642-44c1-97ca-da32ea2a2635");
pub const IID_ID2D1Factory6 = &IID_ID2D1Factory6_Value;
pub const ID2D1Factory6 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory5.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory6,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice5: ?*?*ID2D1Device5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory6,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice5: ?*?*ID2D1Device5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory6_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice5: ?*?*ID2D1Device5) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory6.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory6, @ptrCast(self)), dxgiDevice, d2dDevice5);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1CommandSink5_Value = Guid.initString("7047dd26-b1e7-44a7-959a-8349e2144fa8");
pub const IID_ID2D1CommandSink5 = &IID_ID2D1CommandSink5_Value;
pub const ID2D1CommandSink5 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1CommandSink4.VTable,
        BlendImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1CommandSink5,
                image: ?*ID2D1Image,
                blendMode: D2D1_BLEND_MODE,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1CommandSink5,
                image: ?*ID2D1Image,
                blendMode: D2D1_BLEND_MODE,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1CommandSink4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1CommandSink5_BlendImage(self: *const T, image: ?*ID2D1Image, blendMode: D2D1_BLEND_MODE, targetOffset: ?*const D2D_POINT_2F, imageRectangle: ?*const D2D_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE) callconv(.Inline) HRESULT {
            return @as(*const ID2D1CommandSink5.VTable, @ptrCast(self.vtable)).BlendImage(@as(*const ID2D1CommandSink5, @ptrCast(self)), image, blendMode, targetOffset, imageRectangle, interpolationMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1DeviceContext6_Value = Guid.initString("985f7e37-4ed0-4a19-98a3-15b0edfde306");
pub const IID_ID2D1DeviceContext6 = &IID_ID2D1DeviceContext6_Value;
pub const ID2D1DeviceContext6 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1DeviceContext5.VTable,
        BlendImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1DeviceContext6,
                image: ?*ID2D1Image,
                blendMode: D2D1_BLEND_MODE,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ID2D1DeviceContext6,
                image: ?*ID2D1Image,
                blendMode: D2D1_BLEND_MODE,
                targetOffset: ?*const D2D_POINT_2F,
                imageRectangle: ?*const D2D_RECT_F,
                interpolationMode: D2D1_INTERPOLATION_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1DeviceContext5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1DeviceContext6_BlendImage(self: *const T, image: ?*ID2D1Image, blendMode: D2D1_BLEND_MODE, targetOffset: ?*const D2D_POINT_2F, imageRectangle: ?*const D2D_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE) callconv(.Inline) void {
            return @as(*const ID2D1DeviceContext6.VTable, @ptrCast(self.vtable)).BlendImage(@as(*const ID2D1DeviceContext6, @ptrCast(self)), image, blendMode, targetOffset, imageRectangle, interpolationMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Device6_Value = Guid.initString("7bfef914-2d75-4bad-be87-e18ddb077b6d");
pub const IID_ID2D1Device6 = &IID_ID2D1Device6_Value;
pub const ID2D1Device6 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Device5.VTable,
        CreateDeviceContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Device6,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext6: ?*?*ID2D1DeviceContext6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Device6,
                options: D2D1_DEVICE_CONTEXT_OPTIONS,
                deviceContext6: ?*?*ID2D1DeviceContext6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Device5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Device6_CreateDeviceContext(self: *const T, options: D2D1_DEVICE_CONTEXT_OPTIONS, deviceContext6: ?*?*ID2D1DeviceContext6) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Device6.VTable, @ptrCast(self.vtable)).CreateDeviceContext(@as(*const ID2D1Device6, @ptrCast(self)), options, deviceContext6);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1Factory7_Value = Guid.initString("bdc2bdd3-b96c-4de6-bdf7-99d4745454de");
pub const IID_ID2D1Factory7 = &IID_ID2D1Factory7_Value;
pub const ID2D1Factory7 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1Factory6.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1Factory7,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice6: ?*?*ID2D1Device6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1Factory7,
                dxgiDevice: ?*IDXGIDevice,
                d2dDevice6: ?*?*ID2D1Device6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1Factory6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1Factory7_CreateDevice(self: *const T, dxgiDevice: ?*IDXGIDevice, d2dDevice6: ?*?*ID2D1Device6) callconv(.Inline) HRESULT {
            return @as(*const ID2D1Factory7.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const ID2D1Factory7, @ptrCast(self)), dxgiDevice, d2dDevice6);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1EffectContext1_Value = Guid.initString("84ab595a-fc81-4546-bacd-e8ef4d8abe7a");
pub const IID_ID2D1EffectContext1 = &IID_ID2D1EffectContext1_Value;
pub const ID2D1EffectContext1 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1EffectContext.VTable,
        CreateLookupTable3D: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext1,
                precision: D2D1_BUFFER_PRECISION,
                extents: *[3]u32,
                data: [*:0]const u8,
                dataCount: u32,
                strides: *[2]u32,
                lookupTable: ?*?*ID2D1LookupTable3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext1,
                precision: D2D1_BUFFER_PRECISION,
                extents: *[3]u32,
                data: [*:0]const u8,
                dataCount: u32,
                strides: *[2]u32,
                lookupTable: ?*?*ID2D1LookupTable3D,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1EffectContext.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext1_CreateLookupTable3D(self: *const T, precision: D2D1_BUFFER_PRECISION, extents: *[3]u32, data: [*:0]const u8, dataCount: u32, strides: *[2]u32, lookupTable: ?*?*ID2D1LookupTable3D) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext1.VTable, @ptrCast(self.vtable)).CreateLookupTable3D(@as(*const ID2D1EffectContext1, @ptrCast(self)), precision, extents, data, dataCount, strides, lookupTable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID2D1EffectContext2_Value = Guid.initString("577ad2a0-9fc7-4dda-8b18-dab810140052");
pub const IID_ID2D1EffectContext2 = &IID_ID2D1EffectContext2_Value;
pub const ID2D1EffectContext2 = extern struct {
    pub const VTable = extern struct {
        base: ID2D1EffectContext1.VTable,
        CreateColorContextFromDxgiColorSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext2,
                colorSpace: DXGI_COLOR_SPACE_TYPE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext2,
                colorSpace: DXGI_COLOR_SPACE_TYPE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateColorContextFromSimpleColorProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ID2D1EffectContext2,
                simpleProfile: ?*const D2D1_SIMPLE_COLOR_PROFILE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ID2D1EffectContext2,
                simpleProfile: ?*const D2D1_SIMPLE_COLOR_PROFILE,
                colorContext: ?*?*ID2D1ColorContext1,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID2D1EffectContext1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext2_CreateColorContextFromDxgiColorSpace(self: *const T, colorSpace: DXGI_COLOR_SPACE_TYPE, colorContext: ?*?*ID2D1ColorContext1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext2.VTable, @ptrCast(self.vtable)).CreateColorContextFromDxgiColorSpace(@as(*const ID2D1EffectContext2, @ptrCast(self)), colorSpace, colorContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID2D1EffectContext2_CreateColorContextFromSimpleColorProfile(self: *const T, simpleProfile: ?*const D2D1_SIMPLE_COLOR_PROFILE, colorContext: ?*?*ID2D1ColorContext1) callconv(.Inline) HRESULT {
            return @as(*const ID2D1EffectContext2.VTable, @ptrCast(self.vtable)).CreateColorContextFromSimpleColorProfile(@as(*const ID2D1EffectContext2, @ptrCast(self)), simpleProfile, colorContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (13)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
pub extern "d2d1" fn D2D1CreateFactory(
    factoryType: D2D1_FACTORY_TYPE,
    riid: ?*const Guid,
    pFactoryOptions: ?*const D2D1_FACTORY_OPTIONS,
    ppIFactory: **anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "d2d1" fn D2D1MakeRotateMatrix(
    angle: f32,
    center: D2D_POINT_2F,
    matrix: ?*D2D_MATRIX_3X2_F,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "d2d1" fn D2D1MakeSkewMatrix(
    angleX: f32,
    angleY: f32,
    center: D2D_POINT_2F,
    matrix: ?*D2D_MATRIX_3X2_F,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "d2d1" fn D2D1IsMatrixInvertible(
    matrix: ?*const D2D_MATRIX_3X2_F,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "d2d1" fn D2D1InvertMatrix(
    matrix: ?*D2D_MATRIX_3X2_F,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "d2d1" fn D2D1CreateDevice(
    dxgiDevice: ?*IDXGIDevice,
    creationProperties: ?*const D2D1_CREATION_PROPERTIES,
    d2dDevice: ?*?*ID2D1Device,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "d2d1" fn D2D1CreateDeviceContext(
    dxgiSurface: ?*IDXGISurface,
    creationProperties: ?*const D2D1_CREATION_PROPERTIES,
    d2dDeviceContext: ?*?*ID2D1DeviceContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "d2d1" fn D2D1ConvertColorSpace(
    sourceColorSpace: D2D1_COLOR_SPACE,
    destinationColorSpace: D2D1_COLOR_SPACE,
    color: ?*const D2D1_COLOR_F,
) callconv(@import("std").os.windows.WINAPI) D2D1_COLOR_F;

pub extern "d2d1" fn D2D1SinCos(
    angle: f32,
    s: ?*f32,
    c: ?*f32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "d2d1" fn D2D1Tan(
    angle: f32,
) callconv(@import("std").os.windows.WINAPI) f32;

pub extern "d2d1" fn D2D1Vec3Length(
    x: f32,
    y: f32,
    z: f32,
) callconv(@import("std").os.windows.WINAPI) f32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "d2d1" fn D2D1ComputeMaximumScaleFactor(
    matrix: ?*const D2D_MATRIX_3X2_F,
) callconv(@import("std").os.windows.WINAPI) f32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "d2d1" fn D2D1GetGradientMeshInteriorPointsFromCoonsPatch(
    pPoint0: ?*const D2D_POINT_2F,
    pPoint1: ?*const D2D_POINT_2F,
    pPoint2: ?*const D2D_POINT_2F,
    pPoint3: ?*const D2D_POINT_2F,
    pPoint4: ?*const D2D_POINT_2F,
    pPoint5: ?*const D2D_POINT_2F,
    pPoint6: ?*const D2D_POINT_2F,
    pPoint7: ?*const D2D_POINT_2F,
    pPoint8: ?*const D2D_POINT_2F,
    pPoint9: ?*const D2D_POINT_2F,
    pPoint10: ?*const D2D_POINT_2F,
    pPoint11: ?*const D2D_POINT_2F,
    pTensorPoint11: ?*D2D_POINT_2F,
    pTensorPoint12: ?*D2D_POINT_2F,
    pTensorPoint21: ?*D2D_POINT_2F,
    pTensorPoint22: ?*D2D_POINT_2F,
) callconv(@import("std").os.windows.WINAPI) void;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (47)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const D2D1_ALPHA_MODE = @import("../graphics/direct2d/common.zig").D2D1_ALPHA_MODE;
const D2D1_BEZIER_SEGMENT = @import("../graphics/direct2d/common.zig").D2D1_BEZIER_SEGMENT;
const D2D1_BLEND_MODE = @import("../graphics/direct2d/common.zig").D2D1_BLEND_MODE;
const D2D1_COLOR_F = @import("../graphics/direct2d/common.zig").D2D1_COLOR_F;
const D2D1_COMPOSITE_MODE = @import("../graphics/direct2d/common.zig").D2D1_COMPOSITE_MODE;
const D2D1_FILL_MODE = @import("../graphics/direct2d/common.zig").D2D1_FILL_MODE;
const D2D1_PIXEL_FORMAT = @import("../graphics/direct2d/common.zig").D2D1_PIXEL_FORMAT;
const D2D_MATRIX_3X2_F = @import("../graphics/direct2d/common.zig").D2D_MATRIX_3X2_F;
const D2D_MATRIX_4X3_F = @import("../graphics/direct2d/common.zig").D2D_MATRIX_4X3_F;
const D2D_MATRIX_4X4_F = @import("../graphics/direct2d/common.zig").D2D_MATRIX_4X4_F;
const D2D_MATRIX_5X4_F = @import("../graphics/direct2d/common.zig").D2D_MATRIX_5X4_F;
const D2D_POINT_2F = @import("../graphics/direct2d/common.zig").D2D_POINT_2F;
const D2D_POINT_2U = @import("../graphics/direct2d/common.zig").D2D_POINT_2U;
const D2D_RECT_F = @import("../graphics/direct2d/common.zig").D2D_RECT_F;
const D2D_RECT_U = @import("../graphics/direct2d/common.zig").D2D_RECT_U;
const D2D_SIZE_F = @import("../graphics/direct2d/common.zig").D2D_SIZE_F;
const D2D_SIZE_U = @import("../graphics/direct2d/common.zig").D2D_SIZE_U;
const D3D_FEATURE_LEVEL = @import("../graphics/direct3d.zig").D3D_FEATURE_LEVEL;
const DWRITE_GLYPH_IMAGE_FORMATS = @import("../graphics/direct_write.zig").DWRITE_GLYPH_IMAGE_FORMATS;
const DWRITE_GLYPH_RUN = @import("../graphics/direct_write.zig").DWRITE_GLYPH_RUN;
const DWRITE_GLYPH_RUN_DESCRIPTION = @import("../graphics/direct_write.zig").DWRITE_GLYPH_RUN_DESCRIPTION;
const DWRITE_MEASURING_MODE = @import("../graphics/direct_write.zig").DWRITE_MEASURING_MODE;
const DXGI_COLOR_SPACE_TYPE = @import("../graphics/dxgi/common.zig").DXGI_COLOR_SPACE_TYPE;
const DXGI_FORMAT = @import("../graphics/dxgi/common.zig").DXGI_FORMAT;
const HDC = @import("../graphics/gdi.zig").HDC;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const ID2D1SimplifiedGeometrySink = @import("../graphics/direct2d/common.zig").ID2D1SimplifiedGeometrySink;
const IDWriteFontFace = @import("../graphics/direct_write.zig").IDWriteFontFace;
const IDWriteRenderingParams = @import("../graphics/direct_write.zig").IDWriteRenderingParams;
const IDWriteTextFormat = @import("../graphics/direct_write.zig").IDWriteTextFormat;
const IDWriteTextLayout = @import("../graphics/direct_write.zig").IDWriteTextLayout;
const IDXGIDevice = @import("../graphics/dxgi.zig").IDXGIDevice;
const IDXGISurface = @import("../graphics/dxgi.zig").IDXGISurface;
const IPrintDocumentPackageTarget = @import("../storage/xps/printing.zig").IPrintDocumentPackageTarget;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const IWICBitmap = @import("../graphics/imaging.zig").IWICBitmap;
const IWICBitmapSource = @import("../graphics/imaging.zig").IWICBitmapSource;
const IWICColorContext = @import("../graphics/imaging.zig").IWICColorContext;
const IWICImagingFactory = @import("../graphics/imaging.zig").IWICImagingFactory;
const POINT = @import("../foundation.zig").POINT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PD2D1_EFFECT_FACTORY")) { _ = PD2D1_EFFECT_FACTORY; }
    if (@hasDecl(@This(), "PD2D1_PROPERTY_SET_FUNCTION")) { _ = PD2D1_PROPERTY_SET_FUNCTION; }
    if (@hasDecl(@This(), "PD2D1_PROPERTY_GET_FUNCTION")) { _ = PD2D1_PROPERTY_GET_FUNCTION; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const common = @import("direct2d/common.zig");
