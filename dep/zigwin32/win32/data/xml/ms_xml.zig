//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (552)
//--------------------------------------------------------------------------------
pub const E_XML_NOTWF = @as(i32, -1072897501);
pub const E_XML_NODTD = @as(i32, -1072897500);
pub const E_XML_INVALID = @as(i32, -1072897499);
pub const E_XML_BUFFERTOOSMALL = @as(i32, -1072897498);
pub const XHR_PROP_ONDATA_ALWAYS = @as(u32, 0);
pub const XHR_PROP_ONDATA_NEVER = @as(u64, 18446744073709551615);
pub const DISPID_XOBJ_MIN = @as(u32, 65536);
pub const DISPID_XOBJ_MAX = @as(u32, 131071);
pub const DISPID_XOBJ_BASE = @as(u32, 65536);
pub const DISPID_XMLELEMENTCOLLECTION = @as(u32, 65536);
pub const DISPID_XMLELEMENTCOLLECTION_LENGTH = @as(u32, 65537);
pub const DISPID_XMLELEMENTCOLLECTION_NEWENUM = @as(i32, -4);
pub const DISPID_XMLELEMENTCOLLECTION_ITEM = @as(u32, 65539);
pub const DISPID_XMLDOCUMENT = @as(u32, 65636);
pub const DISPID_XMLDOCUMENT_ROOT = @as(u32, 65637);
pub const DISPID_XMLDOCUMENT_FILESIZE = @as(u32, 65638);
pub const DISPID_XMLDOCUMENT_FILEMODIFIEDDATE = @as(u32, 65639);
pub const DISPID_XMLDOCUMENT_FILEUPDATEDDATE = @as(u32, 65640);
pub const DISPID_XMLDOCUMENT_URL = @as(u32, 65641);
pub const DISPID_XMLDOCUMENT_MIMETYPE = @as(u32, 65642);
pub const DISPID_XMLDOCUMENT_READYSTATE = @as(u32, 65643);
pub const DISPID_XMLDOCUMENT_CREATEELEMENT = @as(u32, 65644);
pub const DISPID_XMLDOCUMENT_CHARSET = @as(u32, 65645);
pub const DISPID_XMLDOCUMENT_VERSION = @as(u32, 65646);
pub const DISPID_XMLDOCUMENT_DOCTYPE = @as(u32, 65647);
pub const DISPID_XMLDOCUMENT_DTDURL = @as(u32, 65648);
pub const DISPID_XMLDOCUMENT_ASYNC = @as(u32, 65649);
pub const DISPID_XMLDOCUMENT_CASEINSENSITIVE = @as(u32, 65650);
pub const DISPID_XMLDOCUMENT_BASEURL = @as(u32, 65651);
pub const DISPID_XMLDOCUMENT_XML = @as(u32, 65652);
pub const DISPID_XMLDOCUMENT_LASTERROR = @as(u32, 65653);
pub const DISPID_XMLDOCUMENT_TRIMWHITESPACE = @as(u32, 65654);
pub const DISPID_XMLDOCUMENT_COMMIT = @as(u32, 65655);
pub const DISPID_XMLELEMENT = @as(u32, 65736);
pub const DISPID_XMLELEMENT_TAGNAME = @as(u32, 65737);
pub const DISPID_XMLELEMENT_PARENT = @as(u32, 65738);
pub const DISPID_XMLELEMENT_SETATTRIBUTE = @as(u32, 65739);
pub const DISPID_XMLELEMENT_GETATTRIBUTE = @as(u32, 65740);
pub const DISPID_XMLELEMENT_REMOVEATTRIBUTE = @as(u32, 65741);
pub const DISPID_XMLELEMENT_CHILDREN = @as(u32, 65742);
pub const DISPID_XMLELEMENT_TYPE = @as(u32, 65743);
pub const DISPID_XMLELEMENT_TEXT = @as(u32, 65744);
pub const DISPID_XMLELEMENT_ADDCHILD = @as(u32, 65745);
pub const DISPID_XMLELEMENT_REMOVECHILD = @as(u32, 65746);
pub const DISPID_XMLELEMENT_ATTRIBUTES = @as(u32, 65747);
pub const DISPID_XMLNOTIFSINK = @as(u32, 65836);
pub const DISPID_XMLNOTIFSINK_CHILDADDED = @as(u32, 65837);
pub const DISPID_XMLATTRIBUTE = @as(u32, 65936);
pub const DISPID_XMLATTRIBUTE_NAME = @as(u32, 65937);
pub const DISPID_XMLATTRIBUTE_VALUE = @as(u32, 65938);
pub const DISPID_XMLERROR = @as(u32, 65936);
pub const DISPID_XMLERROR_REASON = @as(u32, 65937);
pub const DISPID_XMLERROR_LINE = @as(u32, 65938);
pub const DISPID_XMLERROR_POS = @as(u32, 65939);
pub const DISPID_NODE = @as(u32, 66036);
pub const DISPID_NODE_NAME = @as(u32, 66037);
pub const DISPID_NODE_PARENT = @as(u32, 66038);
pub const DISPID_NODE_TYPE = @as(u32, 66039);
pub const DISPID_NODE_VALUE = @as(u32, 66040);
pub const DISPID_NODE_SETATTRIBUTE = @as(u32, 66041);
pub const DISPID_NODE_GETATTRIBUTE = @as(u32, 66042);
pub const DISPID_NODE_REMOVEATTRIBUTE = @as(u32, 66043);
pub const DISPID_NODE_ATTRIBUTES = @as(u32, 66044);
pub const DISPID_NODE_ADD = @as(u32, 66045);
pub const DISPID_NODE_REMOVE = @as(u32, 66046);
pub const DISPID_NODE_CHILDREN = @as(u32, 66047);
pub const DISPID_NODELIST = @as(u32, 66136);
pub const DISPID_NODELIST_NEWENUM = @as(u32, 66137);
pub const DISPID_NODELIST_NEXT = @as(u32, 66138);
pub const DISPID_NODELIST_CURRENT = @as(u32, 66139);
pub const DISPID_NODELIST_MOVE = @as(u32, 66140);
pub const DISPID_NODELIST_MOVETONODE = @as(u32, 66141);
pub const DISPID_NODELIST_LENGTH = @as(u32, 66142);
pub const DISPID_NODELIST_ITEM = @as(u32, 66143);
pub const DISPID_DOM_BASE = @as(u32, 1);
pub const DISPID_DOM_COLLECTION_BASE = @as(u32, 1000000);
pub const DISPID_DOM_COLLECTION_MAX = @as(u32, 2999999);
pub const DISPID_DOM_NODE = @as(u32, 1);
pub const DISPID_DOM_NODE_NODENAME = @as(u32, 2);
pub const DISPID_DOM_NODE_NODEVALUE = @as(u32, 3);
pub const DISPID_DOM_NODE_NODETYPE = @as(u32, 4);
pub const DISPID_DOM_NODE_NODETYPEENUM = @as(u32, 5);
pub const DISPID_DOM_NODE_PARENTNODE = @as(u32, 6);
pub const DISPID_DOM_NODE_CHILDNODES = @as(u32, 7);
pub const DISPID_DOM_NODE_FIRSTCHILD = @as(u32, 8);
pub const DISPID_DOM_NODE_LASTCHILD = @as(u32, 9);
pub const DISPID_DOM_NODE_PREVIOUSSIBLING = @as(u32, 10);
pub const DISPID_DOM_NODE_NEXTSIBLING = @as(u32, 11);
pub const DISPID_DOM_NODE_ATTRIBUTES = @as(u32, 12);
pub const DISPID_DOM_NODE_INSERTBEFORE = @as(u32, 13);
pub const DISPID_DOM_NODE_REPLACECHILD = @as(u32, 14);
pub const DISPID_DOM_NODE_REMOVECHILD = @as(u32, 15);
pub const DISPID_DOM_NODE_APPENDCHILD = @as(u32, 16);
pub const DISPID_DOM_NODE_HASCHILDNODES = @as(u32, 17);
pub const DISPID_DOM_NODE_OWNERDOC = @as(u32, 18);
pub const DISPID_DOM_NODE_CLONENODE = @as(u32, 19);
pub const DISPID_XMLDOM_NODE = @as(u32, 20);
pub const DISPID_XMLDOM_NODE_STRINGTYPE = @as(u32, 21);
pub const DISPID_XMLDOM_NODE_SPECIFIED = @as(u32, 22);
pub const DISPID_XMLDOM_NODE_DEFINITION = @as(u32, 23);
pub const DISPID_XMLDOM_NODE_TEXT = @as(u32, 24);
pub const DISPID_XMLDOM_NODE_NODETYPEDVALUE = @as(u32, 25);
pub const DISPID_XMLDOM_NODE_DATATYPE = @as(u32, 26);
pub const DISPID_XMLDOM_NODE_XML = @as(u32, 27);
pub const DISPID_XMLDOM_NODE_TRANSFORMNODE = @as(u32, 28);
pub const DISPID_XMLDOM_NODE_SELECTNODES = @as(u32, 29);
pub const DISPID_XMLDOM_NODE_SELECTSINGLENODE = @as(u32, 30);
pub const DISPID_XMLDOM_NODE_PARSED = @as(u32, 31);
pub const DISPID_XMLDOM_NODE_NAMESPACE = @as(u32, 32);
pub const DISPID_XMLDOM_NODE_PREFIX = @as(u32, 33);
pub const DISPID_XMLDOM_NODE_BASENAME = @as(u32, 34);
pub const DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT = @as(u32, 35);
pub const DISPID_XMLDOM_NODE__TOP = @as(u32, 36);
pub const DISPID_DOM_DOCUMENT = @as(u32, 37);
pub const DISPID_DOM_DOCUMENT_DOCTYPE = @as(u32, 38);
pub const DISPID_DOM_DOCUMENT_IMPLEMENTATION = @as(u32, 39);
pub const DISPID_DOM_DOCUMENT_DOCUMENTELEMENT = @as(u32, 40);
pub const DISPID_DOM_DOCUMENT_CREATEELEMENT = @as(u32, 41);
pub const DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT = @as(u32, 42);
pub const DISPID_DOM_DOCUMENT_CREATETEXTNODE = @as(u32, 43);
pub const DISPID_DOM_DOCUMENT_CREATECOMMENT = @as(u32, 44);
pub const DISPID_DOM_DOCUMENT_CREATECDATASECTION = @as(u32, 45);
pub const DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION = @as(u32, 46);
pub const DISPID_DOM_DOCUMENT_CREATEATTRIBUTE = @as(u32, 47);
pub const DISPID_DOM_DOCUMENT_CREATEENTITY = @as(u32, 48);
pub const DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE = @as(u32, 49);
pub const DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME = @as(u32, 50);
pub const DISPID_DOM_DOCUMENT_TOP = @as(u32, 51);
pub const DISPID_XMLDOM_DOCUMENT = @as(u32, 52);
pub const DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE = @as(u32, 53);
pub const DISPID_XMLDOM_DOCUMENT_CREATENODE = @as(u32, 54);
pub const DISPID_XMLDOM_DOCUMENT_CREATENODEEX = @as(u32, 55);
pub const DISPID_XMLDOM_DOCUMENT_NODEFROMID = @as(u32, 56);
pub const DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES = @as(u32, 57);
pub const DISPID_XMLDOM_DOCUMENT_LOAD = @as(u32, 58);
pub const DISPID_XMLDOM_DOCUMENT_PARSEERROR = @as(u32, 59);
pub const DISPID_XMLDOM_DOCUMENT_URL = @as(u32, 60);
pub const DISPID_XMLDOM_DOCUMENT_ASYNC = @as(u32, 61);
pub const DISPID_XMLDOM_DOCUMENT_ABORT = @as(u32, 62);
pub const DISPID_XMLDOM_DOCUMENT_LOADXML = @as(u32, 63);
pub const DISPID_XMLDOM_DOCUMENT_SAVE = @as(u32, 64);
pub const DISPID_XMLDOM_DOCUMENT_VALIDATE = @as(u32, 65);
pub const DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE = @as(u32, 66);
pub const DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE = @as(u32, 67);
pub const DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE = @as(u32, 68);
pub const DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE = @as(u32, 69);
pub const DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE = @as(u32, 70);
pub const DISPID_XMLDOM_DOCUMENT__TOP = @as(u32, 71);
pub const DISPID_DOM_NODELIST = @as(u32, 72);
pub const DISPID_DOM_NODELIST_ITEM = @as(u32, 73);
pub const DISPID_DOM_NODELIST_LENGTH = @as(u32, 74);
pub const DISPID_XMLDOM_NODELIST = @as(u32, 75);
pub const DISPID_XMLDOM_NODELIST_NEXTNODE = @as(u32, 76);
pub const DISPID_XMLDOM_NODELIST_RESET = @as(u32, 77);
pub const DISPID_XMLDOM_NODELIST_NEWENUM = @as(u32, 78);
pub const DISPID_XMLDOM_NODELIST__TOP = @as(u32, 79);
pub const DISPID_DOM_NAMEDNODEMAP = @as(u32, 80);
pub const DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM = @as(u32, 83);
pub const DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM = @as(u32, 84);
pub const DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM = @as(u32, 85);
pub const DISPID_XMLDOM_NAMEDNODEMAP = @as(u32, 86);
pub const DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM = @as(u32, 87);
pub const DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM = @as(u32, 88);
pub const DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE = @as(u32, 89);
pub const DISPID_XMLDOM_NAMEDNODEMAP_RESET = @as(u32, 90);
pub const DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM = @as(u32, 91);
pub const DISPID_XMLDOM_NAMEDNODEMAP__TOP = @as(u32, 92);
pub const DISPID_DOM_W3CWRAPPERS = @as(u32, 93);
pub const DISPID_DOM_DOCUMENTFRAGMENT = @as(u32, 94);
pub const DISPID_DOM_DOCUMENTFRAGMENT__TOP = @as(u32, 95);
pub const DISPID_DOM_ELEMENT = @as(u32, 96);
pub const DISPID_DOM_ELEMENT_GETTAGNAME = @as(u32, 97);
pub const DISPID_DOM_ELEMENT_GETATTRIBUTES = @as(u32, 98);
pub const DISPID_DOM_ELEMENT_GETATTRIBUTE = @as(u32, 99);
pub const DISPID_DOM_ELEMENT_SETATTRIBUTE = @as(u32, 100);
pub const DISPID_DOM_ELEMENT_REMOVEATTRIBUTE = @as(u32, 101);
pub const DISPID_DOM_ELEMENT_GETATTRIBUTENODE = @as(u32, 102);
pub const DISPID_DOM_ELEMENT_SETATTRIBUTENODE = @as(u32, 103);
pub const DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE = @as(u32, 104);
pub const DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME = @as(u32, 105);
pub const DISPID_DOM_ELEMENT_NORMALIZE = @as(u32, 106);
pub const DISPID_DOM_ELEMENT__TOP = @as(u32, 107);
pub const DISPID_DOM_DATA = @as(u32, 108);
pub const DISPID_DOM_DATA_DATA = @as(u32, 109);
pub const DISPID_DOM_DATA_LENGTH = @as(u32, 110);
pub const DISPID_DOM_DATA_SUBSTRING = @as(u32, 111);
pub const DISPID_DOM_DATA_APPEND = @as(u32, 112);
pub const DISPID_DOM_DATA_INSERT = @as(u32, 113);
pub const DISPID_DOM_DATA_DELETE = @as(u32, 114);
pub const DISPID_DOM_DATA_REPLACE = @as(u32, 115);
pub const DISPID_DOM_DATA__TOP = @as(u32, 116);
pub const DISPID_DOM_ATTRIBUTE = @as(u32, 117);
pub const DISPID_DOM_ATTRIBUTE_GETNAME = @as(u32, 118);
pub const DISPID_DOM_ATTRIBUTE_SPECIFIED = @as(u32, 119);
pub const DISPID_DOM_ATTRIBUTE_VALUE = @as(u32, 120);
pub const DISPID_DOM_ATTRIBUTE__TOP = @as(u32, 121);
pub const DISPID_DOM_TEXT = @as(u32, 122);
pub const DISPID_DOM_TEXT_SPLITTEXT = @as(u32, 123);
pub const DISPID_DOM_TEXT_JOINTEXT = @as(u32, 124);
pub const DISPID_DOM_TEXT__TOP = @as(u32, 125);
pub const DISPID_DOM_PI = @as(u32, 126);
pub const DISPID_DOM_PI_TARGET = @as(u32, 127);
pub const DISPID_DOM_PI_DATA = @as(u32, 128);
pub const DISPID_DOM_PI__TOP = @as(u32, 129);
pub const DISPID_DOM_DOCUMENTTYPE = @as(u32, 130);
pub const DISPID_DOM_DOCUMENTTYPE_NAME = @as(u32, 131);
pub const DISPID_DOM_DOCUMENTTYPE_ENTITIES = @as(u32, 132);
pub const DISPID_DOM_DOCUMENTTYPE_NOTATIONS = @as(u32, 133);
pub const DISPID_DOM_DOCUMENTTYPE__TOP = @as(u32, 134);
pub const DISPID_DOM_NOTATION = @as(u32, 135);
pub const DISPID_DOM_NOTATION_PUBLICID = @as(u32, 136);
pub const DISPID_DOM_NOTATION_SYSTEMID = @as(u32, 137);
pub const DISPID_DOM_NOTATION__TOP = @as(u32, 138);
pub const DISPID_DOM_ENTITY = @as(u32, 139);
pub const DISPID_DOM_ENTITY_PUBLICID = @as(u32, 140);
pub const DISPID_DOM_ENTITY_SYSTEMID = @as(u32, 141);
pub const DISPID_DOM_ENTITY_NOTATIONNAME = @as(u32, 142);
pub const DISPID_DOM_ENTITY__TOP = @as(u32, 143);
pub const DISPID_DOM_W3CWRAPPERS_TOP = @as(u32, 143);
pub const DISPID_DOM_IMPLEMENTATION = @as(u32, 144);
pub const DISPID_DOM_IMPLEMENTATION_HASFEATURE = @as(u32, 145);
pub const DISPID_DOM_IMPLEMENTATION__TOP = @as(u32, 146);
pub const DISPID_DOM__TOP = @as(u32, 176);
pub const DISPID_DOM_ERROR = @as(u32, 177);
pub const DISPID_DOM_ERROR_ERRORCODE = @as(u32, 178);
pub const DISPID_DOM_ERROR_URL = @as(u32, 179);
pub const DISPID_DOM_ERROR_REASON = @as(u32, 180);
pub const DISPID_DOM_ERROR_SRCTEXT = @as(u32, 181);
pub const DISPID_DOM_ERROR_LINE = @as(u32, 182);
pub const DISPID_DOM_ERROR_LINEPOS = @as(u32, 183);
pub const DISPID_DOM_ERROR_FILEPOS = @as(u32, 184);
pub const DISPID_DOM_ERROR__TOP = @as(u32, 185);
pub const DISPID_DOM_ERROR2 = @as(u32, 186);
pub const DISPID_DOM_ERROR2_ALLERRORS = @as(u32, 187);
pub const DISPID_DOM_ERROR2_ERRORPARAMETERS = @as(u32, 188);
pub const DISPID_DOM_ERROR2_ERRORPARAMETERSCOUNT = @as(u32, 189);
pub const DISPID_DOM_ERROR2_ERRORXPATH = @as(u32, 190);
pub const DISPID_DOM_ERROR2__TOP = @as(u32, 191);
pub const DISPID_DOM_ERRORCOLLECTION = @as(u32, 192);
pub const DISPID_DOM_ERRORCOLLECTION_LENGTH = @as(u32, 193);
pub const DISPID_DOM_ERRORCOLLECTION_NEXT = @as(u32, 194);
pub const DISPID_DOM_ERRORCOLLECTION_RESET = @as(u32, 195);
pub const DISPID_DOM_ERRORCOLLECTION__TOP = @as(u32, 196);
pub const DISPID_XTLRUNTIME = @as(u32, 186);
pub const DISPID_XTLRUNTIME_UNIQUEID = @as(u32, 187);
pub const DISPID_XTLRUNTIME_DEPTH = @as(u32, 188);
pub const DISPID_XTLRUNTIME_CHILDNUMBER = @as(u32, 189);
pub const DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER = @as(u32, 190);
pub const DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER = @as(u32, 191);
pub const DISPID_XTLRUNTIME_FORMATINDEX = @as(u32, 192);
pub const DISPID_XTLRUNTIME_FORMATNUMBER = @as(u32, 193);
pub const DISPID_XTLRUNTIME_FORMATDATE = @as(u32, 194);
pub const DISPID_XTLRUNTIME_FORMATTIME = @as(u32, 195);
pub const DISPID_XTLRUNTIME__TOP = @as(u32, 196);
pub const DISPID_XMLDOMEVENT = @as(u32, 197);
pub const DISPID_XMLDOMEVENT_ONREADYSTATECHANGE = @as(i32, -609);
pub const DISPID_XMLDOMEVENT_ONDATAAVAILABLE = @as(u32, 198);
pub const DISPID_XMLDOMEVENT__TOP = @as(u32, 199);
pub const DISPID_XMLDOM_DOCUMENT2 = @as(u32, 200);
pub const DISPID_XMLDOM_DOCUMENT2_NAMESPACES = @as(u32, 201);
pub const DISPID_XMLDOM_DOCUMENT2_SCHEMAS = @as(u32, 202);
pub const DISPID_XMLDOM_DOCUMENT2_VALIDATE = @as(u32, 203);
pub const DISPID_XMLDOM_DOCUMENT2_SETPROPERTY = @as(u32, 204);
pub const DISPID_XMLDOM_DOCUMENT2_GETPROPERTY = @as(u32, 205);
pub const DISPID_XMLDOM_DOCUMENT2__TOP = @as(u32, 206);
pub const DISPID_XMLDOM_DOCUMENT3 = @as(u32, 207);
pub const DISPID_XMLDOM_DOCUMENT3_VALIDATENODE = @as(u32, 208);
pub const DISPID_XMLDOM_DOCUMENT3_IMPORTNODE = @as(u32, 209);
pub const DISPID_XMLDOM_DOCUMENT3__TOP = @as(u32, 210);
pub const DISPID_XMLDOM_SCHEMACOLLECTION = @as(u32, 2);
pub const DISPID_XMLDOM_SCHEMACOLLECTION_ADD = @as(u32, 3);
pub const DISPID_XMLDOM_SCHEMACOLLECTION_GET = @as(u32, 4);
pub const DISPID_XMLDOM_SCHEMACOLLECTION_REMOVE = @as(u32, 5);
pub const DISPID_XMLDOM_SCHEMACOLLECTION_LENGTH = @as(u32, 6);
pub const DISPID_XMLDOM_SCHEMACOLLECTION_NAMESPACEURI = @as(u32, 7);
pub const DISPID_XMLDOM_SCHEMACOLLECTION_ADDCOLLECTION = @as(u32, 8);
pub const DISPID_XMLDOM_SCHEMACOLLECTION__TOP = @as(u32, 9);
pub const DISPID_XMLDOM_SELECTION = @as(u32, 80);
pub const DISPID_XMLDOM_SELECTION_EXPR = @as(u32, 81);
pub const DISPID_XMLDOM_SELECTION_CONTEXT = @as(u32, 82);
pub const DISPID_XMLDOM_SELECTION_PEEKNODE = @as(u32, 83);
pub const DISPID_XMLDOM_SELECTION_MATCHES = @as(u32, 84);
pub const DISPID_XMLDOM_SELECTION_REMOVENEXT = @as(u32, 85);
pub const DISPID_XMLDOM_SELECTION_REMOVEALL = @as(u32, 86);
pub const DISPID_XMLDOM_SELECTION_CLONE = @as(u32, 87);
pub const DISPID_XMLDOM_SELECTION_GETPROPERTY = @as(u32, 88);
pub const DISPID_XMLDOM_SELECTION_SETPROPERTY = @as(u32, 89);
pub const DISPID_XMLDOM_SELECTION__TOP = @as(u32, 90);
pub const DISPID_XMLDOM_TEMPLATE = @as(u32, 1);
pub const DISPID_XMLDOM_TEMPLATE_STYLESHEET = @as(u32, 2);
pub const DISPID_XMLDOM_TEMPLATE_CREATEPROCESSOR = @as(u32, 3);
pub const DISPID_XMLDOM_TEMPLATE__TOP = @as(u32, 4);
pub const DISPID_XMLDOM_PROCESSOR = @as(u32, 1);
pub const DISPID_XMLDOM_PROCESSOR_INPUT = @as(u32, 2);
pub const DISPID_XMLDOM_PROCESSOR_XSLTEMPLATE = @as(u32, 3);
pub const DISPID_XMLDOM_PROCESSOR_SETSTARTMODE = @as(u32, 4);
pub const DISPID_XMLDOM_PROCESSOR_STARTMODE = @as(u32, 5);
pub const DISPID_XMLDOM_PROCESSOR_STARTMODEURI = @as(u32, 6);
pub const DISPID_XMLDOM_PROCESSOR_OUTPUT = @as(u32, 7);
pub const DISPID_XMLDOM_PROCESSOR_TRANSFORM = @as(u32, 8);
pub const DISPID_XMLDOM_PROCESSOR_RESET = @as(u32, 9);
pub const DISPID_XMLDOM_PROCESSOR_READYSTATE = @as(u32, 10);
pub const DISPID_XMLDOM_PROCESSOR_ADDPARAMETER = @as(u32, 11);
pub const DISPID_XMLDOM_PROCESSOR_ADDOBJECT = @as(u32, 12);
pub const DISPID_XMLDOM_PROCESSOR_STYLESHEET = @as(u32, 13);
pub const DISPID_XMLDOM_PROCESSOR__TOP = @as(u32, 14);
pub const DISPID_XMLDSO = @as(u32, 65536);
pub const DISPID_XMLDSO_DOCUMENT = @as(u32, 65537);
pub const DISPID_XMLDSO_JAVADSOCOMPATIBLE = @as(u32, 65538);
pub const DISPID_SAX_XMLREADER__MIN = @as(u32, 1281);
pub const DISPID_SAX_XMLREADER__MAX = @as(u32, 65536);
pub const DISPID_SAX_XMLREADER__BASE = @as(u32, 1281);
pub const DISPID_SAX_XMLREADER = @as(u32, 1281);
pub const DISPID_SAX_XMLREADER_GETFEATURE = @as(u32, 1282);
pub const DISPID_SAX_XMLREADER_PUTFEATURE = @as(u32, 1283);
pub const DISPID_SAX_XMLREADER_GETPROPERTY = @as(u32, 1284);
pub const DISPID_SAX_XMLREADER_PUTPROPERTY = @as(u32, 1285);
pub const DISPID_SAX_XMLREADER_ENTITYRESOLVER = @as(u32, 1286);
pub const DISPID_SAX_XMLREADER_CONTENTHANDLER = @as(u32, 1287);
pub const DISPID_SAX_XMLREADER_DTDHANDLER = @as(u32, 1288);
pub const DISPID_SAX_XMLREADER_ERRORHANDLER = @as(u32, 1289);
pub const DISPID_SAX_XMLREADER_BASEURL = @as(u32, 1290);
pub const DISPID_SAX_XMLREADER_SECUREBASEURL = @as(u32, 1291);
pub const DISPID_SAX_XMLREADER_PARSE = @as(u32, 1292);
pub const DISPID_SAX_XMLREADER_PARSEURL = @as(u32, 1293);
pub const DISPID_SAX_XMLREADER_PARENT = @as(u32, 1294);
pub const DISPID_SAX_XMLREADER__TOP = @as(u32, 1295);
pub const DISPID_SAX_XMLFILTER__BASE = @as(u32, 1296);
pub const DISPID_SAX_XMLFILTER = @as(u32, 1296);
pub const DISPID_SAX_XMLFILTER_GETFEATURE = @as(u32, 1297);
pub const DISPID_SAX_XMLFILTER_PUTFEATURE = @as(u32, 1298);
pub const DISPID_SAX_XMLFILTER_GETPROPERTY = @as(u32, 1299);
pub const DISPID_SAX_XMLFILTER_PUTPROPERTY = @as(u32, 1300);
pub const DISPID_SAX_XMLFILTER_ENTITYRESOLVER = @as(u32, 1301);
pub const DISPID_SAX_XMLFILTER_CONTENTHANDLER = @as(u32, 1302);
pub const DISPID_SAX_XMLFILTER_DTDHANDLER = @as(u32, 1303);
pub const DISPID_SAX_XMLFILTER_ERRORHANDLER = @as(u32, 1304);
pub const DISPID_SAX_XMLFILTER_BASEURL = @as(u32, 1305);
pub const DISPID_SAX_XMLFILTER_SECUREBASEURL = @as(u32, 1306);
pub const DISPID_SAX_XMLFILTER_PARSE = @as(u32, 1307);
pub const DISPID_SAX_XMLFILTER_PARSEURL = @as(u32, 1308);
pub const DISPID_SAX_XMLFILTER_PARENT = @as(u32, 1309);
pub const DISPID_SAX_XMLFILTER__TOP = @as(u32, 1311);
pub const DISPID_SAX_LOCATOR__BASE = @as(u32, 1312);
pub const DISPID_SAX_LOCATOR = @as(u32, 1312);
pub const DISPID_SAX_LOCATOR_COLUMNNUMBER = @as(u32, 1313);
pub const DISPID_SAX_LOCATOR_LINENUMBER = @as(u32, 1314);
pub const DISPID_SAX_LOCATOR_PUBLICID = @as(u32, 1315);
pub const DISPID_SAX_LOCATOR_SYSTEMID = @as(u32, 1316);
pub const DISPID_SAX_LOCATOR__TOP = @as(u32, 1317);
pub const DISPID_SAX_ENTITYRESOLVER__BASE = @as(u32, 1318);
pub const DISPID_SAX_ENTITYRESOLVER = @as(u32, 1318);
pub const DISPID_SAX_ENTITYRESOLVER_RESOLVEENTITY = @as(u32, 1319);
pub const DISPID_SAX_ENTITYRESOLVER__TOP = @as(u32, 1320);
pub const DISPID_SAX_CONTENTHANDLER__BASE = @as(u32, 1321);
pub const DISPID_SAX_CONTENTHANDLER = @as(u32, 1321);
pub const DISPID_SAX_CONTENTHANDLER_DOCUMENTLOCATOR = @as(u32, 1322);
pub const DISPID_SAX_CONTENTHANDLER_STARTDOCUMENT = @as(u32, 1323);
pub const DISPID_SAX_CONTENTHANDLER_ENDDOCUMENT = @as(u32, 1324);
pub const DISPID_SAX_CONTENTHANDLER_STARTPREFIXMAPPING = @as(u32, 1325);
pub const DISPID_SAX_CONTENTHANDLER_ENDPREFIXMAPPING = @as(u32, 1326);
pub const DISPID_SAX_CONTENTHANDLER_STARTELEMENT = @as(u32, 1327);
pub const DISPID_SAX_CONTENTHANDLER_ENDELEMENT = @as(u32, 1328);
pub const DISPID_SAX_CONTENTHANDLER_CHARACTERS = @as(u32, 1329);
pub const DISPID_SAX_CONTENTHANDLER_IGNORABLEWHITESPACE = @as(u32, 1330);
pub const DISPID_SAX_CONTENTHANDLER_PROCESSINGINSTRUCTION = @as(u32, 1331);
pub const DISPID_SAX_CONTENTHANDLER_SKIPPEDENTITY = @as(u32, 1332);
pub const DISPID_SAX_CONTENTHANDLER__TOP = @as(u32, 1333);
pub const DISPID_SAX_DTDHANDLER__BASE = @as(u32, 1334);
pub const DISPID_SAX_DTDHANDLER = @as(u32, 1334);
pub const DISPID_SAX_DTDHANDLER_NOTATIONDECL = @as(u32, 1335);
pub const DISPID_SAX_DTDHANDLER_UNPARSEDENTITYDECL = @as(u32, 1336);
pub const DISPID_SAX_DTDHANDLER__TOP = @as(u32, 1337);
pub const DISPID_SAX_ERRORHANDLER__BASE = @as(u32, 1338);
pub const DISPID_SAX_ERRORHANDLER = @as(u32, 1338);
pub const DISPID_SAX_ERRORHANDLER_ERROR = @as(u32, 1339);
pub const DISPID_SAX_ERRORHANDLER_FATALERROR = @as(u32, 1340);
pub const DISPID_SAX_ERRORHANDLER_IGNORABLEWARNING = @as(u32, 1341);
pub const DISPID_SAX_ERRORHANDLER__TOP = @as(u32, 1342);
pub const DISPID_SAX_ATTRIBUTES__BASE = @as(u32, 1343);
pub const DISPID_SAX_ATTRIBUTES = @as(u32, 1343);
pub const DISPID_SAX_ATTRIBUTES_LENGTH = @as(u32, 1344);
pub const DISPID_SAX_ATTRIBUTES_GETURI = @as(u32, 1345);
pub const DISPID_SAX_ATTRIBUTES_GETLOCALNAME = @as(u32, 1346);
pub const DISPID_SAX_ATTRIBUTES_GETQNAME = @as(u32, 1347);
pub const DISPID_SAX_ATTRIBUTES_GETINDEXFROMNAME = @as(u32, 1348);
pub const DISPID_SAX_ATTRIBUTES_GETINDEXFROMQNAME = @as(u32, 1349);
pub const DISPID_SAX_ATTRIBUTES_GETTYPE = @as(u32, 1350);
pub const DISPID_SAX_ATTRIBUTES_GETTYPEFROMNAME = @as(u32, 1351);
pub const DISPID_SAX_ATTRIBUTES_GETTYPEFROMQNAME = @as(u32, 1352);
pub const DISPID_SAX_ATTRIBUTES_GETVALUE = @as(u32, 1353);
pub const DISPID_SAX_ATTRIBUTES_GETVALUEFROMNAME = @as(u32, 1354);
pub const DISPID_SAX_ATTRIBUTES_GETVALUEFROMQNAME = @as(u32, 1355);
pub const DISPID_SAX_ATTRIBUTES__TOP = @as(u32, 1356);
pub const DISPID_SAX_LEXICALHANDLER__BASE = @as(u32, 1357);
pub const DISPID_SAX_LEXICALHANDLER = @as(u32, 1357);
pub const DISPID_SAX_LEXICALHANDLER_STARTDTD = @as(u32, 1358);
pub const DISPID_SAX_LEXICALHANDLER_ENDDTD = @as(u32, 1359);
pub const DISPID_SAX_LEXICALHANDLER_STARTENTITY = @as(u32, 1360);
pub const DISPID_SAX_LEXICALHANDLER_ENDENTITY = @as(u32, 1361);
pub const DISPID_SAX_LEXICALHANDLER_STARTCDATA = @as(u32, 1362);
pub const DISPID_SAX_LEXICALHANDLER_ENDCDATA = @as(u32, 1363);
pub const DISPID_SAX_LEXICALHANDLER_COMMENT = @as(u32, 1364);
pub const DISPID_SAX_LEXICALHANDLER__TOP = @as(u32, 1365);
pub const DISPID_SAX_DECLHANDLER__BASE = @as(u32, 1366);
pub const DISPID_SAX_DECLHANDLER = @as(u32, 1366);
pub const DISPID_SAX_DECLHANDLER_ELEMENTDECL = @as(u32, 1367);
pub const DISPID_SAX_DECLHANDLER_ATTRIBUTEDECL = @as(u32, 1368);
pub const DISPID_SAX_DECLHANDLER_INTERNALENTITYDECL = @as(u32, 1369);
pub const DISPID_SAX_DECLHANDLER_EXTERNALENTITYDECL = @as(u32, 1370);
pub const DISPID_SAX_DECLHANDLER__TOP = @as(u32, 1371);
pub const DISPID_MX_ATTRIBUTES__BASE = @as(u32, 1372);
pub const DISPID_MX_ATTRIBUTES = @as(u32, 1372);
pub const DISPID_MX_ATTRIBUTES_ADDATTRIBUTE = @as(u32, 1373);
pub const DISPID_MX_ATTRIBUTES_CLEAR = @as(u32, 1374);
pub const DISPID_MX_ATTRIBUTES_REMOVEATTRIBUTE = @as(u32, 1375);
pub const DISPID_MX_ATTRIBUTES_SETATTRIBUTE = @as(u32, 1376);
pub const DISPID_MX_ATTRIBUTES_SETATTRIBUTES = @as(u32, 1377);
pub const DISPID_MX_ATTRIBUTES_SETLOCALNAME = @as(u32, 1378);
pub const DISPID_MX_ATTRIBUTES_SETQNAME = @as(u32, 1379);
pub const DISPID_MX_ATTRIBUTES_SETTYPE = @as(u32, 1380);
pub const DISPID_MX_ATTRIBUTES_SETURI = @as(u32, 1381);
pub const DISPID_MX_ATTRIBUTES_SETVALUE = @as(u32, 1382);
pub const DISPID_MX_ATTRIBUTES_ADDATTRIBUTEFROMINDEX = @as(u32, 1383);
pub const DISPID_MX_ATTRIBUTES__TOP = @as(u32, 1383);
pub const DISPID_MX_WRITER__BASE = @as(u32, 1384);
pub const DISPID_MX_WRITER = @as(u32, 1384);
pub const DISPID_MX_WRITER_OUTPUT = @as(u32, 1385);
pub const DISPID_MX_WRITER_DESTINATION = @as(u32, 1386);
pub const DISPID_MX_WRITER_ENCODING = @as(u32, 1387);
pub const DISPID_MX_WRITER_BYTEORDERMARK = @as(u32, 1388);
pub const DISPID_MX_WRITER_INDENT = @as(u32, 1389);
pub const DISPID_MX_WRITER_STANDALONE = @as(u32, 1390);
pub const DISPID_MX_WRITER_OMITXMLDECLARATION = @as(u32, 1391);
pub const DISPID_MX_WRITER_VERSION = @as(u32, 1392);
pub const DISPID_MX_WRITER_DISABLEOUTPUTESCAPING = @as(u32, 1393);
pub const DISPID_MX_WRITER_FLUSH = @as(u32, 1394);
pub const DISPID_MX_WRITER_RESET = @as(u32, 1395);
pub const DISPID_MX_WRITER__TOP = @as(u32, 1396);
pub const DISPID_MX_READER_CONTROL__BASE = @as(u32, 1397);
pub const DISPID_MX_READER_CONTROL = @as(u32, 1397);
pub const DISPID_MX_READER_CONTROL_ABORT = @as(u32, 1398);
pub const DISPID_MX_READER_CONTROL_RESUME = @as(u32, 1399);
pub const DISPID_MX_READER_CONTROL_SUSPEND = @as(u32, 1400);
pub const DISPID_MX_READER_CONTROL__TOP = @as(u32, 1401);
pub const DISPID_MX_SCHEMADECLHANDLER__BASE = @as(u32, 1402);
pub const DISPID_MX_SCHEMADECLHANDLER = @as(u32, 1402);
pub const DISPID_MX_SCHEMADECLHANDLER_SCHEMAELEMENTDECL = @as(u32, 1403);
pub const DISPID_MX_SCHEMADECLHANDLER__TOP = @as(u32, 1404);
pub const DISPID_MX_NSMGR__BASE = @as(u32, 1405);
pub const DISPID_MX_NSMGR = @as(u32, 1405);
pub const DISPID_MX_NSMGR_ALLOWOVERRIDE = @as(u32, 1406);
pub const DISPID_MX_NSMGR_RESET = @as(u32, 1407);
pub const DISPID_MX_NSMGR_PUSHCONTEXT = @as(u32, 1408);
pub const DISPID_MX_NSMGR_PUSHNODECONTEXT = @as(u32, 1409);
pub const DISPID_MX_NSMGR_POPCONTEXT = @as(u32, 1410);
pub const DISPID_MX_NSMGR_DECLAREPREFIX = @as(u32, 1411);
pub const DISPID_MX_NSMGR_GETDECLAREDPREFIXES = @as(u32, 1412);
pub const DISPID_MX_NSMGR_GETPREFIXES = @as(u32, 1413);
pub const DISPID_MX_NSMGR_GETURI = @as(u32, 1414);
pub const DISPID_MX_NSMGR_GETURIFROMNODE = @as(u32, 1415);
pub const DISPID_MX_NSMGR_LENGTH = @as(u32, 1416);
pub const DISPID_MX_NSMGR__TOP = @as(u32, 1417);
pub const DISPID_MXXML_FILTER__BASE = @as(u32, 1418);
pub const DISPID_MXXML_FILTER = @as(u32, 1418);
pub const DISPID_MXXML_FILTER_CONTENTHANDLER = @as(u32, 1419);
pub const DISPID_MXXML_FILTER_DTDHANDLER = @as(u32, 1420);
pub const DISPID_MXXML_FILTER_ENTITYRESOLVER = @as(u32, 1421);
pub const DISPID_MXXML_FILTER_ERRORHANDLER = @as(u32, 1422);
pub const DISPID_MXXML_FILTER_GETFEATURE = @as(u32, 1423);
pub const DISPID_MXXML_FILTER_GETPROPERTY = @as(u32, 1424);
pub const DISPID_MXXML_FILTER_PUTFEATURE = @as(u32, 1425);
pub const DISPID_MXXML_FILTER_PUTPROPERTY = @as(u32, 1426);
pub const DISPID_MXXML_FILTER__TOP = @as(u32, 1427);
pub const DISPID_SOM = @as(u32, 1418);
pub const DISPID_SOM_VALIDATE = @as(u32, 1419);
pub const DISPID_SOM_VALIDATEONLOAD = @as(u32, 1420);
pub const DISPID_SOM_GETSCHEMA = @as(u32, 1421);
pub const DISPID_SOM_GETDECLARATION = @as(u32, 1422);
pub const DISPID_SOM_ITEMBYNAME = @as(u32, 1423);
pub const DISPID_SOM_ITEMBYQNAME = @as(u32, 1424);
pub const DISPID_SOM_ANYATTRIBUTE = @as(u32, 1425);
pub const DISPID_SOM_ATTRIBUTEGROUPS = @as(u32, 1426);
pub const DISPID_SOM_ATTRIBUTES = @as(u32, 1427);
pub const DISPID_SOM_BASETYPES = @as(u32, 1428);
pub const DISPID_SOM_CONTENTMODEL = @as(u32, 1429);
pub const DISPID_SOM_CONTENTTYPE = @as(u32, 1430);
pub const DISPID_SOM_DEFAULTVALUE = @as(u32, 1431);
pub const DISPID_SOM_DERIVEDBY = @as(u32, 1432);
pub const DISPID_SOM_DISALLOWED = @as(u32, 1433);
pub const DISPID_SOM_ELEMENTS = @as(u32, 1434);
pub const DISPID_SOM_ENUMERATION = @as(u32, 1435);
pub const DISPID_SOM_FIELDS = @as(u32, 1436);
pub const DISPID_SOM_FINAL = @as(u32, 1437);
pub const DISPID_SOM_FIXEDVALUE = @as(u32, 1438);
pub const DISPID_SOM_FRACTIONDIGITS = @as(u32, 1439);
pub const DISPID_SOM_ID = @as(u32, 1440);
pub const DISPID_SOM_IDCONSTRAINTS = @as(u32, 1441);
pub const DISPID_SOM_ISABSTRACT = @as(u32, 1442);
pub const DISPID_SOM_ISNILLABLE = @as(u32, 1443);
pub const DISPID_SOM_ISREFERENCE = @as(u32, 1444);
pub const DISPID_SOM_ISVALID = @as(u32, 1445);
pub const DISPID_SOM_ITEMTYPE = @as(u32, 1446);
pub const DISPID_SOM_LENGTH = @as(u32, 1447);
pub const DISPID_SOM_MAXEXCLUSIVE = @as(u32, 1448);
pub const DISPID_SOM_MAXINCLUSIVE = @as(u32, 1449);
pub const DISPID_SOM_MAXLENGTH = @as(u32, 1450);
pub const DISPID_SOM_MAXOCCURS = @as(u32, 1451);
pub const DISPID_SOM_MINEXCLUSIVE = @as(u32, 1452);
pub const DISPID_SOM_MININCLUSIVE = @as(u32, 1453);
pub const DISPID_SOM_MINLENGTH = @as(u32, 1454);
pub const DISPID_SOM_MINOCCURS = @as(u32, 1455);
pub const DISPID_SOM_MODELGROUPS = @as(u32, 1456);
pub const DISPID_SOM_NAME = @as(u32, 1457);
pub const DISPID_SOM_NAMESPACES = @as(u32, 1458);
pub const DISPID_SOM_NAMESPACEURI = @as(u32, 1459);
pub const DISPID_SOM_NOTATIONS = @as(u32, 1460);
pub const DISPID_SOM_PARTICLES = @as(u32, 1461);
pub const DISPID_SOM_PATTERNS = @as(u32, 1462);
pub const DISPID_SOM_PROCESSCONTENTS = @as(u32, 1463);
pub const DISPID_SOM_PROHIBITED = @as(u32, 1464);
pub const DISPID_SOM_PUBLICIDENTIFIER = @as(u32, 1465);
pub const DISPID_SOM_REFERENCEDKEY = @as(u32, 1466);
pub const DISPID_SOM_SCHEMA = @as(u32, 1467);
pub const DISPID_SOM_SCHEMALOCATIONS = @as(u32, 1468);
pub const DISPID_SOM_SCOPE = @as(u32, 1469);
pub const DISPID_SOM_SELECTOR = @as(u32, 1470);
pub const DISPID_SOM_SUBSTITUTIONGROUP = @as(u32, 1471);
pub const DISPID_SOM_EXCLUSIONS = @as(u32, 1472);
pub const DISPID_SOM_SYSTEMIDENTIFIER = @as(u32, 1473);
pub const DISPID_SOM_TARGETNAMESPACE = @as(u32, 1474);
pub const DISPID_SOM_TOTALDIGITS = @as(u32, 1475);
pub const DISPID_SOM_TYPE = @as(u32, 1476);
pub const DISPID_SOM_TYPES = @as(u32, 1477);
pub const DISPID_SOM_UNHANDLEDATTRS = @as(u32, 1478);
pub const DISPID_SOM_USE = @as(u32, 1479);
pub const DISPID_SOM_VARIETY = @as(u32, 1480);
pub const DISPID_SOM_VERSION = @as(u32, 1481);
pub const DISPID_SOM_WHITESPACE = @as(u32, 1482);
pub const DISPID_SOM_WRITEANNOTATION = @as(u32, 1483);
pub const DISPID_SOM_TOP = @as(u32, 1484);
pub const DISPID_XMLDSIG = @as(u32, 1);
pub const DISPID_XMLDSIG_CREATEKEYFROMCSP = @as(u32, 1);
pub const DISPID_XMLDSIG_CREATEKEYFROMHMACSECRET = @as(u32, 2);
pub const DISPID_XMLDSIG_CREATEKEYFROMNODE = @as(u32, 3);
pub const DISPID_XMLDSIG_CREATESAXPROXY = @as(u32, 4);
pub const DISPID_XMLDSIG_GETVERIFYINGCERTIFICATE = @as(u32, 5);
pub const DISPID_XMLDSIG_SETREFERENCEDATA = @as(u32, 6);
pub const DISPID_XMLDSIG_SIGN = @as(u32, 7);
pub const DISPID_XMLDSIG_SIGNATURE = @as(u32, 8);
pub const DISPID_XMLDSIG_STORE = @as(u32, 9);
pub const DISPID_XMLDSIG_VERIFY = @as(u32, 10);

//--------------------------------------------------------------------------------
// Section: Types (127)
//--------------------------------------------------------------------------------
const CLSID_DOMDocument_Value = Guid.initString("2933bf90-7b36-11d2-b20e-00c04f983e60");
pub const CLSID_DOMDocument = &CLSID_DOMDocument_Value;

const CLSID_DOMFreeThreadedDocument_Value = Guid.initString("2933bf91-7b36-11d2-b20e-00c04f983e60");
pub const CLSID_DOMFreeThreadedDocument = &CLSID_DOMFreeThreadedDocument_Value;

const CLSID_XMLHTTPRequest_Value = Guid.initString("ed8c108e-4349-11d2-91a4-00c04f7969e8");
pub const CLSID_XMLHTTPRequest = &CLSID_XMLHTTPRequest_Value;

const CLSID_XMLDSOControl_Value = Guid.initString("550dda30-0541-11d2-9ca9-0060b0ec3d39");
pub const CLSID_XMLDSOControl = &CLSID_XMLDSOControl_Value;

const CLSID_XMLDocument_Value = Guid.initString("cfc399af-d876-11d0-9c10-00c04fc99c8e");
pub const CLSID_XMLDocument = &CLSID_XMLDocument_Value;

pub const XML_ERROR = extern struct {
    _nLine: u32,
    _pchBuf: ?BSTR,
    _cchBuf: u32,
    _ich: u32,
    _pszFound: ?BSTR,
    _pszExpected: ?BSTR,
    _reserved1: u32,
    _reserved2: u32,
};

pub const DOMNodeType = enum(i32) {
    INVALID = 0,
    ELEMENT = 1,
    ATTRIBUTE = 2,
    TEXT = 3,
    CDATA_SECTION = 4,
    ENTITY_REFERENCE = 5,
    ENTITY = 6,
    PROCESSING_INSTRUCTION = 7,
    COMMENT = 8,
    DOCUMENT = 9,
    DOCUMENT_TYPE = 10,
    DOCUMENT_FRAGMENT = 11,
    NOTATION = 12,
};
pub const NODE_INVALID = DOMNodeType.INVALID;
pub const NODE_ELEMENT = DOMNodeType.ELEMENT;
pub const NODE_ATTRIBUTE = DOMNodeType.ATTRIBUTE;
pub const NODE_TEXT = DOMNodeType.TEXT;
pub const NODE_CDATA_SECTION = DOMNodeType.CDATA_SECTION;
pub const NODE_ENTITY_REFERENCE = DOMNodeType.ENTITY_REFERENCE;
pub const NODE_ENTITY = DOMNodeType.ENTITY;
pub const NODE_PROCESSING_INSTRUCTION = DOMNodeType.PROCESSING_INSTRUCTION;
pub const NODE_COMMENT = DOMNodeType.COMMENT;
pub const NODE_DOCUMENT = DOMNodeType.DOCUMENT;
pub const NODE_DOCUMENT_TYPE = DOMNodeType.DOCUMENT_TYPE;
pub const NODE_DOCUMENT_FRAGMENT = DOMNodeType.DOCUMENT_FRAGMENT;
pub const NODE_NOTATION = DOMNodeType.NOTATION;

pub const XMLEMEM_TYPE = enum(i32) {
    ELEMENT = 0,
    TEXT = 1,
    COMMENT = 2,
    DOCUMENT = 3,
    DTD = 4,
    PI = 5,
    OTHER = 6,
};
pub const XMLELEMTYPE_ELEMENT = XMLEMEM_TYPE.ELEMENT;
pub const XMLELEMTYPE_TEXT = XMLEMEM_TYPE.TEXT;
pub const XMLELEMTYPE_COMMENT = XMLEMEM_TYPE.COMMENT;
pub const XMLELEMTYPE_DOCUMENT = XMLEMEM_TYPE.DOCUMENT;
pub const XMLELEMTYPE_DTD = XMLEMEM_TYPE.DTD;
pub const XMLELEMTYPE_PI = XMLEMEM_TYPE.PI;
pub const XMLELEMTYPE_OTHER = XMLEMEM_TYPE.OTHER;

const IID_IXMLDOMImplementation_Value = Guid.initString("2933bf8f-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMImplementation = &IID_IXMLDOMImplementation_Value;
pub const IXMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        hasFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMImplementation,
                feature: ?BSTR,
                version: ?BSTR,
                hasFeature: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMImplementation,
                feature: ?BSTR,
                version: ?BSTR,
                hasFeature: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMImplementation_hasFeature(self: *const T, feature: ?BSTR, version: ?BSTR, hasFeature: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMImplementation.VTable, @ptrCast(self.vtable)).hasFeature(@as(*const IXMLDOMImplementation, @ptrCast(self)), feature, version, hasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNode_Value = Guid.initString("2933bf80-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNode = &IID_IXMLDOMNode_Value;
pub const IXMLDOMNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                type: ?*DOMNodeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                type: ?*DOMNodeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parentNode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                parent: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                parent: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_childNodes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                childList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                childList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_firstChild: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                firstChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                firstChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lastChild: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                lastChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                lastChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_previousSibling: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                previousSibling: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                previousSibling: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextSibling: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                nextSibling: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                nextSibling: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                attributeMap: ?*?*IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                attributeMap: ?*?*IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        insertBefore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                newChild: ?*IXMLDOMNode,
                refChild: VARIANT,
                outNewChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                newChild: ?*IXMLDOMNode,
                refChild: VARIANT,
                outNewChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        replaceChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                newChild: ?*IXMLDOMNode,
                oldChild: ?*IXMLDOMNode,
                outOldChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                newChild: ?*IXMLDOMNode,
                oldChild: ?*IXMLDOMNode,
                outOldChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                childNode: ?*IXMLDOMNode,
                oldChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                childNode: ?*IXMLDOMNode,
                oldChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        appendChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                newChild: ?*IXMLDOMNode,
                outNewChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                newChild: ?*IXMLDOMNode,
                outNewChild: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        hasChildNodes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                hasChild: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                hasChild: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerDocument: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                XMLDOMDocument: ?*?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                XMLDOMDocument: ?*?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        cloneNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                deep: i16,
                cloneRoot: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                deep: i16,
                cloneRoot: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeTypeString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                nodeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                nodeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                text: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                text: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                text: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_specified: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                isSpecified: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                isSpecified: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_definition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                definitionNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                definitionNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nodeTypedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                typedValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                typedValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nodeTypedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                typedValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                typedValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dataType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                dataTypeName: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                dataTypeName: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dataType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                dataTypeName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                dataTypeName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_xml: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                xmlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                xmlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        transformNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                stylesheet: ?*IXMLDOMNode,
                xmlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                stylesheet: ?*IXMLDOMNode,
                xmlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        selectNodes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                queryString: ?BSTR,
                resultList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                queryString: ?BSTR,
                resultList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        selectSingleNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                queryString: ?BSTR,
                resultNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                queryString: ?BSTR,
                resultNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parsed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                isParsed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                isParsed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                namespaceURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                namespaceURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prefix: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                prefixString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                prefixString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNode,
                nameString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNode,
                nameString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        transformNodeToObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNode,
                stylesheet: ?*IXMLDOMNode,
                outputObject: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNode,
                stylesheet: ?*IXMLDOMNode,
                outputObject: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_nodeName(@as(*const IXMLDOMNode, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_nodeValue(@as(*const IXMLDOMNode, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_nodeValue(self: *const T, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).put_nodeValue(@as(*const IXMLDOMNode, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeType(self: *const T, type_: ?*DOMNodeType) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_nodeType(@as(*const IXMLDOMNode, @ptrCast(self)), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_parentNode(self: *const T, parent: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_parentNode(@as(*const IXMLDOMNode, @ptrCast(self)), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_childNodes(self: *const T, childList: ?*?*IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_childNodes(@as(*const IXMLDOMNode, @ptrCast(self)), childList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_firstChild(self: *const T, firstChild: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_firstChild(@as(*const IXMLDOMNode, @ptrCast(self)), firstChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_lastChild(self: *const T, lastChild: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_lastChild(@as(*const IXMLDOMNode, @ptrCast(self)), lastChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_previousSibling(self: *const T, previousSibling: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_previousSibling(@as(*const IXMLDOMNode, @ptrCast(self)), previousSibling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nextSibling(self: *const T, nextSibling: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_nextSibling(@as(*const IXMLDOMNode, @ptrCast(self)), nextSibling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_attributes(self: *const T, attributeMap: ?*?*IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_attributes(@as(*const IXMLDOMNode, @ptrCast(self)), attributeMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_insertBefore(self: *const T, newChild: ?*IXMLDOMNode, refChild: VARIANT, outNewChild: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).insertBefore(@as(*const IXMLDOMNode, @ptrCast(self)), newChild, refChild, outNewChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_replaceChild(self: *const T, newChild: ?*IXMLDOMNode, oldChild: ?*IXMLDOMNode, outOldChild: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).replaceChild(@as(*const IXMLDOMNode, @ptrCast(self)), newChild, oldChild, outOldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_removeChild(self: *const T, childNode: ?*IXMLDOMNode, oldChild: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).removeChild(@as(*const IXMLDOMNode, @ptrCast(self)), childNode, oldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_appendChild(self: *const T, newChild: ?*IXMLDOMNode, outNewChild: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).appendChild(@as(*const IXMLDOMNode, @ptrCast(self)), newChild, outNewChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_hasChildNodes(self: *const T, hasChild: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).hasChildNodes(@as(*const IXMLDOMNode, @ptrCast(self)), hasChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_ownerDocument(self: *const T, XMLDOMDocument: ?*?*IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_ownerDocument(@as(*const IXMLDOMNode, @ptrCast(self)), XMLDOMDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_cloneNode(self: *const T, deep: i16, cloneRoot: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).cloneNode(@as(*const IXMLDOMNode, @ptrCast(self)), deep, cloneRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeTypeString(self: *const T, nodeType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_nodeTypeString(@as(*const IXMLDOMNode, @ptrCast(self)), nodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_text(self: *const T, text: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_text(@as(*const IXMLDOMNode, @ptrCast(self)), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_text(self: *const T, text: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).put_text(@as(*const IXMLDOMNode, @ptrCast(self)), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_specified(self: *const T, isSpecified: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_specified(@as(*const IXMLDOMNode, @ptrCast(self)), isSpecified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_definition(self: *const T, definitionNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_definition(@as(*const IXMLDOMNode, @ptrCast(self)), definitionNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeTypedValue(self: *const T, typedValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_nodeTypedValue(@as(*const IXMLDOMNode, @ptrCast(self)), typedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_nodeTypedValue(self: *const T, typedValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).put_nodeTypedValue(@as(*const IXMLDOMNode, @ptrCast(self)), typedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_dataType(self: *const T, dataTypeName: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_dataType(@as(*const IXMLDOMNode, @ptrCast(self)), dataTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_dataType(self: *const T, dataTypeName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).put_dataType(@as(*const IXMLDOMNode, @ptrCast(self)), dataTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_xml(self: *const T, xmlString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_xml(@as(*const IXMLDOMNode, @ptrCast(self)), xmlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_transformNode(self: *const T, stylesheet: ?*IXMLDOMNode, xmlString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).transformNode(@as(*const IXMLDOMNode, @ptrCast(self)), stylesheet, xmlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_selectNodes(self: *const T, queryString: ?BSTR, resultList: ?*?*IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).selectNodes(@as(*const IXMLDOMNode, @ptrCast(self)), queryString, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_selectSingleNode(self: *const T, queryString: ?BSTR, resultNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).selectSingleNode(@as(*const IXMLDOMNode, @ptrCast(self)), queryString, resultNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_parsed(self: *const T, isParsed: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_parsed(@as(*const IXMLDOMNode, @ptrCast(self)), isParsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_namespaceURI(self: *const T, namespaceURI: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_namespaceURI(@as(*const IXMLDOMNode, @ptrCast(self)), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_prefix(self: *const T, prefixString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_prefix(@as(*const IXMLDOMNode, @ptrCast(self)), prefixString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_baseName(self: *const T, nameString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).get_baseName(@as(*const IXMLDOMNode, @ptrCast(self)), nameString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_transformNodeToObject(self: *const T, stylesheet: ?*IXMLDOMNode, outputObject: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNode.VTable, @ptrCast(self.vtable)).transformNodeToObject(@as(*const IXMLDOMNode, @ptrCast(self)), stylesheet, outputObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocumentFragment_Value = Guid.initString("3efaa413-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMDocumentFragment = &IID_IXMLDOMDocumentFragment_Value;
pub const IXMLDOMDocumentFragment = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocument_Value = Guid.initString("2933bf81-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocument = &IID_IXMLDOMDocument_Value;
pub const IXMLDOMDocument = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                documentType: ?*?*IXMLDOMDocumentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                documentType: ?*?*IXMLDOMDocumentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_implementation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                impl: ?*?*IXMLDOMImplementation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                impl: ?*?*IXMLDOMImplementation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_documentElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                DOMElement: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                DOMElement: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_documentElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                DOMElement: ?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                DOMElement: ?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                tagName: ?BSTR,
                element: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                tagName: ?BSTR,
                element: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createDocumentFragment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                docFrag: ?*?*IXMLDOMDocumentFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                docFrag: ?*?*IXMLDOMDocumentFragment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createTextNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                data: ?BSTR,
                text: ?*?*IXMLDOMText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                data: ?BSTR,
                text: ?*?*IXMLDOMText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createComment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                data: ?BSTR,
                comment: ?*?*IXMLDOMComment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                data: ?BSTR,
                comment: ?*?*IXMLDOMComment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createCDATASection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                data: ?BSTR,
                cdata: ?*?*IXMLDOMCDATASection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                data: ?BSTR,
                cdata: ?*?*IXMLDOMCDATASection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createProcessingInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                target: ?BSTR,
                data: ?BSTR,
                pi: ?*?*IXMLDOMProcessingInstruction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                target: ?BSTR,
                data: ?BSTR,
                pi: ?*?*IXMLDOMProcessingInstruction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                name: ?BSTR,
                attribute: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                name: ?BSTR,
                attribute: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createEntityReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                name: ?BSTR,
                entityRef: ?*?*IXMLDOMEntityReference,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                name: ?BSTR,
                entityRef: ?*?*IXMLDOMEntityReference,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getElementsByTagName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                tagName: ?BSTR,
                resultList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                tagName: ?BSTR,
                resultList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                Type: VARIANT,
                name: ?BSTR,
                namespaceURI: ?BSTR,
                node: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                Type: VARIANT,
                name: ?BSTR,
                namespaceURI: ?BSTR,
                node: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        nodeFromID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                idString: ?BSTR,
                node: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                idString: ?BSTR,
                node: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                xmlSource: VARIANT,
                isSuccessful: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                xmlSource: VARIANT,
                isSuccessful: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parseError: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                errorObj: ?*?*IXMLDOMParseError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                errorObj: ?*?*IXMLDOMParseError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                urlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                urlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_async: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isAsync: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isAsync: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_async: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isAsync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isAsync: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        loadXML: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                bstrXML: ?BSTR,
                isSuccessful: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                bstrXML: ?BSTR,
                isSuccessful: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                destination: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument,
                destination: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_validateOnParse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isValidating: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isValidating: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_validateOnParse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isValidating: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isValidating: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_resolveExternals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isResolving: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isResolving: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_resolveExternals: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isResolving: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isResolving: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_preserveWhiteSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isPreserving: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isPreserving: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_preserveWhiteSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                isPreserving: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                isPreserving: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                readystatechangeSink: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                readystatechangeSink: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ondataavailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                ondataavailableSink: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                ondataavailableSink: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ontransformnode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument,
                ontransformnodeSink: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument,
                ontransformnodeSink: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_doctype(self: *const T, documentType: ?*?*IXMLDOMDocumentType) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_doctype(@as(*const IXMLDOMDocument, @ptrCast(self)), documentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_implementation(self: *const T, impl: ?*?*IXMLDOMImplementation) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_implementation(@as(*const IXMLDOMDocument, @ptrCast(self)), impl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_documentElement(self: *const T, DOMElement: ?*?*IXMLDOMElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_documentElement(@as(*const IXMLDOMDocument, @ptrCast(self)), DOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_putref_documentElement(self: *const T, DOMElement: ?*IXMLDOMElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).putref_documentElement(@as(*const IXMLDOMDocument, @ptrCast(self)), DOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createElement(self: *const T, tagName: ?BSTR, element: ?*?*IXMLDOMElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createElement(@as(*const IXMLDOMDocument, @ptrCast(self)), tagName, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createDocumentFragment(self: *const T, docFrag: ?*?*IXMLDOMDocumentFragment) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createDocumentFragment(@as(*const IXMLDOMDocument, @ptrCast(self)), docFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createTextNode(self: *const T, data: ?BSTR, text: ?*?*IXMLDOMText) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createTextNode(@as(*const IXMLDOMDocument, @ptrCast(self)), data, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createComment(self: *const T, data: ?BSTR, comment: ?*?*IXMLDOMComment) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createComment(@as(*const IXMLDOMDocument, @ptrCast(self)), data, comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createCDATASection(self: *const T, data: ?BSTR, cdata: ?*?*IXMLDOMCDATASection) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createCDATASection(@as(*const IXMLDOMDocument, @ptrCast(self)), data, cdata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createProcessingInstruction(self: *const T, target: ?BSTR, data: ?BSTR, pi: ?*?*IXMLDOMProcessingInstruction) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createProcessingInstruction(@as(*const IXMLDOMDocument, @ptrCast(self)), target, data, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createAttribute(self: *const T, name: ?BSTR, attribute: ?*?*IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createAttribute(@as(*const IXMLDOMDocument, @ptrCast(self)), name, attribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createEntityReference(self: *const T, name: ?BSTR, entityRef: ?*?*IXMLDOMEntityReference) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createEntityReference(@as(*const IXMLDOMDocument, @ptrCast(self)), name, entityRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_getElementsByTagName(self: *const T, tagName: ?BSTR, resultList: ?*?*IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).getElementsByTagName(@as(*const IXMLDOMDocument, @ptrCast(self)), tagName, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createNode(self: *const T, Type: VARIANT, name: ?BSTR, namespaceURI: ?BSTR, node: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).createNode(@as(*const IXMLDOMDocument, @ptrCast(self)), Type, name, namespaceURI, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_nodeFromID(self: *const T, idString: ?BSTR, node: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).nodeFromID(@as(*const IXMLDOMDocument, @ptrCast(self)), idString, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_load(self: *const T, xmlSource: VARIANT, isSuccessful: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).load(@as(*const IXMLDOMDocument, @ptrCast(self)), xmlSource, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_readyState(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXMLDOMDocument, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_parseError(self: *const T, errorObj: ?*?*IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_parseError(@as(*const IXMLDOMDocument, @ptrCast(self)), errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_url(self: *const T, urlString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_url(@as(*const IXMLDOMDocument, @ptrCast(self)), urlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_async(self: *const T, isAsync: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_async(@as(*const IXMLDOMDocument, @ptrCast(self)), isAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_async(self: *const T, isAsync: i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_async(@as(*const IXMLDOMDocument, @ptrCast(self)), isAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).abort(@as(*const IXMLDOMDocument, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_loadXML(self: *const T, bstrXML: ?BSTR, isSuccessful: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).loadXML(@as(*const IXMLDOMDocument, @ptrCast(self)), bstrXML, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_save(self: *const T, destination: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).save(@as(*const IXMLDOMDocument, @ptrCast(self)), destination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_validateOnParse(self: *const T, isValidating: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_validateOnParse(@as(*const IXMLDOMDocument, @ptrCast(self)), isValidating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_validateOnParse(self: *const T, isValidating: i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_validateOnParse(@as(*const IXMLDOMDocument, @ptrCast(self)), isValidating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_resolveExternals(self: *const T, isResolving: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_resolveExternals(@as(*const IXMLDOMDocument, @ptrCast(self)), isResolving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_resolveExternals(self: *const T, isResolving: i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_resolveExternals(@as(*const IXMLDOMDocument, @ptrCast(self)), isResolving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_preserveWhiteSpace(self: *const T, isPreserving: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).get_preserveWhiteSpace(@as(*const IXMLDOMDocument, @ptrCast(self)), isPreserving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_preserveWhiteSpace(self: *const T, isPreserving: i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_preserveWhiteSpace(@as(*const IXMLDOMDocument, @ptrCast(self)), isPreserving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_onreadystatechange(self: *const T, readystatechangeSink: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_onreadystatechange(@as(*const IXMLDOMDocument, @ptrCast(self)), readystatechangeSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_ondataavailable(self: *const T, ondataavailableSink: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_ondataavailable(@as(*const IXMLDOMDocument, @ptrCast(self)), ondataavailableSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_ontransformnode(self: *const T, ontransformnodeSink: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument.VTable, @ptrCast(self.vtable)).put_ontransformnode(@as(*const IXMLDOMDocument, @ptrCast(self)), ontransformnodeSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNodeList_Value = Guid.initString("2933bf82-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNodeList = &IID_IXMLDOMNodeList_Value;
pub const IXMLDOMNodeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNodeList,
                index: i32,
                listItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNodeList,
                index: i32,
                listItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNodeList,
                listLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNodeList,
                listLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        nextNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNodeList,
                nextItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNodeList,
                nextItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNodeList,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNodeList,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get_item(self: *const T, index: i32, listItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNodeList.VTable, @ptrCast(self.vtable)).get_item(@as(*const IXMLDOMNodeList, @ptrCast(self)), index, listItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get_length(self: *const T, listLength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNodeList.VTable, @ptrCast(self.vtable)).get_length(@as(*const IXMLDOMNodeList, @ptrCast(self)), listLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_nextNode(self: *const T, nextItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNodeList.VTable, @ptrCast(self.vtable)).nextNode(@as(*const IXMLDOMNodeList, @ptrCast(self)), nextItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNodeList.VTable, @ptrCast(self.vtable)).reset(@as(*const IXMLDOMNodeList, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get__newEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNodeList.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const IXMLDOMNodeList, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNamedNodeMap_Value = Guid.initString("2933bf83-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNamedNodeMap = &IID_IXMLDOMNamedNodeMap_Value;
pub const IXMLDOMNamedNodeMap = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                name: ?BSTR,
                namedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                name: ?BSTR,
                namedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                newItem: ?*IXMLDOMNode,
                nameItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                newItem: ?*IXMLDOMNode,
                nameItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                name: ?BSTR,
                namedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                name: ?BSTR,
                namedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                index: i32,
                listItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                index: i32,
                listItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                listLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                listLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getQualifiedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                baseName: ?BSTR,
                namespaceURI: ?BSTR,
                qualifiedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                baseName: ?BSTR,
                namespaceURI: ?BSTR,
                qualifiedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeQualifiedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                baseName: ?BSTR,
                namespaceURI: ?BSTR,
                qualifiedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                baseName: ?BSTR,
                namespaceURI: ?BSTR,
                qualifiedItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        nextNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                nextItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                nextItem: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNamedNodeMap,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNamedNodeMap,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_getNamedItem(self: *const T, name: ?BSTR, namedItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).getNamedItem(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), name, namedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_setNamedItem(self: *const T, newItem: ?*IXMLDOMNode, nameItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).setNamedItem(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), newItem, nameItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_removeNamedItem(self: *const T, name: ?BSTR, namedItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).removeNamedItem(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), name, namedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get_item(self: *const T, index: i32, listItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).get_item(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), index, listItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get_length(self: *const T, listLength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).get_length(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), listLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_getQualifiedItem(self: *const T, baseName: ?BSTR, namespaceURI: ?BSTR, qualifiedItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).getQualifiedItem(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), baseName, namespaceURI, qualifiedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_removeQualifiedItem(self: *const T, baseName: ?BSTR, namespaceURI: ?BSTR, qualifiedItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).removeQualifiedItem(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), baseName, namespaceURI, qualifiedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_nextNode(self: *const T, nextItem: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).nextNode(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), nextItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).reset(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get__newEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNamedNodeMap.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const IXMLDOMNamedNodeMap, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMCharacterData_Value = Guid.initString("2933bf84-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMCharacterData = &IID_IXMLDOMCharacterData_Value;
pub const IXMLDOMCharacterData = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                data: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                data: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                dataLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                dataLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        substringData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                count: i32,
                data: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                count: i32,
                data: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        appendData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        insertData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        deleteData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                count: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                count: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        replaceData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                count: i32,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMCharacterData,
                offset: i32,
                count: i32,
                data: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_get_data(self: *const T, data: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).get_data(@as(*const IXMLDOMCharacterData, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_put_data(self: *const T, data: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).put_data(@as(*const IXMLDOMCharacterData, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_get_length(self: *const T, dataLength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).get_length(@as(*const IXMLDOMCharacterData, @ptrCast(self)), dataLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_substringData(self: *const T, offset: i32, count: i32, data: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).substringData(@as(*const IXMLDOMCharacterData, @ptrCast(self)), offset, count, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_appendData(self: *const T, data: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).appendData(@as(*const IXMLDOMCharacterData, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_insertData(self: *const T, offset: i32, data: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).insertData(@as(*const IXMLDOMCharacterData, @ptrCast(self)), offset, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_deleteData(self: *const T, offset: i32, count: i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).deleteData(@as(*const IXMLDOMCharacterData, @ptrCast(self)), offset, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_replaceData(self: *const T, offset: i32, count: i32, data: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMCharacterData.VTable, @ptrCast(self.vtable)).replaceData(@as(*const IXMLDOMCharacterData, @ptrCast(self)), offset, count, data);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMAttribute_Value = Guid.initString("2933bf85-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMAttribute = &IID_IXMLDOMAttribute_Value;
pub const IXMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMAttribute,
                attributeName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMAttribute,
                attributeName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMAttribute,
                attributeValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMAttribute,
                attributeValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMAttribute,
                attributeValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMAttribute,
                attributeValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_get_name(self: *const T, attributeName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMAttribute.VTable, @ptrCast(self.vtable)).get_name(@as(*const IXMLDOMAttribute, @ptrCast(self)), attributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_get_value(self: *const T, attributeValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMAttribute.VTable, @ptrCast(self.vtable)).get_value(@as(*const IXMLDOMAttribute, @ptrCast(self)), attributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_put_value(self: *const T, attributeValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMAttribute.VTable, @ptrCast(self.vtable)).put_value(@as(*const IXMLDOMAttribute, @ptrCast(self)), attributeValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMElement_Value = Guid.initString("2933bf86-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMElement = &IID_IXMLDOMElement_Value;
pub const IXMLDOMElement = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMElement,
                tagName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMElement,
                tagName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttributeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
                attributeNode: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                name: ?BSTR,
                attributeNode: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttributeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                DOMAttribute: ?*IXMLDOMAttribute,
                attributeNode: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                DOMAttribute: ?*IXMLDOMAttribute,
                attributeNode: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttributeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                DOMAttribute: ?*IXMLDOMAttribute,
                attributeNode: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                DOMAttribute: ?*IXMLDOMAttribute,
                attributeNode: ?*?*IXMLDOMAttribute,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getElementsByTagName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
                tagName: ?BSTR,
                resultList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
                tagName: ?BSTR,
                resultList: ?*?*IXMLDOMNodeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        normalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_get_tagName(self: *const T, tagName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).get_tagName(@as(*const IXMLDOMElement, @ptrCast(self)), tagName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getAttribute(self: *const T, name: ?BSTR, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).getAttribute(@as(*const IXMLDOMElement, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_setAttribute(self: *const T, name: ?BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).setAttribute(@as(*const IXMLDOMElement, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_removeAttribute(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).removeAttribute(@as(*const IXMLDOMElement, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getAttributeNode(self: *const T, name: ?BSTR, attributeNode: ?*?*IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).getAttributeNode(@as(*const IXMLDOMElement, @ptrCast(self)), name, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_setAttributeNode(self: *const T, DOMAttribute: ?*IXMLDOMAttribute, attributeNode: ?*?*IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).setAttributeNode(@as(*const IXMLDOMElement, @ptrCast(self)), DOMAttribute, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_removeAttributeNode(self: *const T, DOMAttribute: ?*IXMLDOMAttribute, attributeNode: ?*?*IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).removeAttributeNode(@as(*const IXMLDOMElement, @ptrCast(self)), DOMAttribute, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getElementsByTagName(self: *const T, tagName: ?BSTR, resultList: ?*?*IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).getElementsByTagName(@as(*const IXMLDOMElement, @ptrCast(self)), tagName, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMElement.VTable, @ptrCast(self.vtable)).normalize(@as(*const IXMLDOMElement, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMText_Value = Guid.initString("2933bf87-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMText = &IID_IXMLDOMText_Value;
pub const IXMLDOMText = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMCharacterData.VTable,
        splitText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMText,
                offset: i32,
                rightHandTextNode: ?*?*IXMLDOMText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMText,
                offset: i32,
                rightHandTextNode: ?*?*IXMLDOMText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMCharacterData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMText_splitText(self: *const T, offset: i32, rightHandTextNode: ?*?*IXMLDOMText) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMText.VTable, @ptrCast(self.vtable)).splitText(@as(*const IXMLDOMText, @ptrCast(self)), offset, rightHandTextNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMComment_Value = Guid.initString("2933bf88-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMComment = &IID_IXMLDOMComment_Value;
pub const IXMLDOMComment = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMCharacterData.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMCharacterData.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMProcessingInstruction_Value = Guid.initString("2933bf89-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMProcessingInstruction = &IID_IXMLDOMProcessingInstruction_Value;
pub const IXMLDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_target: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMProcessingInstruction,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMProcessingInstruction,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMProcessingInstruction,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMProcessingInstruction,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMProcessingInstruction,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMProcessingInstruction,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_get_target(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMProcessingInstruction.VTable, @ptrCast(self.vtable)).get_target(@as(*const IXMLDOMProcessingInstruction, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_get_data(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMProcessingInstruction.VTable, @ptrCast(self.vtable)).get_data(@as(*const IXMLDOMProcessingInstruction, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_put_data(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMProcessingInstruction.VTable, @ptrCast(self.vtable)).put_data(@as(*const IXMLDOMProcessingInstruction, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMCDATASection_Value = Guid.initString("2933bf8a-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMCDATASection = &IID_IXMLDOMCDATASection_Value;
pub const IXMLDOMCDATASection = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMText.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMText.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocumentType_Value = Guid.initString("2933bf8b-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocumentType = &IID_IXMLDOMDocumentType_Value;
pub const IXMLDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocumentType,
                rootName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocumentType,
                rootName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocumentType,
                entityMap: ?*?*IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocumentType,
                entityMap: ?*?*IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notations: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocumentType,
                notationMap: ?*?*IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocumentType,
                notationMap: ?*?*IXMLDOMNamedNodeMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_name(self: *const T, rootName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocumentType.VTable, @ptrCast(self.vtable)).get_name(@as(*const IXMLDOMDocumentType, @ptrCast(self)), rootName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_entities(self: *const T, entityMap: ?*?*IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocumentType.VTable, @ptrCast(self.vtable)).get_entities(@as(*const IXMLDOMDocumentType, @ptrCast(self)), entityMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_notations(self: *const T, notationMap: ?*?*IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocumentType.VTable, @ptrCast(self.vtable)).get_notations(@as(*const IXMLDOMDocumentType, @ptrCast(self)), notationMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNotation_Value = Guid.initString("2933bf8c-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMNotation = &IID_IXMLDOMNotation_Value;
pub const IXMLDOMNotation = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNotation,
                publicID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNotation,
                publicID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMNotation,
                systemID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMNotation,
                systemID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNotation_get_publicId(self: *const T, publicID: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNotation.VTable, @ptrCast(self.vtable)).get_publicId(@as(*const IXMLDOMNotation, @ptrCast(self)), publicID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNotation_get_systemId(self: *const T, systemID: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMNotation.VTable, @ptrCast(self.vtable)).get_systemId(@as(*const IXMLDOMNotation, @ptrCast(self)), systemID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMEntity_Value = Guid.initString("2933bf8d-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMEntity = &IID_IXMLDOMEntity_Value;
pub const IXMLDOMEntity = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMEntity,
                publicID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMEntity,
                publicID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMEntity,
                systemID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMEntity,
                systemID: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notationName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMEntity,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMEntity,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_publicId(self: *const T, publicID: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMEntity.VTable, @ptrCast(self.vtable)).get_publicId(@as(*const IXMLDOMEntity, @ptrCast(self)), publicID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_systemId(self: *const T, systemID: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMEntity.VTable, @ptrCast(self.vtable)).get_systemId(@as(*const IXMLDOMEntity, @ptrCast(self)), systemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_notationName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMEntity.VTable, @ptrCast(self.vtable)).get_notationName(@as(*const IXMLDOMEntity, @ptrCast(self)), name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMEntityReference_Value = Guid.initString("2933bf8e-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMEntityReference = &IID_IXMLDOMEntityReference_Value;
pub const IXMLDOMEntityReference = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseError_Value = Guid.initString("3efaa426-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMParseError = &IID_IXMLDOMParseError_Value;
pub const IXMLDOMParseError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                errorCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                errorCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                urlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                urlString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_reason: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                reasonString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                reasonString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_srcText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                sourceString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                sourceString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_line: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                lineNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                lineNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_linepos: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                linePosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                linePosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_filepos: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError,
                filePosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError,
                filePosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_errorCode(self: *const T, errorCode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_errorCode(@as(*const IXMLDOMParseError, @ptrCast(self)), errorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_url(self: *const T, urlString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_url(@as(*const IXMLDOMParseError, @ptrCast(self)), urlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_reason(self: *const T, reasonString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_reason(@as(*const IXMLDOMParseError, @ptrCast(self)), reasonString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_srcText(self: *const T, sourceString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_srcText(@as(*const IXMLDOMParseError, @ptrCast(self)), sourceString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_line(self: *const T, lineNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_line(@as(*const IXMLDOMParseError, @ptrCast(self)), lineNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_linepos(self: *const T, linePosition: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_linepos(@as(*const IXMLDOMParseError, @ptrCast(self)), linePosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_filepos(self: *const T, filePosition: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError.VTable, @ptrCast(self.vtable)).get_filepos(@as(*const IXMLDOMParseError, @ptrCast(self)), filePosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXTLRuntime_Value = Guid.initString("3efaa425-272f-11d2-836f-0000f87a7782");
pub const IID_IXTLRuntime = &IID_IXTLRuntime_Value;
pub const IXTLRuntime = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        uniqueID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        depth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pDepth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pDepth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        childNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ancestorChildNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                bstrNodeName: ?BSTR,
                pNode: ?*IXMLDOMNode,
                pNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                bstrNodeName: ?BSTR,
                pNode: ?*IXMLDOMNode,
                pNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        absoluteChildNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                pNode: ?*IXMLDOMNode,
                pNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        formatIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                lIndex: i32,
                bstrFormat: ?BSTR,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                lIndex: i32,
                bstrFormat: ?BSTR,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        formatNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                dblNumber: f64,
                bstrFormat: ?BSTR,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                dblNumber: f64,
                bstrFormat: ?BSTR,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        formatDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                varDate: VARIANT,
                bstrFormat: ?BSTR,
                varDestLocale: VARIANT,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                varDate: VARIANT,
                bstrFormat: ?BSTR,
                varDestLocale: VARIANT,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        formatTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXTLRuntime,
                varTime: VARIANT,
                bstrFormat: ?BSTR,
                varDestLocale: VARIANT,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXTLRuntime,
                varTime: VARIANT,
                bstrFormat: ?BSTR,
                varDestLocale: VARIANT,
                pbstrFormattedString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_uniqueID(self: *const T, pNode: ?*IXMLDOMNode, pID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).uniqueID(@as(*const IXTLRuntime, @ptrCast(self)), pNode, pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_depth(self: *const T, pNode: ?*IXMLDOMNode, pDepth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).depth(@as(*const IXTLRuntime, @ptrCast(self)), pNode, pDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_childNumber(self: *const T, pNode: ?*IXMLDOMNode, pNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).childNumber(@as(*const IXTLRuntime, @ptrCast(self)), pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_ancestorChildNumber(self: *const T, bstrNodeName: ?BSTR, pNode: ?*IXMLDOMNode, pNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).ancestorChildNumber(@as(*const IXTLRuntime, @ptrCast(self)), bstrNodeName, pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_absoluteChildNumber(self: *const T, pNode: ?*IXMLDOMNode, pNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).absoluteChildNumber(@as(*const IXTLRuntime, @ptrCast(self)), pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatIndex(self: *const T, lIndex: i32, bstrFormat: ?BSTR, pbstrFormattedString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).formatIndex(@as(*const IXTLRuntime, @ptrCast(self)), lIndex, bstrFormat, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatNumber(self: *const T, dblNumber: f64, bstrFormat: ?BSTR, pbstrFormattedString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).formatNumber(@as(*const IXTLRuntime, @ptrCast(self)), dblNumber, bstrFormat, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatDate(self: *const T, varDate: VARIANT, bstrFormat: ?BSTR, varDestLocale: VARIANT, pbstrFormattedString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).formatDate(@as(*const IXTLRuntime, @ptrCast(self)), varDate, bstrFormat, varDestLocale, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatTime(self: *const T, varTime: VARIANT, bstrFormat: ?BSTR, varDestLocale: VARIANT, pbstrFormattedString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXTLRuntime.VTable, @ptrCast(self.vtable)).formatTime(@as(*const IXTLRuntime, @ptrCast(self)), varTime, bstrFormat, varDestLocale, pbstrFormattedString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_XMLDOMDocumentEvents_Value = Guid.initString("3efaa427-272f-11d2-836f-0000f87a7782");
pub const IID_XMLDOMDocumentEvents = &IID_XMLDOMDocumentEvents_Value;
pub const XMLDOMDocumentEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHttpRequest_Value = Guid.initString("ed8c108d-4349-11d2-91a4-00c04f7969e8");
pub const IID_IXMLHttpRequest = &IID_IXMLHttpRequest_Value;
pub const IXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                bstrMethod: ?BSTR,
                bstrUrl: ?BSTR,
                varAsync: VARIANT,
                bstrUser: VARIANT,
                bstrPassword: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHttpRequest,
                bstrMethod: ?BSTR,
                bstrUrl: ?BSTR,
                varAsync: VARIANT,
                bstrUser: VARIANT,
                bstrPassword: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setRequestHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                bstrHeader: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHttpRequest,
                bstrHeader: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getResponseHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                bstrHeader: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHttpRequest,
                bstrHeader: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAllResponseHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                pbstrHeaders: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHttpRequest,
                pbstrHeaders: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        send: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                varBody: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHttpRequest,
                varBody: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHttpRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHttpRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                plStatus: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                plStatus: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_statusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                pbstrStatus: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                pbstrStatus: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseXML: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                ppBody: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                ppBody: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                pbstrBody: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                pbstrBody: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseBody: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                plState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                plState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHttpRequest,
                pReadyStateSink: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHttpRequest,
                pReadyStateSink: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_open(self: *const T, bstrMethod: ?BSTR, bstrUrl: ?BSTR, varAsync: VARIANT, bstrUser: VARIANT, bstrPassword: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).open(@as(*const IXMLHttpRequest, @ptrCast(self)), bstrMethod, bstrUrl, varAsync, bstrUser, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_setRequestHeader(self: *const T, bstrHeader: ?BSTR, bstrValue: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).setRequestHeader(@as(*const IXMLHttpRequest, @ptrCast(self)), bstrHeader, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_getResponseHeader(self: *const T, bstrHeader: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).getResponseHeader(@as(*const IXMLHttpRequest, @ptrCast(self)), bstrHeader, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_getAllResponseHeaders(self: *const T, pbstrHeaders: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).getAllResponseHeaders(@as(*const IXMLHttpRequest, @ptrCast(self)), pbstrHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).send(@as(*const IXMLHttpRequest, @ptrCast(self)), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).abort(@as(*const IXMLHttpRequest, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_status(self: *const T, plStatus: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_status(@as(*const IXMLHttpRequest, @ptrCast(self)), plStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_statusText(self: *const T, pbstrStatus: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_statusText(@as(*const IXMLHttpRequest, @ptrCast(self)), pbstrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseXML(self: *const T, ppBody: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_responseXML(@as(*const IXMLHttpRequest, @ptrCast(self)), ppBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseText(self: *const T, pbstrBody: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_responseText(@as(*const IXMLHttpRequest, @ptrCast(self)), pbstrBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseBody(self: *const T, pvarBody: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_responseBody(@as(*const IXMLHttpRequest, @ptrCast(self)), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseStream(self: *const T, pvarBody: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_responseStream(@as(*const IXMLHttpRequest, @ptrCast(self)), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_readyState(self: *const T, plState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXMLHttpRequest, @ptrCast(self)), plState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_put_onreadystatechange(self: *const T, pReadyStateSink: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IXMLHttpRequest.VTable, @ptrCast(self.vtable)).put_onreadystatechange(@as(*const IXMLHttpRequest, @ptrCast(self)), pReadyStateSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDSOControl_Value = Guid.initString("310afa62-0575-11d2-9ca9-0060b0ec3d39");
pub const IID_IXMLDSOControl = &IID_IXMLDSOControl_Value;
pub const IXMLDSOControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XMLDocument: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDSOControl,
                ppDoc: ?*?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDSOControl,
                ppDoc: ?*?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_XMLDocument: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDSOControl,
                ppDoc: ?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDSOControl,
                ppDoc: ?*IXMLDOMDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_JavaDSOCompatible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDSOControl,
                fJavaDSOCompatible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDSOControl,
                fJavaDSOCompatible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_JavaDSOCompatible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDSOControl,
                fJavaDSOCompatible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDSOControl,
                fJavaDSOCompatible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDSOControl,
                state: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDSOControl,
                state: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_XMLDocument(self: *const T, ppDoc: ?*?*IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @as(*const IXMLDSOControl.VTable, @ptrCast(self.vtable)).get_XMLDocument(@as(*const IXMLDSOControl, @ptrCast(self)), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_put_XMLDocument(self: *const T, ppDoc: ?*IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @as(*const IXMLDSOControl.VTable, @ptrCast(self.vtable)).put_XMLDocument(@as(*const IXMLDSOControl, @ptrCast(self)), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_JavaDSOCompatible(self: *const T, fJavaDSOCompatible: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IXMLDSOControl.VTable, @ptrCast(self.vtable)).get_JavaDSOCompatible(@as(*const IXMLDSOControl, @ptrCast(self)), fJavaDSOCompatible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_put_JavaDSOCompatible(self: *const T, fJavaDSOCompatible: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IXMLDSOControl.VTable, @ptrCast(self.vtable)).put_JavaDSOCompatible(@as(*const IXMLDSOControl, @ptrCast(self)), fJavaDSOCompatible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_readyState(self: *const T, state: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDSOControl.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXMLDSOControl, @ptrCast(self)), state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElementCollection_Value = Guid.initString("65725580-9b5d-11d0-9bfe-00c04fc99c8e");
pub const IID_IXMLElementCollection = &IID_IXMLElementCollection_Value;
pub const IXMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElementCollection,
                v: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElementCollection,
                v: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElementCollection,
                p: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElementCollection,
                p: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElementCollection,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElementCollection,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElementCollection,
                var1: VARIANT,
                var2: VARIANT,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElementCollection,
                var1: VARIANT,
                var2: VARIANT,
                ppDisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLElementCollection.VTable, @ptrCast(self.vtable)).put_length(@as(*const IXMLElementCollection, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_get_length(self: *const T, p: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLElementCollection.VTable, @ptrCast(self.vtable)).get_length(@as(*const IXMLElementCollection, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_get__newEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IXMLElementCollection.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const IXMLElementCollection, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_item(self: *const T, var1: VARIANT, var2: VARIANT, ppDisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IXMLElementCollection.VTable, @ptrCast(self.vtable)).item(@as(*const IXMLElementCollection, @ptrCast(self)), var1, var2, ppDisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDocument_Value = Guid.initString("f52e2b61-18a1-11d1-b105-00805f49916b");
pub const IID_IXMLDocument = &IID_IXMLDocument_Value;
pub const IXMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_root: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileModifiedDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileUpdatedDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDocument,
                vType: VARIANT,
                var1: VARIANT,
                ppElem: ?*?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDocument,
                vType: VARIANT,
                var1: VARIANT,
                ppElem: ?*?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_root(self: *const T, p: ?*?*IXMLElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_root(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileSize(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_fileSize(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileModifiedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_fileModifiedDate(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileUpdatedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_fileUpdatedDate(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_URL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_put_URL(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).put_URL(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_mimeType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_mimeType(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_readyState(self: *const T, pl: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXMLDocument, @ptrCast(self)), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_charset(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_put_charset(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).put_charset(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_version(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_version(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_doctype(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_doctype(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_dtdURL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).get_dtdURL(@as(*const IXMLDocument, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_createElement(self: *const T, vType: VARIANT, var1: VARIANT, ppElem: ?*?*IXMLElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument.VTable, @ptrCast(self.vtable)).createElement(@as(*const IXMLDocument, @ptrCast(self)), vType, var1, ppElem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDocument2_Value = Guid.initString("2b8de2fe-8d2d-11d1-b2fc-00c04fd915a9");
pub const IID_IXMLDocument2 = &IID_IXMLDocument2_Value;
pub const IXMLDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_root: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileModifiedDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fileUpdatedDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                pl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_charset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_charset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_doctype: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDocument2,
                vType: VARIANT,
                var1: VARIANT,
                ppElem: ?*?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDocument2,
                vType: VARIANT,
                var1: VARIANT,
                ppElem: ?*?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_async: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                pf: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                pf: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_async: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDocument2,
                f: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDocument2,
                f: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_root(self: *const T, p: ?*?*IXMLElement2) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_root(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileSize(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_fileSize(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileModifiedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_fileModifiedDate(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileUpdatedDate(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_fileUpdatedDate(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_URL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_URL(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).put_URL(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_mimeType(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_mimeType(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_readyState(self: *const T, pl: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXMLDocument2, @ptrCast(self)), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_charset(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_charset(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_charset(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).put_charset(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_version(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_version(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_doctype(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_doctype(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_dtdURL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_dtdURL(@as(*const IXMLDocument2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_createElement(self: *const T, vType: VARIANT, var1: VARIANT, ppElem: ?*?*IXMLElement2) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).createElement(@as(*const IXMLDocument2, @ptrCast(self)), vType, var1, ppElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_async(self: *const T, pf: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).get_async(@as(*const IXMLDocument2, @ptrCast(self)), pf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_async(self: *const T, f: i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDocument2.VTable, @ptrCast(self.vtable)).put_async(@as(*const IXMLDocument2, @ptrCast(self)), f);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElement_Value = Guid.initString("3f7f31ac-e15f-11d0-9c25-00c04fc99c8e");
pub const IID_IXMLElement = &IID_IXMLElement_Value;
pub const IXMLElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tagName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                ppParent: ?*?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                ppParent: ?*?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement,
                strPropertyName: ?BSTR,
                PropertyValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement,
                strPropertyName: ?BSTR,
                PropertyValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement,
                strPropertyName: ?BSTR,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement,
                strPropertyName: ?BSTR,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement,
                strPropertyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement,
                strPropertyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_children: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                pp: ?*?*IXMLElementCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                pp: ?*?*IXMLElementCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                plType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                plType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement,
                pChildElem: ?*IXMLElement,
                lIndex: i32,
                lReserved: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement,
                pChildElem: ?*IXMLElement,
                lIndex: i32,
                lReserved: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement,
                pChildElem: ?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement,
                pChildElem: ?*IXMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_tagName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).get_tagName(@as(*const IXMLElement, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_put_tagName(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).put_tagName(@as(*const IXMLElement, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_parent(self: *const T, ppParent: ?*?*IXMLElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).get_parent(@as(*const IXMLElement, @ptrCast(self)), ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_setAttribute(self: *const T, strPropertyName: ?BSTR, PropertyValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).setAttribute(@as(*const IXMLElement, @ptrCast(self)), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_getAttribute(self: *const T, strPropertyName: ?BSTR, PropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).getAttribute(@as(*const IXMLElement, @ptrCast(self)), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_removeAttribute(self: *const T, strPropertyName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).removeAttribute(@as(*const IXMLElement, @ptrCast(self)), strPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_children(self: *const T, pp: ?*?*IXMLElementCollection) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).get_children(@as(*const IXMLElement, @ptrCast(self)), pp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_type(self: *const T, plType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).get_type(@as(*const IXMLElement, @ptrCast(self)), plType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).get_text(@as(*const IXMLElement, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_put_text(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).put_text(@as(*const IXMLElement, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_addChild(self: *const T, pChildElem: ?*IXMLElement, lIndex: i32, lReserved: i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).addChild(@as(*const IXMLElement, @ptrCast(self)), pChildElem, lIndex, lReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_removeChild(self: *const T, pChildElem: ?*IXMLElement) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement.VTable, @ptrCast(self.vtable)).removeChild(@as(*const IXMLElement, @ptrCast(self)), pChildElem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElement2_Value = Guid.initString("2b8de2ff-8d2d-11d1-b2fc-00c04fd915a9");
pub const IID_IXMLElement2 = &IID_IXMLElement2_Value;
pub const IXMLElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_tagName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_tagName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                ppParent: ?*?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                ppParent: ?*?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement2,
                strPropertyName: ?BSTR,
                PropertyValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement2,
                strPropertyName: ?BSTR,
                PropertyValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement2,
                strPropertyName: ?BSTR,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement2,
                strPropertyName: ?BSTR,
                PropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement2,
                strPropertyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement2,
                strPropertyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_children: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                pp: ?*?*IXMLElementCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                pp: ?*?*IXMLElementCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                plType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                plType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                p: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement2,
                pChildElem: ?*IXMLElement2,
                lIndex: i32,
                lReserved: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement2,
                pChildElem: ?*IXMLElement2,
                lIndex: i32,
                lReserved: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLElement2,
                pChildElem: ?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLElement2,
                pChildElem: ?*IXMLElement2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLElement2,
                pp: ?*?*IXMLElementCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLElement2,
                pp: ?*?*IXMLElementCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_tagName(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).get_tagName(@as(*const IXMLElement2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_put_tagName(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).put_tagName(@as(*const IXMLElement2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_parent(self: *const T, ppParent: ?*?*IXMLElement2) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).get_parent(@as(*const IXMLElement2, @ptrCast(self)), ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_setAttribute(self: *const T, strPropertyName: ?BSTR, PropertyValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).setAttribute(@as(*const IXMLElement2, @ptrCast(self)), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_getAttribute(self: *const T, strPropertyName: ?BSTR, PropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).getAttribute(@as(*const IXMLElement2, @ptrCast(self)), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_removeAttribute(self: *const T, strPropertyName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).removeAttribute(@as(*const IXMLElement2, @ptrCast(self)), strPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_children(self: *const T, pp: ?*?*IXMLElementCollection) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).get_children(@as(*const IXMLElement2, @ptrCast(self)), pp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_type(self: *const T, plType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).get_type(@as(*const IXMLElement2, @ptrCast(self)), plType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_text(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).get_text(@as(*const IXMLElement2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_put_text(self: *const T, p: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).put_text(@as(*const IXMLElement2, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_addChild(self: *const T, pChildElem: ?*IXMLElement2, lIndex: i32, lReserved: i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).addChild(@as(*const IXMLElement2, @ptrCast(self)), pChildElem, lIndex, lReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_removeChild(self: *const T, pChildElem: ?*IXMLElement2) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).removeChild(@as(*const IXMLElement2, @ptrCast(self)), pChildElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_attributes(self: *const T, pp: ?*?*IXMLElementCollection) callconv(.Inline) HRESULT {
            return @as(*const IXMLElement2.VTable, @ptrCast(self.vtable)).get_attributes(@as(*const IXMLElement2, @ptrCast(self)), pp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLAttribute_Value = Guid.initString("d4d4a0fc-3b73-11d1-b2b4-00c04fb92596");
pub const IID_IXMLAttribute = &IID_IXMLAttribute_Value;
pub const IXMLAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLAttribute,
                n: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLAttribute,
                n: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLAttribute,
                v: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLAttribute,
                v: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLAttribute_get_name(self: *const T, n: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLAttribute.VTable, @ptrCast(self.vtable)).get_name(@as(*const IXMLAttribute, @ptrCast(self)), n);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLAttribute_get_value(self: *const T, v: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLAttribute.VTable, @ptrCast(self.vtable)).get_value(@as(*const IXMLAttribute, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLError_Value = Guid.initString("948c5ad3-c58d-11d0-9c0b-00c04fc99c8e");
pub const IID_IXMLError = &IID_IXMLError_Value;
pub const IXMLError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLError,
                pErrorReturn: ?*XML_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLError,
                pErrorReturn: ?*XML_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLError_GetErrorInfo(self: *const T, pErrorReturn: ?*XML_ERROR) callconv(.Inline) HRESULT {
            return @as(*const IXMLError.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const IXMLError, @ptrCast(self)), pErrorReturn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DOMDocument60_Value = Guid.initString("88d96a05-f192-11d4-a65f-0040963251e5");
pub const CLSID_DOMDocument60 = &CLSID_DOMDocument60_Value;

const CLSID_FreeThreadedDOMDocument60_Value = Guid.initString("88d96a06-f192-11d4-a65f-0040963251e5");
pub const CLSID_FreeThreadedDOMDocument60 = &CLSID_FreeThreadedDOMDocument60_Value;

const CLSID_XMLSchemaCache60_Value = Guid.initString("88d96a07-f192-11d4-a65f-0040963251e5");
pub const CLSID_XMLSchemaCache60 = &CLSID_XMLSchemaCache60_Value;

const CLSID_XSLTemplate60_Value = Guid.initString("88d96a08-f192-11d4-a65f-0040963251e5");
pub const CLSID_XSLTemplate60 = &CLSID_XSLTemplate60_Value;

const CLSID_XMLHTTP60_Value = Guid.initString("88d96a0a-f192-11d4-a65f-0040963251e5");
pub const CLSID_XMLHTTP60 = &CLSID_XMLHTTP60_Value;

const CLSID_FreeThreadedXMLHTTP60_Value = Guid.initString("88d96a09-f192-11d4-a65f-0040963251e5");
pub const CLSID_FreeThreadedXMLHTTP60 = &CLSID_FreeThreadedXMLHTTP60_Value;

const CLSID_ServerXMLHTTP60_Value = Guid.initString("88d96a0b-f192-11d4-a65f-0040963251e5");
pub const CLSID_ServerXMLHTTP60 = &CLSID_ServerXMLHTTP60_Value;

const CLSID_SAXXMLReader60_Value = Guid.initString("88d96a0c-f192-11d4-a65f-0040963251e5");
pub const CLSID_SAXXMLReader60 = &CLSID_SAXXMLReader60_Value;

const CLSID_MXXMLWriter60_Value = Guid.initString("88d96a0f-f192-11d4-a65f-0040963251e5");
pub const CLSID_MXXMLWriter60 = &CLSID_MXXMLWriter60_Value;

const CLSID_MXHTMLWriter60_Value = Guid.initString("88d96a10-f192-11d4-a65f-0040963251e5");
pub const CLSID_MXHTMLWriter60 = &CLSID_MXHTMLWriter60_Value;

const CLSID_SAXAttributes60_Value = Guid.initString("88d96a0e-f192-11d4-a65f-0040963251e5");
pub const CLSID_SAXAttributes60 = &CLSID_SAXAttributes60_Value;

const CLSID_MXNamespaceManager60_Value = Guid.initString("88d96a11-f192-11d4-a65f-0040963251e5");
pub const CLSID_MXNamespaceManager60 = &CLSID_MXNamespaceManager60_Value;

const IID_IXMLDOMDocument2_Value = Guid.initString("2933bf95-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocument2 = &IID_IXMLDOMDocument2_Value;
pub const IXMLDOMDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMDocument.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument2,
                namespaceCollection: ?*?*IXMLDOMSchemaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument2,
                namespaceCollection: ?*?*IXMLDOMSchemaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_schemas: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMDocument2,
                otherCollection: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMDocument2,
                otherCollection: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_schemas: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument2,
                otherCollection: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument2,
                otherCollection: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        validate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument2,
                errorObj: ?*?*IXMLDOMParseError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument2,
                errorObj: ?*?*IXMLDOMParseError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument2,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument2,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument2,
                name: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument2,
                name: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_get_namespaces(self: *const T, namespaceCollection: ?*?*IXMLDOMSchemaCollection) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument2.VTable, @ptrCast(self.vtable)).get_namespaces(@as(*const IXMLDOMDocument2, @ptrCast(self)), namespaceCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_get_schemas(self: *const T, otherCollection: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument2.VTable, @ptrCast(self.vtable)).get_schemas(@as(*const IXMLDOMDocument2, @ptrCast(self)), otherCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_putref_schemas(self: *const T, otherCollection: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument2.VTable, @ptrCast(self.vtable)).putref_schemas(@as(*const IXMLDOMDocument2, @ptrCast(self)), otherCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_validate(self: *const T, errorObj: ?*?*IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument2.VTable, @ptrCast(self.vtable)).validate(@as(*const IXMLDOMDocument2, @ptrCast(self)), errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_setProperty(self: *const T, name: ?BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument2.VTable, @ptrCast(self.vtable)).setProperty(@as(*const IXMLDOMDocument2, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument2_getProperty(self: *const T, name: ?BSTR, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument2.VTable, @ptrCast(self.vtable)).getProperty(@as(*const IXMLDOMDocument2, @ptrCast(self)), name, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocument3_Value = Guid.initString("2933bf96-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXMLDOMDocument3 = &IID_IXMLDOMDocument3_Value;
pub const IXMLDOMDocument3 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMDocument2.VTable,
        validateNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument3,
                node: ?*IXMLDOMNode,
                errorObj: ?*?*IXMLDOMParseError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument3,
                node: ?*IXMLDOMNode,
                errorObj: ?*?*IXMLDOMParseError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        importNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMDocument3,
                node: ?*IXMLDOMNode,
                deep: i16,
                clone: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMDocument3,
                node: ?*IXMLDOMNode,
                deep: i16,
                clone: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMDocument2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument3_validateNode(self: *const T, node: ?*IXMLDOMNode, errorObj: ?*?*IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument3.VTable, @ptrCast(self.vtable)).validateNode(@as(*const IXMLDOMDocument3, @ptrCast(self)), node, errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument3_importNode(self: *const T, node: ?*IXMLDOMNode, deep: i16, clone: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMDocument3.VTable, @ptrCast(self.vtable)).importNode(@as(*const IXMLDOMDocument3, @ptrCast(self)), node, deep, clone);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMSchemaCollection_Value = Guid.initString("373984c8-b845-449b-91e7-45ac83036ade");
pub const IID_IXMLDOMSchemaCollection = &IID_IXMLDOMSchemaCollection_Value;
pub const IXMLDOMSchemaCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                namespaceURI: ?BSTR,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                namespaceURI: ?BSTR,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                namespaceURI: ?BSTR,
                schemaNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                namespaceURI: ?BSTR,
                schemaNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                index: i32,
                length: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                index: i32,
                length: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                otherCollection: ?*IXMLDOMSchemaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                otherCollection: ?*IXMLDOMSchemaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSchemaCollection,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_add(self: *const T, namespaceURI: ?BSTR, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).add(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), namespaceURI, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get(self: *const T, namespaceURI: ?BSTR, schemaNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).get(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), namespaceURI, schemaNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_remove(self: *const T, namespaceURI: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).remove(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get_length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).get_length(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get_namespaceURI(self: *const T, index: i32, length: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).get_namespaceURI(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), index, length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_addCollection(self: *const T, otherCollection: ?*IXMLDOMSchemaCollection) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).addCollection(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), otherCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection_get__newEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const IXMLDOMSchemaCollection, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMSelection_Value = Guid.initString("aa634fc7-5888-44a7-a257-3a47150d3a0e");
pub const IID_IXMLDOMSelection = &IID_IXMLDOMSelection_Value;
pub const IXMLDOMSelection = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNodeList.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expr: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                expression: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSelection,
                expression: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_expr: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                expression: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSelection,
                expression: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_context: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_context: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                pNode: ?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                pNode: ?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        peekNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        matches: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                pNode: ?*IXMLDOMNode,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                pNode: ?*IXMLDOMNode,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                ppNode: ?*?*IXMLDOMSelection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                name: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                name: ?BSTR,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSelection,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSelection,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNodeList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_get_expr(self: *const T, expression: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).get_expr(@as(*const IXMLDOMSelection, @ptrCast(self)), expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_put_expr(self: *const T, expression: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).put_expr(@as(*const IXMLDOMSelection, @ptrCast(self)), expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_get_context(self: *const T, ppNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).get_context(@as(*const IXMLDOMSelection, @ptrCast(self)), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_putref_context(self: *const T, pNode: ?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).putref_context(@as(*const IXMLDOMSelection, @ptrCast(self)), pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_peekNode(self: *const T, ppNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).peekNode(@as(*const IXMLDOMSelection, @ptrCast(self)), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_matches(self: *const T, pNode: ?*IXMLDOMNode, ppNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).matches(@as(*const IXMLDOMSelection, @ptrCast(self)), pNode, ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_removeNext(self: *const T, ppNode: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).removeNext(@as(*const IXMLDOMSelection, @ptrCast(self)), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_removeAll(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).removeAll(@as(*const IXMLDOMSelection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_clone(self: *const T, ppNode: ?*?*IXMLDOMSelection) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).clone(@as(*const IXMLDOMSelection, @ptrCast(self)), ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_getProperty(self: *const T, name: ?BSTR, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).getProperty(@as(*const IXMLDOMSelection, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSelection_setProperty(self: *const T, name: ?BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSelection.VTable, @ptrCast(self.vtable)).setProperty(@as(*const IXMLDOMSelection, @ptrCast(self)), name, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseError2_Value = Guid.initString("3efaa428-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMParseError2 = &IID_IXMLDOMParseError2_Value;
pub const IXMLDOMParseError2 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMParseError.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorXPath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError2,
                xpathexpr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError2,
                xpathexpr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_allErrors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError2,
                allErrors: ?*?*IXMLDOMParseErrorCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError2,
                allErrors: ?*?*IXMLDOMParseErrorCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        errorParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMParseError2,
                index: i32,
                param1: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMParseError2,
                index: i32,
                param1: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorParametersCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseError2,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseError2,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMParseError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_get_errorXPath(self: *const T, xpathexpr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError2.VTable, @ptrCast(self.vtable)).get_errorXPath(@as(*const IXMLDOMParseError2, @ptrCast(self)), xpathexpr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_get_allErrors(self: *const T, allErrors: ?*?*IXMLDOMParseErrorCollection) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError2.VTable, @ptrCast(self.vtable)).get_allErrors(@as(*const IXMLDOMParseError2, @ptrCast(self)), allErrors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_errorParameters(self: *const T, index: i32, param1: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError2.VTable, @ptrCast(self.vtable)).errorParameters(@as(*const IXMLDOMParseError2, @ptrCast(self)), index, param1);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError2_get_errorParametersCount(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseError2.VTable, @ptrCast(self.vtable)).get_errorParametersCount(@as(*const IXMLDOMParseError2, @ptrCast(self)), count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseErrorCollection_Value = Guid.initString("3efaa429-272f-11d2-836f-0000f87a7782");
pub const IID_IXMLDOMParseErrorCollection = &IID_IXMLDOMParseErrorCollection_Value;
pub const IXMLDOMParseErrorCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseErrorCollection,
                index: i32,
                @"error": ?*?*IXMLDOMParseError2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseErrorCollection,
                index: i32,
                @"error": ?*?*IXMLDOMParseError2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseErrorCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseErrorCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_next: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseErrorCollection,
                @"error": ?*?*IXMLDOMParseError2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseErrorCollection,
                @"error": ?*?*IXMLDOMParseError2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMParseErrorCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMParseErrorCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMParseErrorCollection,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMParseErrorCollection,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get_item(self: *const T, index: i32, @"error": ?*?*IXMLDOMParseError2) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseErrorCollection.VTable, @ptrCast(self.vtable)).get_item(@as(*const IXMLDOMParseErrorCollection, @ptrCast(self)), index, @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get_length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseErrorCollection.VTable, @ptrCast(self.vtable)).get_length(@as(*const IXMLDOMParseErrorCollection, @ptrCast(self)), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get_next(self: *const T, @"error": ?*?*IXMLDOMParseError2) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseErrorCollection.VTable, @ptrCast(self.vtable)).get_next(@as(*const IXMLDOMParseErrorCollection, @ptrCast(self)), @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseErrorCollection.VTable, @ptrCast(self.vtable)).reset(@as(*const IXMLDOMParseErrorCollection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseErrorCollection_get__newEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMParseErrorCollection.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const IXMLDOMParseErrorCollection, @ptrCast(self)), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXSLProcessor_Value = Guid.initString("2933bf92-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXSLProcessor = &IID_IXSLProcessor_Value;
pub const IXSLProcessor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_input: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                @"var": VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_input: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ownerTemplate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                ppTemplate: ?*?*IXSLTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                ppTemplate: ?*?*IXSLTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setStartMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLProcessor,
                mode: ?BSTR,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLProcessor,
                mode: ?BSTR,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                mode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                mode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_startModeURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                namespaceURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                namespaceURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_output: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                output: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                output: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_output: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                pOutput: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                pOutput: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        transform: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLProcessor,
                pDone: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLProcessor,
                pDone: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                pReadyState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                pReadyState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLProcessor,
                baseName: ?BSTR,
                parameter: VARIANT,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLProcessor,
                baseName: ?BSTR,
                parameter: VARIANT,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLProcessor,
                obj: ?*IDispatch,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLProcessor,
                obj: ?*IDispatch,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stylesheet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLProcessor,
                stylesheet: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLProcessor,
                stylesheet: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_put_input(self: *const T, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).put_input(@as(*const IXSLProcessor, @ptrCast(self)), @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_input(self: *const T, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_input(@as(*const IXSLProcessor, @ptrCast(self)), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_ownerTemplate(self: *const T, ppTemplate: ?*?*IXSLTemplate) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_ownerTemplate(@as(*const IXSLProcessor, @ptrCast(self)), ppTemplate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_setStartMode(self: *const T, mode: ?BSTR, namespaceURI: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).setStartMode(@as(*const IXSLProcessor, @ptrCast(self)), mode, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_startMode(self: *const T, mode: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_startMode(@as(*const IXSLProcessor, @ptrCast(self)), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_startModeURI(self: *const T, namespaceURI: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_startModeURI(@as(*const IXSLProcessor, @ptrCast(self)), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_put_output(self: *const T, output: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).put_output(@as(*const IXSLProcessor, @ptrCast(self)), output);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_output(self: *const T, pOutput: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_output(@as(*const IXSLProcessor, @ptrCast(self)), pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_transform(self: *const T, pDone: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).transform(@as(*const IXSLProcessor, @ptrCast(self)), pDone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).reset(@as(*const IXSLProcessor, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_readyState(self: *const T, pReadyState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXSLProcessor, @ptrCast(self)), pReadyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_addParameter(self: *const T, baseName: ?BSTR, parameter: VARIANT, namespaceURI: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).addParameter(@as(*const IXSLProcessor, @ptrCast(self)), baseName, parameter, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_addObject(self: *const T, obj: ?*IDispatch, namespaceURI: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).addObject(@as(*const IXSLProcessor, @ptrCast(self)), obj, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLProcessor_get_stylesheet(self: *const T, stylesheet: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXSLProcessor.VTable, @ptrCast(self.vtable)).get_stylesheet(@as(*const IXSLProcessor, @ptrCast(self)), stylesheet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXSLTemplate_Value = Guid.initString("2933bf93-7b36-11d2-b20e-00c04f983e60");
pub const IID_IXSLTemplate = &IID_IXSLTemplate_Value;
pub const IXSLTemplate = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_stylesheet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLTemplate,
                stylesheet: ?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLTemplate,
                stylesheet: ?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stylesheet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXSLTemplate,
                stylesheet: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXSLTemplate,
                stylesheet: ?*?*IXMLDOMNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXSLTemplate,
                ppProcessor: ?*?*IXSLProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXSLTemplate,
                ppProcessor: ?*?*IXSLProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLTemplate_putref_stylesheet(self: *const T, stylesheet: ?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXSLTemplate.VTable, @ptrCast(self.vtable)).putref_stylesheet(@as(*const IXSLTemplate, @ptrCast(self)), stylesheet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLTemplate_get_stylesheet(self: *const T, stylesheet: ?*?*IXMLDOMNode) callconv(.Inline) HRESULT {
            return @as(*const IXSLTemplate.VTable, @ptrCast(self.vtable)).get_stylesheet(@as(*const IXSLTemplate, @ptrCast(self)), stylesheet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXSLTemplate_createProcessor(self: *const T, ppProcessor: ?*?*IXSLProcessor) callconv(.Inline) HRESULT {
            return @as(*const IXSLTemplate.VTable, @ptrCast(self.vtable)).createProcessor(@as(*const IXSLTemplate, @ptrCast(self)), ppProcessor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHTTPRequest_Value = Guid.initString("ed8c108d-4349-11d2-91a4-00c04f7969e8");
pub const IID_IXMLHTTPRequest = &IID_IXMLHTTPRequest_Value;
pub const IXMLHTTPRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                bstrMethod: ?BSTR,
                bstrUrl: ?BSTR,
                varAsync: VARIANT,
                bstrUser: VARIANT,
                bstrPassword: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest,
                bstrMethod: ?BSTR,
                bstrUrl: ?BSTR,
                varAsync: VARIANT,
                bstrUser: VARIANT,
                bstrPassword: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setRequestHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                bstrHeader: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest,
                bstrHeader: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getResponseHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                bstrHeader: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest,
                bstrHeader: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAllResponseHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                pbstrHeaders: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest,
                pbstrHeaders: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        send: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                varBody: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest,
                varBody: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                plStatus: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                plStatus: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_statusText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                pbstrStatus: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                pbstrStatus: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseXML: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                ppBody: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                ppBody: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                pbstrBody: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                pbstrBody: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseBody: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_responseStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                pvarBody: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_readyState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                plState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                plState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_onreadystatechange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLHTTPRequest,
                pReadyStateSink: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLHTTPRequest,
                pReadyStateSink: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_open(self: *const T, bstrMethod: ?BSTR, bstrUrl: ?BSTR, varAsync: VARIANT, bstrUser: VARIANT, bstrPassword: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).open(@as(*const IXMLHTTPRequest, @ptrCast(self)), bstrMethod, bstrUrl, varAsync, bstrUser, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_setRequestHeader(self: *const T, bstrHeader: ?BSTR, bstrValue: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).setRequestHeader(@as(*const IXMLHTTPRequest, @ptrCast(self)), bstrHeader, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_getResponseHeader(self: *const T, bstrHeader: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).getResponseHeader(@as(*const IXMLHTTPRequest, @ptrCast(self)), bstrHeader, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_getAllResponseHeaders(self: *const T, pbstrHeaders: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).getAllResponseHeaders(@as(*const IXMLHTTPRequest, @ptrCast(self)), pbstrHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).send(@as(*const IXMLHTTPRequest, @ptrCast(self)), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).abort(@as(*const IXMLHTTPRequest, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_status(self: *const T, plStatus: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_status(@as(*const IXMLHTTPRequest, @ptrCast(self)), plStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_statusText(self: *const T, pbstrStatus: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_statusText(@as(*const IXMLHTTPRequest, @ptrCast(self)), pbstrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseXML(self: *const T, ppBody: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_responseXML(@as(*const IXMLHTTPRequest, @ptrCast(self)), ppBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseText(self: *const T, pbstrBody: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_responseText(@as(*const IXMLHTTPRequest, @ptrCast(self)), pbstrBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseBody(self: *const T, pvarBody: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_responseBody(@as(*const IXMLHTTPRequest, @ptrCast(self)), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_responseStream(self: *const T, pvarBody: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_responseStream(@as(*const IXMLHTTPRequest, @ptrCast(self)), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_get_readyState(self: *const T, plState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).get_readyState(@as(*const IXMLHTTPRequest, @ptrCast(self)), plState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest_put_onreadystatechange(self: *const T, pReadyStateSink: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest.VTable, @ptrCast(self.vtable)).put_onreadystatechange(@as(*const IXMLHTTPRequest, @ptrCast(self)), pReadyStateSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SERVERXMLHTTP_OPTION = enum(i32) {
    URL = -1,
    URL_CODEPAGE = 0,
    ESCAPE_PERCENT_IN_URL = 1,
    IGNORE_SERVER_SSL_CERT_ERROR_FLAGS = 2,
    SELECT_CLIENT_SSL_CERT = 3,
};
pub const SXH_OPTION_URL = SERVERXMLHTTP_OPTION.URL;
pub const SXH_OPTION_URL_CODEPAGE = SERVERXMLHTTP_OPTION.URL_CODEPAGE;
pub const SXH_OPTION_ESCAPE_PERCENT_IN_URL = SERVERXMLHTTP_OPTION.ESCAPE_PERCENT_IN_URL;
pub const SXH_OPTION_IGNORE_SERVER_SSL_CERT_ERROR_FLAGS = SERVERXMLHTTP_OPTION.IGNORE_SERVER_SSL_CERT_ERROR_FLAGS;
pub const SXH_OPTION_SELECT_CLIENT_SSL_CERT = SERVERXMLHTTP_OPTION.SELECT_CLIENT_SSL_CERT;

pub const SXH_SERVER_CERT_OPTION = enum(i32) {
    UNKNOWN_CA = 256,
    WRONG_USAGE = 512,
    CERT_CN_INVALID = 4096,
    CERT_DATE_INVALID = 8192,
    ALL_SERVER_ERRORS = 13056,
};
pub const SXH_SERVER_CERT_IGNORE_UNKNOWN_CA = SXH_SERVER_CERT_OPTION.UNKNOWN_CA;
pub const SXH_SERVER_CERT_IGNORE_WRONG_USAGE = SXH_SERVER_CERT_OPTION.WRONG_USAGE;
pub const SXH_SERVER_CERT_IGNORE_CERT_CN_INVALID = SXH_SERVER_CERT_OPTION.CERT_CN_INVALID;
pub const SXH_SERVER_CERT_IGNORE_CERT_DATE_INVALID = SXH_SERVER_CERT_OPTION.CERT_DATE_INVALID;
pub const SXH_SERVER_CERT_IGNORE_ALL_SERVER_ERRORS = SXH_SERVER_CERT_OPTION.ALL_SERVER_ERRORS;

pub const SXH_PROXY_SETTING = enum(i32) {
    DEFAULT = 0,
    // PRECONFIG = 0, this enum value conflicts with DEFAULT
    DIRECT = 1,
    PROXY = 2,
};
pub const SXH_PROXY_SET_DEFAULT = SXH_PROXY_SETTING.DEFAULT;
pub const SXH_PROXY_SET_PRECONFIG = SXH_PROXY_SETTING.DEFAULT;
pub const SXH_PROXY_SET_DIRECT = SXH_PROXY_SETTING.DIRECT;
pub const SXH_PROXY_SET_PROXY = SXH_PROXY_SETTING.PROXY;

const IID_IServerXMLHTTPRequest_Value = Guid.initString("2e9196bf-13ba-4dd4-91ca-6c571f281495");
pub const IID_IServerXMLHTTPRequest = &IID_IServerXMLHTTPRequest_Value;
pub const IServerXMLHTTPRequest = extern struct {
    pub const VTable = extern struct {
        base: IXMLHTTPRequest.VTable,
        setTimeouts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServerXMLHTTPRequest,
                resolveTimeout: i32,
                connectTimeout: i32,
                sendTimeout: i32,
                receiveTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServerXMLHTTPRequest,
                resolveTimeout: i32,
                connectTimeout: i32,
                sendTimeout: i32,
                receiveTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        waitForResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServerXMLHTTPRequest,
                timeoutInSeconds: VARIANT,
                isSuccessful: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServerXMLHTTPRequest,
                timeoutInSeconds: VARIANT,
                isSuccessful: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServerXMLHTTPRequest,
                option: SERVERXMLHTTP_OPTION,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServerXMLHTTPRequest,
                option: SERVERXMLHTTP_OPTION,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServerXMLHTTPRequest,
                option: SERVERXMLHTTP_OPTION,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServerXMLHTTPRequest,
                option: SERVERXMLHTTP_OPTION,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLHTTPRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_setTimeouts(self: *const T, resolveTimeout: i32, connectTimeout: i32, sendTimeout: i32, receiveTimeout: i32) callconv(.Inline) HRESULT {
            return @as(*const IServerXMLHTTPRequest.VTable, @ptrCast(self.vtable)).setTimeouts(@as(*const IServerXMLHTTPRequest, @ptrCast(self)), resolveTimeout, connectTimeout, sendTimeout, receiveTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_waitForResponse(self: *const T, timeoutInSeconds: VARIANT, isSuccessful: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IServerXMLHTTPRequest.VTable, @ptrCast(self.vtable)).waitForResponse(@as(*const IServerXMLHTTPRequest, @ptrCast(self)), timeoutInSeconds, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_getOption(self: *const T, option: SERVERXMLHTTP_OPTION, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IServerXMLHTTPRequest.VTable, @ptrCast(self.vtable)).getOption(@as(*const IServerXMLHTTPRequest, @ptrCast(self)), option, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest_setOption(self: *const T, option: SERVERXMLHTTP_OPTION, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IServerXMLHTTPRequest.VTable, @ptrCast(self.vtable)).setOption(@as(*const IServerXMLHTTPRequest, @ptrCast(self)), option, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IServerXMLHTTPRequest2_Value = Guid.initString("2e01311b-c322-4b0a-bd77-b90cfdc8dce7");
pub const IID_IServerXMLHTTPRequest2 = &IID_IServerXMLHTTPRequest2_Value;
pub const IServerXMLHTTPRequest2 = extern struct {
    pub const VTable = extern struct {
        base: IServerXMLHTTPRequest.VTable,
        setProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServerXMLHTTPRequest2,
                proxySetting: SXH_PROXY_SETTING,
                varProxyServer: VARIANT,
                varBypassList: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServerXMLHTTPRequest2,
                proxySetting: SXH_PROXY_SETTING,
                varProxyServer: VARIANT,
                varBypassList: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProxyCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServerXMLHTTPRequest2,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServerXMLHTTPRequest2,
                bstrUserName: ?BSTR,
                bstrPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServerXMLHTTPRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest2_setProxy(self: *const T, proxySetting: SXH_PROXY_SETTING, varProxyServer: VARIANT, varBypassList: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IServerXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).setProxy(@as(*const IServerXMLHTTPRequest2, @ptrCast(self)), proxySetting, varProxyServer, varBypassList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServerXMLHTTPRequest2_setProxyCredentials(self: *const T, bstrUserName: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IServerXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).setProxyCredentials(@as(*const IServerXMLHTTPRequest2, @ptrCast(self)), bstrUserName, bstrPassword);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXXMLReader_Value = Guid.initString("a4f96ed0-f829-476e-81c0-cdc7bd2a0802");
pub const IID_ISAXXMLReader = &IID_ISAXXMLReader_Value;
pub const ISAXXMLReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                pvfValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                pvfValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                vfValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                vfValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchName: ?[*:0]const u16,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getEntityResolver: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                ppResolver: ?*?*ISAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                ppResolver: ?*?*ISAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putEntityResolver: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pResolver: ?*ISAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pResolver: ?*ISAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getContentHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                ppHandler: ?*?*ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                ppHandler: ?*?*ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putContentHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pHandler: ?*ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pHandler: ?*ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDTDHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                ppHandler: ?*?*ISAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                ppHandler: ?*?*ISAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putDTDHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pHandler: ?*ISAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pHandler: ?*ISAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getErrorHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                ppHandler: ?*?*ISAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                ppHandler: ?*?*ISAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putErrorHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pHandler: ?*ISAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pHandler: ?*ISAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getBaseURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                ppwchBaseUrl: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                ppwchBaseUrl: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putBaseURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchBaseUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchBaseUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getSecureBaseURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                ppwchSecureBaseUrl: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                ppwchSecureBaseUrl: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putSecureBaseURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchSecureBaseUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchSecureBaseUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        parse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                varInput: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                varInput: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        parseURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLReader,
                pwchUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLReader,
                pwchUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getFeature(self: *const T, pwchName: ?[*:0]const u16, pvfValue: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getFeature(@as(*const ISAXXMLReader, @ptrCast(self)), pwchName, pvfValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putFeature(self: *const T, pwchName: ?[*:0]const u16, vfValue: i16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putFeature(@as(*const ISAXXMLReader, @ptrCast(self)), pwchName, vfValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getProperty(self: *const T, pwchName: ?[*:0]const u16, pvarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getProperty(@as(*const ISAXXMLReader, @ptrCast(self)), pwchName, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putProperty(self: *const T, pwchName: ?[*:0]const u16, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putProperty(@as(*const ISAXXMLReader, @ptrCast(self)), pwchName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getEntityResolver(self: *const T, ppResolver: ?*?*ISAXEntityResolver) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getEntityResolver(@as(*const ISAXXMLReader, @ptrCast(self)), ppResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putEntityResolver(self: *const T, pResolver: ?*ISAXEntityResolver) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putEntityResolver(@as(*const ISAXXMLReader, @ptrCast(self)), pResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getContentHandler(self: *const T, ppHandler: ?*?*ISAXContentHandler) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getContentHandler(@as(*const ISAXXMLReader, @ptrCast(self)), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putContentHandler(self: *const T, pHandler: ?*ISAXContentHandler) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putContentHandler(@as(*const ISAXXMLReader, @ptrCast(self)), pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getDTDHandler(self: *const T, ppHandler: ?*?*ISAXDTDHandler) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getDTDHandler(@as(*const ISAXXMLReader, @ptrCast(self)), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putDTDHandler(self: *const T, pHandler: ?*ISAXDTDHandler) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putDTDHandler(@as(*const ISAXXMLReader, @ptrCast(self)), pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getErrorHandler(self: *const T, ppHandler: ?*?*ISAXErrorHandler) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getErrorHandler(@as(*const ISAXXMLReader, @ptrCast(self)), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putErrorHandler(self: *const T, pHandler: ?*ISAXErrorHandler) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putErrorHandler(@as(*const ISAXXMLReader, @ptrCast(self)), pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getBaseURL(self: *const T, ppwchBaseUrl: ?*const ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getBaseURL(@as(*const ISAXXMLReader, @ptrCast(self)), ppwchBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putBaseURL(self: *const T, pwchBaseUrl: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putBaseURL(@as(*const ISAXXMLReader, @ptrCast(self)), pwchBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_getSecureBaseURL(self: *const T, ppwchSecureBaseUrl: ?*const ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).getSecureBaseURL(@as(*const ISAXXMLReader, @ptrCast(self)), ppwchSecureBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_putSecureBaseURL(self: *const T, pwchSecureBaseUrl: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).putSecureBaseURL(@as(*const ISAXXMLReader, @ptrCast(self)), pwchSecureBaseUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_parse(self: *const T, varInput: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).parse(@as(*const ISAXXMLReader, @ptrCast(self)), varInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLReader_parseURL(self: *const T, pwchUrl: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLReader.VTable, @ptrCast(self.vtable)).parseURL(@as(*const ISAXXMLReader, @ptrCast(self)), pwchUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXXMLFilter_Value = Guid.initString("70409222-ca09-4475-acb8-40312fe8d145");
pub const IID_ISAXXMLFilter = &IID_ISAXXMLFilter_Value;
pub const ISAXXMLFilter = extern struct {
    pub const VTable = extern struct {
        base: ISAXXMLReader.VTable,
        getParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLFilter,
                ppReader: ?*?*ISAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLFilter,
                ppReader: ?*?*ISAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXXMLFilter,
                pReader: ?*ISAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXXMLFilter,
                pReader: ?*ISAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISAXXMLReader.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLFilter_getParent(self: *const T, ppReader: ?*?*ISAXXMLReader) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLFilter.VTable, @ptrCast(self.vtable)).getParent(@as(*const ISAXXMLFilter, @ptrCast(self)), ppReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXXMLFilter_putParent(self: *const T, pReader: ?*ISAXXMLReader) callconv(.Inline) HRESULT {
            return @as(*const ISAXXMLFilter.VTable, @ptrCast(self.vtable)).putParent(@as(*const ISAXXMLFilter, @ptrCast(self)), pReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXLocator_Value = Guid.initString("9b7e472a-0de4-4640-bff3-84d38a051c31");
pub const IID_ISAXLocator = &IID_ISAXLocator_Value;
pub const ISAXLocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getColumnNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLocator,
                pnColumn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLocator,
                pnColumn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getLineNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLocator,
                pnLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLocator,
                pnLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getPublicId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLocator,
                ppwchPublicId: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLocator,
                ppwchPublicId: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLocator,
                ppwchSystemId: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLocator,
                ppwchSystemId: ?*const ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getColumnNumber(self: *const T, pnColumn: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXLocator.VTable, @ptrCast(self.vtable)).getColumnNumber(@as(*const ISAXLocator, @ptrCast(self)), pnColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getLineNumber(self: *const T, pnLine: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXLocator.VTable, @ptrCast(self.vtable)).getLineNumber(@as(*const ISAXLocator, @ptrCast(self)), pnLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getPublicId(self: *const T, ppwchPublicId: ?*const ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXLocator.VTable, @ptrCast(self.vtable)).getPublicId(@as(*const ISAXLocator, @ptrCast(self)), ppwchPublicId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLocator_getSystemId(self: *const T, ppwchSystemId: ?*const ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISAXLocator.VTable, @ptrCast(self.vtable)).getSystemId(@as(*const ISAXLocator, @ptrCast(self)), ppwchSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXEntityResolver_Value = Guid.initString("99bca7bd-e8c4-4d5f-a0cf-6d907901ff07");
pub const IID_ISAXEntityResolver = &IID_ISAXEntityResolver_Value;
pub const ISAXEntityResolver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        resolveEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXEntityResolver,
                pwchPublicId: ?[*:0]const u16,
                pwchSystemId: ?[*:0]const u16,
                pvarInput: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXEntityResolver,
                pwchPublicId: ?[*:0]const u16,
                pwchSystemId: ?[*:0]const u16,
                pvarInput: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXEntityResolver_resolveEntity(self: *const T, pwchPublicId: ?[*:0]const u16, pwchSystemId: ?[*:0]const u16, pvarInput: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISAXEntityResolver.VTable, @ptrCast(self.vtable)).resolveEntity(@as(*const ISAXEntityResolver, @ptrCast(self)), pwchPublicId, pwchSystemId, pvarInput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXContentHandler_Value = Guid.initString("1545cdfa-9e4e-4497-a8a4-2bf7d0112c44");
pub const IID_ISAXContentHandler = &IID_ISAXContentHandler_Value;
pub const ISAXContentHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        putDocumentLocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pLocator: ?*ISAXLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pLocator: ?*ISAXLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startPrefixMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchPrefix: ?[*:0]const u16,
                cchPrefix: i32,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchPrefix: ?[*:0]const u16,
                cchPrefix: i32,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endPrefixMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchPrefix: ?[*:0]const u16,
                cchPrefix: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchPrefix: ?[*:0]const u16,
                cchPrefix: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchNamespaceUri: ?[*:0]const u16,
                cchNamespaceUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                pAttributes: ?*ISAXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchNamespaceUri: ?[*:0]const u16,
                cchNamespaceUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                pAttributes: ?*ISAXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchNamespaceUri: ?[*:0]const u16,
                cchNamespaceUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchNamespaceUri: ?[*:0]const u16,
                cchNamespaceUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        characters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchChars: ?[*:0]const u16,
                cchChars: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchChars: ?[*:0]const u16,
                cchChars: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ignorableWhitespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchChars: ?[*:0]const u16,
                cchChars: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchChars: ?[*:0]const u16,
                cchChars: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        processingInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchTarget: ?[*:0]const u16,
                cchTarget: i32,
                pwchData: ?[*:0]const u16,
                cchData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchTarget: ?[*:0]const u16,
                cchTarget: i32,
                pwchData: ?[*:0]const u16,
                cchData: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        skippedEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXContentHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXContentHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_putDocumentLocator(self: *const T, pLocator: ?*ISAXLocator) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).putDocumentLocator(@as(*const ISAXContentHandler, @ptrCast(self)), pLocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_startDocument(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).startDocument(@as(*const ISAXContentHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_endDocument(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).endDocument(@as(*const ISAXContentHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_startPrefixMapping(self: *const T, pwchPrefix: ?[*:0]const u16, cchPrefix: i32, pwchUri: ?[*:0]const u16, cchUri: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).startPrefixMapping(@as(*const ISAXContentHandler, @ptrCast(self)), pwchPrefix, cchPrefix, pwchUri, cchUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_endPrefixMapping(self: *const T, pwchPrefix: ?[*:0]const u16, cchPrefix: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).endPrefixMapping(@as(*const ISAXContentHandler, @ptrCast(self)), pwchPrefix, cchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_startElement(self: *const T, pwchNamespaceUri: ?[*:0]const u16, cchNamespaceUri: i32, pwchLocalName: ?[*:0]const u16, cchLocalName: i32, pwchQName: ?[*:0]const u16, cchQName: i32, pAttributes: ?*ISAXAttributes) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).startElement(@as(*const ISAXContentHandler, @ptrCast(self)), pwchNamespaceUri, cchNamespaceUri, pwchLocalName, cchLocalName, pwchQName, cchQName, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_endElement(self: *const T, pwchNamespaceUri: ?[*:0]const u16, cchNamespaceUri: i32, pwchLocalName: ?[*:0]const u16, cchLocalName: i32, pwchQName: ?[*:0]const u16, cchQName: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).endElement(@as(*const ISAXContentHandler, @ptrCast(self)), pwchNamespaceUri, cchNamespaceUri, pwchLocalName, cchLocalName, pwchQName, cchQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_characters(self: *const T, pwchChars: ?[*:0]const u16, cchChars: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).characters(@as(*const ISAXContentHandler, @ptrCast(self)), pwchChars, cchChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_ignorableWhitespace(self: *const T, pwchChars: ?[*:0]const u16, cchChars: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).ignorableWhitespace(@as(*const ISAXContentHandler, @ptrCast(self)), pwchChars, cchChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_processingInstruction(self: *const T, pwchTarget: ?[*:0]const u16, cchTarget: i32, pwchData: ?[*:0]const u16, cchData: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).processingInstruction(@as(*const ISAXContentHandler, @ptrCast(self)), pwchTarget, cchTarget, pwchData, cchData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXContentHandler_skippedEntity(self: *const T, pwchName: ?[*:0]const u16, cchName: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXContentHandler.VTable, @ptrCast(self.vtable)).skippedEntity(@as(*const ISAXContentHandler, @ptrCast(self)), pwchName, cchName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXDTDHandler_Value = Guid.initString("e15c1baf-afb3-4d60-8c36-19a8c45defed");
pub const IID_ISAXDTDHandler = &IID_ISAXDTDHandler_Value;
pub const ISAXDTDHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        notationDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXDTDHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXDTDHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        unparsedEntityDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXDTDHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
                pwchNotationName: ?[*:0]const u16,
                cchNotationName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXDTDHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
                pwchNotationName: ?[*:0]const u16,
                cchNotationName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDTDHandler_notationDecl(self: *const T, pwchName: ?[*:0]const u16, cchName: i32, pwchPublicId: ?[*:0]const u16, cchPublicId: i32, pwchSystemId: ?[*:0]const u16, cchSystemId: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXDTDHandler.VTable, @ptrCast(self.vtable)).notationDecl(@as(*const ISAXDTDHandler, @ptrCast(self)), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDTDHandler_unparsedEntityDecl(self: *const T, pwchName: ?[*:0]const u16, cchName: i32, pwchPublicId: ?[*:0]const u16, cchPublicId: i32, pwchSystemId: ?[*:0]const u16, cchSystemId: i32, pwchNotationName: ?[*:0]const u16, cchNotationName: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXDTDHandler.VTable, @ptrCast(self.vtable)).unparsedEntityDecl(@as(*const ISAXDTDHandler, @ptrCast(self)), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId, pwchNotationName, cchNotationName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXErrorHandler_Value = Guid.initString("a60511c4-ccf5-479e-98a3-dc8dc545b7d0");
pub const IID_ISAXErrorHandler = &IID_ISAXErrorHandler_Value;
pub const ISAXErrorHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        @"error": switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXErrorHandler,
                pLocator: ?*ISAXLocator,
                pwchErrorMessage: ?[*:0]const u16,
                hrErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXErrorHandler,
                pLocator: ?*ISAXLocator,
                pwchErrorMessage: ?[*:0]const u16,
                hrErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        fatalError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXErrorHandler,
                pLocator: ?*ISAXLocator,
                pwchErrorMessage: ?[*:0]const u16,
                hrErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXErrorHandler,
                pLocator: ?*ISAXLocator,
                pwchErrorMessage: ?[*:0]const u16,
                hrErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ignorableWarning: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXErrorHandler,
                pLocator: ?*ISAXLocator,
                pwchErrorMessage: ?[*:0]const u16,
                hrErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXErrorHandler,
                pLocator: ?*ISAXLocator,
                pwchErrorMessage: ?[*:0]const u16,
                hrErrorCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXErrorHandler_error(self: *const T, pLocator: ?*ISAXLocator, pwchErrorMessage: ?[*:0]const u16, hrErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ISAXErrorHandler.VTable, @ptrCast(self.vtable)).@"error"(@as(*const ISAXErrorHandler, @ptrCast(self)), pLocator, pwchErrorMessage, hrErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXErrorHandler_fatalError(self: *const T, pLocator: ?*ISAXLocator, pwchErrorMessage: ?[*:0]const u16, hrErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ISAXErrorHandler.VTable, @ptrCast(self.vtable)).fatalError(@as(*const ISAXErrorHandler, @ptrCast(self)), pLocator, pwchErrorMessage, hrErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXErrorHandler_ignorableWarning(self: *const T, pLocator: ?*ISAXLocator, pwchErrorMessage: ?[*:0]const u16, hrErrorCode: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ISAXErrorHandler.VTable, @ptrCast(self.vtable)).ignorableWarning(@as(*const ISAXErrorHandler, @ptrCast(self)), pLocator, pwchErrorMessage, hrErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXLexicalHandler_Value = Guid.initString("7f85d5f5-47a8-4497-bda5-84ba04819ea6");
pub const IID_ISAXLexicalHandler = &IID_ISAXLexicalHandler_Value;
pub const ISAXLexicalHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        startDTD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endDTD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startCDATA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endCDATA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        comment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXLexicalHandler,
                pwchChars: ?[*:0]const u16,
                cchChars: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXLexicalHandler,
                pwchChars: ?[*:0]const u16,
                cchChars: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_startDTD(self: *const T, pwchName: ?[*:0]const u16, cchName: i32, pwchPublicId: ?[*:0]const u16, cchPublicId: i32, pwchSystemId: ?[*:0]const u16, cchSystemId: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).startDTD(@as(*const ISAXLexicalHandler, @ptrCast(self)), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_endDTD(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).endDTD(@as(*const ISAXLexicalHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_startEntity(self: *const T, pwchName: ?[*:0]const u16, cchName: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).startEntity(@as(*const ISAXLexicalHandler, @ptrCast(self)), pwchName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_endEntity(self: *const T, pwchName: ?[*:0]const u16, cchName: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).endEntity(@as(*const ISAXLexicalHandler, @ptrCast(self)), pwchName, cchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_startCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).startCDATA(@as(*const ISAXLexicalHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_endCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).endCDATA(@as(*const ISAXLexicalHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXLexicalHandler_comment(self: *const T, pwchChars: ?[*:0]const u16, cchChars: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXLexicalHandler.VTable, @ptrCast(self.vtable)).comment(@as(*const ISAXLexicalHandler, @ptrCast(self)), pwchChars, cchChars);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXDeclHandler_Value = Guid.initString("862629ac-771a-47b2-8337-4e6843c1be90");
pub const IID_ISAXDeclHandler = &IID_ISAXDeclHandler_Value;
pub const ISAXDeclHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        elementDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXDeclHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchModel: ?[*:0]const u16,
                cchModel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXDeclHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchModel: ?[*:0]const u16,
                cchModel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        attributeDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXDeclHandler,
                pwchElementName: ?[*:0]const u16,
                cchElementName: i32,
                pwchAttributeName: ?[*:0]const u16,
                cchAttributeName: i32,
                pwchType: ?[*:0]const u16,
                cchType: i32,
                pwchValueDefault: ?[*:0]const u16,
                cchValueDefault: i32,
                pwchValue: ?[*:0]const u16,
                cchValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXDeclHandler,
                pwchElementName: ?[*:0]const u16,
                cchElementName: i32,
                pwchAttributeName: ?[*:0]const u16,
                cchAttributeName: i32,
                pwchType: ?[*:0]const u16,
                cchType: i32,
                pwchValueDefault: ?[*:0]const u16,
                cchValueDefault: i32,
                pwchValue: ?[*:0]const u16,
                cchValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        internalEntityDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXDeclHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchValue: ?[*:0]const u16,
                cchValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXDeclHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchValue: ?[*:0]const u16,
                cchValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        externalEntityDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXDeclHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXDeclHandler,
                pwchName: ?[*:0]const u16,
                cchName: i32,
                pwchPublicId: ?[*:0]const u16,
                cchPublicId: i32,
                pwchSystemId: ?[*:0]const u16,
                cchSystemId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_elementDecl(self: *const T, pwchName: ?[*:0]const u16, cchName: i32, pwchModel: ?[*:0]const u16, cchModel: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXDeclHandler.VTable, @ptrCast(self.vtable)).elementDecl(@as(*const ISAXDeclHandler, @ptrCast(self)), pwchName, cchName, pwchModel, cchModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_attributeDecl(self: *const T, pwchElementName: ?[*:0]const u16, cchElementName: i32, pwchAttributeName: ?[*:0]const u16, cchAttributeName: i32, pwchType: ?[*:0]const u16, cchType: i32, pwchValueDefault: ?[*:0]const u16, cchValueDefault: i32, pwchValue: ?[*:0]const u16, cchValue: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXDeclHandler.VTable, @ptrCast(self.vtable)).attributeDecl(@as(*const ISAXDeclHandler, @ptrCast(self)), pwchElementName, cchElementName, pwchAttributeName, cchAttributeName, pwchType, cchType, pwchValueDefault, cchValueDefault, pwchValue, cchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_internalEntityDecl(self: *const T, pwchName: ?[*:0]const u16, cchName: i32, pwchValue: ?[*:0]const u16, cchValue: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXDeclHandler.VTable, @ptrCast(self.vtable)).internalEntityDecl(@as(*const ISAXDeclHandler, @ptrCast(self)), pwchName, cchName, pwchValue, cchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXDeclHandler_externalEntityDecl(self: *const T, pwchName: ?[*:0]const u16, cchName: i32, pwchPublicId: ?[*:0]const u16, cchPublicId: i32, pwchSystemId: ?[*:0]const u16, cchSystemId: i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXDeclHandler.VTable, @ptrCast(self.vtable)).externalEntityDecl(@as(*const ISAXDeclHandler, @ptrCast(self)), pwchName, cchName, pwchPublicId, cchPublicId, pwchSystemId, cchSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISAXAttributes_Value = Guid.initString("f078abe1-45d2-4832-91ea-4466ce2f25c9");
pub const IID_ISAXAttributes = &IID_ISAXAttributes_Value;
pub const ISAXAttributes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pnLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pnLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getURI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchUri: ?*const ?*u16,
                pcchUri: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchUri: ?*const ?*u16,
                pcchUri: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getLocalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchLocalName: ?*const ?*u16,
                pcchLocalName: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchLocalName: ?*const ?*u16,
                pcchLocalName: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchQName: ?*const ?*u16,
                pcchQName: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchQName: ?*const ?*u16,
                pcchQName: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchUri: ?*const ?*u16,
                pcchUri: ?*i32,
                ppwchLocalName: ?*const ?*u16,
                pcchLocalName: ?*i32,
                ppwchQName: ?*const ?*u16,
                pcchQName: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchUri: ?*const ?*u16,
                pcchUri: ?*i32,
                ppwchLocalName: ?*const ?*u16,
                pcchLocalName: ?*i32,
                ppwchQName: ?*const ?*u16,
                pcchQName: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getIndexFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                pnIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                pnIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getIndexFromQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                pnIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                pnIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchType: ?*const ?*u16,
                pcchType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchType: ?*const ?*u16,
                pcchType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getTypeFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                ppwchType: ?*const ?*u16,
                pcchType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                ppwchType: ?*const ?*u16,
                pcchType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getTypeFromQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                ppwchType: ?*const ?*u16,
                pcchType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                ppwchType: ?*const ?*u16,
                pcchType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchValue: ?*const ?*u16,
                pcchValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                nIndex: i32,
                ppwchValue: ?*const ?*u16,
                pcchValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getValueFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                ppwchValue: ?*const ?*u16,
                pcchValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pwchUri: ?[*:0]const u16,
                cchUri: i32,
                pwchLocalName: ?[*:0]const u16,
                cchLocalName: i32,
                ppwchValue: ?*const ?*u16,
                pcchValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getValueFromQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISAXAttributes,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                ppwchValue: ?*const ?*u16,
                pcchValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISAXAttributes,
                pwchQName: ?[*:0]const u16,
                cchQName: i32,
                ppwchValue: ?*const ?*u16,
                pcchValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getLength(self: *const T, pnLength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getLength(@as(*const ISAXAttributes, @ptrCast(self)), pnLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getURI(self: *const T, nIndex: i32, ppwchUri: ?*const ?*u16, pcchUri: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getURI(@as(*const ISAXAttributes, @ptrCast(self)), nIndex, ppwchUri, pcchUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getLocalName(self: *const T, nIndex: i32, ppwchLocalName: ?*const ?*u16, pcchLocalName: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getLocalName(@as(*const ISAXAttributes, @ptrCast(self)), nIndex, ppwchLocalName, pcchLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getQName(self: *const T, nIndex: i32, ppwchQName: ?*const ?*u16, pcchQName: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getQName(@as(*const ISAXAttributes, @ptrCast(self)), nIndex, ppwchQName, pcchQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getName(self: *const T, nIndex: i32, ppwchUri: ?*const ?*u16, pcchUri: ?*i32, ppwchLocalName: ?*const ?*u16, pcchLocalName: ?*i32, ppwchQName: ?*const ?*u16, pcchQName: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getName(@as(*const ISAXAttributes, @ptrCast(self)), nIndex, ppwchUri, pcchUri, ppwchLocalName, pcchLocalName, ppwchQName, pcchQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getIndexFromName(self: *const T, pwchUri: ?[*:0]const u16, cchUri: i32, pwchLocalName: ?[*:0]const u16, cchLocalName: i32, pnIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getIndexFromName(@as(*const ISAXAttributes, @ptrCast(self)), pwchUri, cchUri, pwchLocalName, cchLocalName, pnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getIndexFromQName(self: *const T, pwchQName: ?[*:0]const u16, cchQName: i32, pnIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getIndexFromQName(@as(*const ISAXAttributes, @ptrCast(self)), pwchQName, cchQName, pnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getType(self: *const T, nIndex: i32, ppwchType: ?*const ?*u16, pcchType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getType(@as(*const ISAXAttributes, @ptrCast(self)), nIndex, ppwchType, pcchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getTypeFromName(self: *const T, pwchUri: ?[*:0]const u16, cchUri: i32, pwchLocalName: ?[*:0]const u16, cchLocalName: i32, ppwchType: ?*const ?*u16, pcchType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getTypeFromName(@as(*const ISAXAttributes, @ptrCast(self)), pwchUri, cchUri, pwchLocalName, cchLocalName, ppwchType, pcchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getTypeFromQName(self: *const T, pwchQName: ?[*:0]const u16, cchQName: i32, ppwchType: ?*const ?*u16, pcchType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getTypeFromQName(@as(*const ISAXAttributes, @ptrCast(self)), pwchQName, cchQName, ppwchType, pcchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getValue(self: *const T, nIndex: i32, ppwchValue: ?*const ?*u16, pcchValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getValue(@as(*const ISAXAttributes, @ptrCast(self)), nIndex, ppwchValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getValueFromName(self: *const T, pwchUri: ?[*:0]const u16, cchUri: i32, pwchLocalName: ?[*:0]const u16, cchLocalName: i32, ppwchValue: ?*const ?*u16, pcchValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getValueFromName(@as(*const ISAXAttributes, @ptrCast(self)), pwchUri, cchUri, pwchLocalName, cchLocalName, ppwchValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISAXAttributes_getValueFromQName(self: *const T, pwchQName: ?[*:0]const u16, cchQName: i32, ppwchValue: ?*const ?*u16, pcchValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISAXAttributes.VTable, @ptrCast(self.vtable)).getValueFromQName(@as(*const ISAXAttributes, @ptrCast(self)), pwchQName, cchQName, ppwchValue, pcchValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXXMLReader_Value = Guid.initString("8c033caa-6cd6-4f73-b728-4531af74945f");
pub const IID_IVBSAXXMLReader = &IID_IVBSAXXMLReader_Value;
pub const IVBSAXXMLReader = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                varValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                varValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strName: ?BSTR,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entityResolver: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oResolver: ?*?*IVBSAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oResolver: ?*?*IVBSAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_entityResolver: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oResolver: ?*IVBSAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oResolver: ?*IVBSAXEntityResolver,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*?*IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*?*IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_contentHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*?*IVBSAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*?*IVBSAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_dtdHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*IVBSAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*IVBSAXDTDHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*?*IVBSAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*?*IVBSAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_errorHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*IVBSAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                oHandler: ?*IVBSAXErrorHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strBaseURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strBaseURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_secureBaseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strSecureBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strSecureBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_secureBaseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strSecureBaseURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strSecureBaseURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        parse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                varInput: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                varInput: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        parseURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLReader,
                strURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLReader,
                strURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_getFeature(self: *const T, strName: ?BSTR, fValue: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).getFeature(@as(*const IVBSAXXMLReader, @ptrCast(self)), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putFeature(self: *const T, strName: ?BSTR, fValue: i16) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).putFeature(@as(*const IVBSAXXMLReader, @ptrCast(self)), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_getProperty(self: *const T, strName: ?BSTR, varValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).getProperty(@as(*const IVBSAXXMLReader, @ptrCast(self)), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putProperty(self: *const T, strName: ?BSTR, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).putProperty(@as(*const IVBSAXXMLReader, @ptrCast(self)), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_entityResolver(self: *const T, oResolver: ?*?*IVBSAXEntityResolver) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).get_entityResolver(@as(*const IVBSAXXMLReader, @ptrCast(self)), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_entityResolver(self: *const T, oResolver: ?*IVBSAXEntityResolver) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).putref_entityResolver(@as(*const IVBSAXXMLReader, @ptrCast(self)), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_contentHandler(self: *const T, oHandler: ?*?*IVBSAXContentHandler) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).get_contentHandler(@as(*const IVBSAXXMLReader, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_contentHandler(self: *const T, oHandler: ?*IVBSAXContentHandler) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).putref_contentHandler(@as(*const IVBSAXXMLReader, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_dtdHandler(self: *const T, oHandler: ?*?*IVBSAXDTDHandler) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).get_dtdHandler(@as(*const IVBSAXXMLReader, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_dtdHandler(self: *const T, oHandler: ?*IVBSAXDTDHandler) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).putref_dtdHandler(@as(*const IVBSAXXMLReader, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_errorHandler(self: *const T, oHandler: ?*?*IVBSAXErrorHandler) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).get_errorHandler(@as(*const IVBSAXXMLReader, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_putref_errorHandler(self: *const T, oHandler: ?*IVBSAXErrorHandler) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).putref_errorHandler(@as(*const IVBSAXXMLReader, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_baseURL(self: *const T, strBaseURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).get_baseURL(@as(*const IVBSAXXMLReader, @ptrCast(self)), strBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_put_baseURL(self: *const T, strBaseURL: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).put_baseURL(@as(*const IVBSAXXMLReader, @ptrCast(self)), strBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_get_secureBaseURL(self: *const T, strSecureBaseURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).get_secureBaseURL(@as(*const IVBSAXXMLReader, @ptrCast(self)), strSecureBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_put_secureBaseURL(self: *const T, strSecureBaseURL: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).put_secureBaseURL(@as(*const IVBSAXXMLReader, @ptrCast(self)), strSecureBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_parse(self: *const T, varInput: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).parse(@as(*const IVBSAXXMLReader, @ptrCast(self)), varInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLReader_parseURL(self: *const T, strURL: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLReader.VTable, @ptrCast(self.vtable)).parseURL(@as(*const IVBSAXXMLReader, @ptrCast(self)), strURL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXXMLFilter_Value = Guid.initString("1299eb1b-5b88-433e-82de-82ca75ad4e04");
pub const IID_IVBSAXXMLFilter = &IID_IVBSAXXMLFilter_Value;
pub const IVBSAXXMLFilter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXXMLFilter,
                oReader: ?*?*IVBSAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXXMLFilter,
                oReader: ?*?*IVBSAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_parent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXXMLFilter,
                oReader: ?*IVBSAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXXMLFilter,
                oReader: ?*IVBSAXXMLReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLFilter_get_parent(self: *const T, oReader: ?*?*IVBSAXXMLReader) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLFilter.VTable, @ptrCast(self.vtable)).get_parent(@as(*const IVBSAXXMLFilter, @ptrCast(self)), oReader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXXMLFilter_putref_parent(self: *const T, oReader: ?*IVBSAXXMLReader) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXXMLFilter.VTable, @ptrCast(self.vtable)).putref_parent(@as(*const IVBSAXXMLFilter, @ptrCast(self)), oReader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXLocator_Value = Guid.initString("796e7ac5-5aa2-4eff-acad-3faaf01a3288");
pub const IID_IVBSAXLocator = &IID_IVBSAXLocator_Value;
pub const IVBSAXLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_columnNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXLocator,
                nColumn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXLocator,
                nColumn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lineNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXLocator,
                nLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXLocator,
                nLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXLocator,
                strPublicId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXLocator,
                strPublicId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXLocator,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXLocator,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_columnNumber(self: *const T, nColumn: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLocator.VTable, @ptrCast(self.vtable)).get_columnNumber(@as(*const IVBSAXLocator, @ptrCast(self)), nColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_lineNumber(self: *const T, nLine: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLocator.VTable, @ptrCast(self.vtable)).get_lineNumber(@as(*const IVBSAXLocator, @ptrCast(self)), nLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_publicId(self: *const T, strPublicId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLocator.VTable, @ptrCast(self.vtable)).get_publicId(@as(*const IVBSAXLocator, @ptrCast(self)), strPublicId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLocator_get_systemId(self: *const T, strSystemId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLocator.VTable, @ptrCast(self.vtable)).get_systemId(@as(*const IVBSAXLocator, @ptrCast(self)), strSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXEntityResolver_Value = Guid.initString("0c05d096-f45b-4aca-ad1a-aa0bc25518dc");
pub const IID_IVBSAXEntityResolver = &IID_IVBSAXEntityResolver_Value;
pub const IVBSAXEntityResolver = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        resolveEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXEntityResolver,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
                varInput: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXEntityResolver,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
                varInput: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXEntityResolver_resolveEntity(self: *const T, strPublicId: ?*?BSTR, strSystemId: ?*?BSTR, varInput: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXEntityResolver.VTable, @ptrCast(self.vtable)).resolveEntity(@as(*const IVBSAXEntityResolver, @ptrCast(self)), strPublicId, strSystemId, varInput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXContentHandler_Value = Guid.initString("2ed7290a-4dd5-4b46-bb26-4e4155e77faa");
pub const IID_IVBSAXContentHandler = &IID_IVBSAXContentHandler_Value;
pub const IVBSAXContentHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_documentLocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                oLocator: ?*IVBSAXLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                oLocator: ?*IVBSAXLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startPrefixMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strPrefix: ?*?BSTR,
                strURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strPrefix: ?*?BSTR,
                strURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endPrefixMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strPrefix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strPrefix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strNamespaceURI: ?*?BSTR,
                strLocalName: ?*?BSTR,
                strQName: ?*?BSTR,
                oAttributes: ?*IVBSAXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strNamespaceURI: ?*?BSTR,
                strLocalName: ?*?BSTR,
                strQName: ?*?BSTR,
                oAttributes: ?*IVBSAXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strNamespaceURI: ?*?BSTR,
                strLocalName: ?*?BSTR,
                strQName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strNamespaceURI: ?*?BSTR,
                strLocalName: ?*?BSTR,
                strQName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        characters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ignorableWhitespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        processingInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strTarget: ?*?BSTR,
                strData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strTarget: ?*?BSTR,
                strData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        skippedEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXContentHandler,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXContentHandler,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_putref_documentLocator(self: *const T, oLocator: ?*IVBSAXLocator) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).putref_documentLocator(@as(*const IVBSAXContentHandler, @ptrCast(self)), oLocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_startDocument(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).startDocument(@as(*const IVBSAXContentHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_endDocument(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).endDocument(@as(*const IVBSAXContentHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_startPrefixMapping(self: *const T, strPrefix: ?*?BSTR, strURI: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).startPrefixMapping(@as(*const IVBSAXContentHandler, @ptrCast(self)), strPrefix, strURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_endPrefixMapping(self: *const T, strPrefix: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).endPrefixMapping(@as(*const IVBSAXContentHandler, @ptrCast(self)), strPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_startElement(self: *const T, strNamespaceURI: ?*?BSTR, strLocalName: ?*?BSTR, strQName: ?*?BSTR, oAttributes: ?*IVBSAXAttributes) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).startElement(@as(*const IVBSAXContentHandler, @ptrCast(self)), strNamespaceURI, strLocalName, strQName, oAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_endElement(self: *const T, strNamespaceURI: ?*?BSTR, strLocalName: ?*?BSTR, strQName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).endElement(@as(*const IVBSAXContentHandler, @ptrCast(self)), strNamespaceURI, strLocalName, strQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_characters(self: *const T, strChars: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).characters(@as(*const IVBSAXContentHandler, @ptrCast(self)), strChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_ignorableWhitespace(self: *const T, strChars: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).ignorableWhitespace(@as(*const IVBSAXContentHandler, @ptrCast(self)), strChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_processingInstruction(self: *const T, strTarget: ?*?BSTR, strData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).processingInstruction(@as(*const IVBSAXContentHandler, @ptrCast(self)), strTarget, strData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXContentHandler_skippedEntity(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXContentHandler.VTable, @ptrCast(self.vtable)).skippedEntity(@as(*const IVBSAXContentHandler, @ptrCast(self)), strName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXDTDHandler_Value = Guid.initString("24fb3297-302d-4620-ba39-3a732d850558");
pub const IID_IVBSAXDTDHandler = &IID_IVBSAXDTDHandler_Value;
pub const IVBSAXDTDHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        notationDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXDTDHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXDTDHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        unparsedEntityDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXDTDHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
                strNotationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXDTDHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
                strNotationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDTDHandler_notationDecl(self: *const T, strName: ?*?BSTR, strPublicId: ?*?BSTR, strSystemId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXDTDHandler.VTable, @ptrCast(self.vtable)).notationDecl(@as(*const IVBSAXDTDHandler, @ptrCast(self)), strName, strPublicId, strSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDTDHandler_unparsedEntityDecl(self: *const T, strName: ?*?BSTR, strPublicId: ?*?BSTR, strSystemId: ?*?BSTR, strNotationName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXDTDHandler.VTable, @ptrCast(self.vtable)).unparsedEntityDecl(@as(*const IVBSAXDTDHandler, @ptrCast(self)), strName, strPublicId, strSystemId, strNotationName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXErrorHandler_Value = Guid.initString("d963d3fe-173c-4862-9095-b92f66995f52");
pub const IID_IVBSAXErrorHandler = &IID_IVBSAXErrorHandler_Value;
pub const IVBSAXErrorHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        @"error": switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXErrorHandler,
                oLocator: ?*IVBSAXLocator,
                strErrorMessage: ?*?BSTR,
                nErrorCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXErrorHandler,
                oLocator: ?*IVBSAXLocator,
                strErrorMessage: ?*?BSTR,
                nErrorCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        fatalError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXErrorHandler,
                oLocator: ?*IVBSAXLocator,
                strErrorMessage: ?*?BSTR,
                nErrorCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXErrorHandler,
                oLocator: ?*IVBSAXLocator,
                strErrorMessage: ?*?BSTR,
                nErrorCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ignorableWarning: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXErrorHandler,
                oLocator: ?*IVBSAXLocator,
                strErrorMessage: ?*?BSTR,
                nErrorCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXErrorHandler,
                oLocator: ?*IVBSAXLocator,
                strErrorMessage: ?*?BSTR,
                nErrorCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXErrorHandler_error(self: *const T, oLocator: ?*IVBSAXLocator, strErrorMessage: ?*?BSTR, nErrorCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXErrorHandler.VTable, @ptrCast(self.vtable)).@"error"(@as(*const IVBSAXErrorHandler, @ptrCast(self)), oLocator, strErrorMessage, nErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXErrorHandler_fatalError(self: *const T, oLocator: ?*IVBSAXLocator, strErrorMessage: ?*?BSTR, nErrorCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXErrorHandler.VTable, @ptrCast(self.vtable)).fatalError(@as(*const IVBSAXErrorHandler, @ptrCast(self)), oLocator, strErrorMessage, nErrorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXErrorHandler_ignorableWarning(self: *const T, oLocator: ?*IVBSAXLocator, strErrorMessage: ?*?BSTR, nErrorCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXErrorHandler.VTable, @ptrCast(self.vtable)).ignorableWarning(@as(*const IVBSAXErrorHandler, @ptrCast(self)), oLocator, strErrorMessage, nErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXLexicalHandler_Value = Guid.initString("032aac35-8c0e-4d9d-979f-e3b702935576");
pub const IID_IVBSAXLexicalHandler = &IID_IVBSAXLexicalHandler_Value;
pub const IVBSAXLexicalHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDTD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endDTD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endEntity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startCDATA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        endCDATA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        comment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXLexicalHandler,
                strChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXLexicalHandler,
                strChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_startDTD(self: *const T, strName: ?*?BSTR, strPublicId: ?*?BSTR, strSystemId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).startDTD(@as(*const IVBSAXLexicalHandler, @ptrCast(self)), strName, strPublicId, strSystemId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_endDTD(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).endDTD(@as(*const IVBSAXLexicalHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_startEntity(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).startEntity(@as(*const IVBSAXLexicalHandler, @ptrCast(self)), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_endEntity(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).endEntity(@as(*const IVBSAXLexicalHandler, @ptrCast(self)), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_startCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).startCDATA(@as(*const IVBSAXLexicalHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_endCDATA(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).endCDATA(@as(*const IVBSAXLexicalHandler, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXLexicalHandler_comment(self: *const T, strChars: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXLexicalHandler.VTable, @ptrCast(self.vtable)).comment(@as(*const IVBSAXLexicalHandler, @ptrCast(self)), strChars);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXDeclHandler_Value = Guid.initString("e8917260-7579-4be1-b5dd-7afbfa6f077b");
pub const IID_IVBSAXDeclHandler = &IID_IVBSAXDeclHandler_Value;
pub const IVBSAXDeclHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        elementDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXDeclHandler,
                strName: ?*?BSTR,
                strModel: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXDeclHandler,
                strName: ?*?BSTR,
                strModel: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        attributeDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXDeclHandler,
                strElementName: ?*?BSTR,
                strAttributeName: ?*?BSTR,
                strType: ?*?BSTR,
                strValueDefault: ?*?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXDeclHandler,
                strElementName: ?*?BSTR,
                strAttributeName: ?*?BSTR,
                strType: ?*?BSTR,
                strValueDefault: ?*?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        internalEntityDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXDeclHandler,
                strName: ?*?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXDeclHandler,
                strName: ?*?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        externalEntityDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXDeclHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXDeclHandler,
                strName: ?*?BSTR,
                strPublicId: ?*?BSTR,
                strSystemId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_elementDecl(self: *const T, strName: ?*?BSTR, strModel: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXDeclHandler.VTable, @ptrCast(self.vtable)).elementDecl(@as(*const IVBSAXDeclHandler, @ptrCast(self)), strName, strModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_attributeDecl(self: *const T, strElementName: ?*?BSTR, strAttributeName: ?*?BSTR, strType: ?*?BSTR, strValueDefault: ?*?BSTR, strValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXDeclHandler.VTable, @ptrCast(self.vtable)).attributeDecl(@as(*const IVBSAXDeclHandler, @ptrCast(self)), strElementName, strAttributeName, strType, strValueDefault, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_internalEntityDecl(self: *const T, strName: ?*?BSTR, strValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXDeclHandler.VTable, @ptrCast(self.vtable)).internalEntityDecl(@as(*const IVBSAXDeclHandler, @ptrCast(self)), strName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXDeclHandler_externalEntityDecl(self: *const T, strName: ?*?BSTR, strPublicId: ?*?BSTR, strSystemId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXDeclHandler.VTable, @ptrCast(self.vtable)).externalEntityDecl(@as(*const IVBSAXDeclHandler, @ptrCast(self)), strName, strPublicId, strSystemId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBSAXAttributes_Value = Guid.initString("10dc0586-132b-4cac-8bb3-db00ac8b7ee0");
pub const IID_IVBSAXAttributes = &IID_IVBSAXAttributes_Value;
pub const IVBSAXAttributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                nLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBSAXAttributes,
                nLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getURI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getLocalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strLocalName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strLocalName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strQName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strQName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getIndexFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                nIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                nIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getIndexFromQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                strQName: ?BSTR,
                nIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                strQName: ?BSTR,
                nIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getTypeFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getTypeFromQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                strQName: ?BSTR,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                strQName: ?BSTR,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                nIndex: i32,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getValueFromName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getValueFromQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBSAXAttributes,
                strQName: ?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBSAXAttributes,
                strQName: ?BSTR,
                strValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_get_length(self: *const T, nLength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).get_length(@as(*const IVBSAXAttributes, @ptrCast(self)), nLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getURI(self: *const T, nIndex: i32, strURI: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getURI(@as(*const IVBSAXAttributes, @ptrCast(self)), nIndex, strURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getLocalName(self: *const T, nIndex: i32, strLocalName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getLocalName(@as(*const IVBSAXAttributes, @ptrCast(self)), nIndex, strLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getQName(self: *const T, nIndex: i32, strQName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getQName(@as(*const IVBSAXAttributes, @ptrCast(self)), nIndex, strQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getIndexFromName(self: *const T, strURI: ?BSTR, strLocalName: ?BSTR, nIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getIndexFromName(@as(*const IVBSAXAttributes, @ptrCast(self)), strURI, strLocalName, nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getIndexFromQName(self: *const T, strQName: ?BSTR, nIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getIndexFromQName(@as(*const IVBSAXAttributes, @ptrCast(self)), strQName, nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getType(self: *const T, nIndex: i32, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getType(@as(*const IVBSAXAttributes, @ptrCast(self)), nIndex, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getTypeFromName(self: *const T, strURI: ?BSTR, strLocalName: ?BSTR, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getTypeFromName(@as(*const IVBSAXAttributes, @ptrCast(self)), strURI, strLocalName, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getTypeFromQName(self: *const T, strQName: ?BSTR, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getTypeFromQName(@as(*const IVBSAXAttributes, @ptrCast(self)), strQName, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getValue(self: *const T, nIndex: i32, strValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getValue(@as(*const IVBSAXAttributes, @ptrCast(self)), nIndex, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getValueFromName(self: *const T, strURI: ?BSTR, strLocalName: ?BSTR, strValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getValueFromName(@as(*const IVBSAXAttributes, @ptrCast(self)), strURI, strLocalName, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBSAXAttributes_getValueFromQName(self: *const T, strQName: ?BSTR, strValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBSAXAttributes.VTable, @ptrCast(self.vtable)).getValueFromQName(@as(*const IVBSAXAttributes, @ptrCast(self)), strQName, strValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXWriter_Value = Guid.initString("4d7ff4ba-1565-4ea8-94e1-6e724a46f98d");
pub const IID_IMXWriter = &IID_IMXWriter_Value;
pub const IMXWriter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_output: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                varDestination: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                varDestination: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_output: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                varDestination: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                varDestination: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_encoding: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                strEncoding: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                strEncoding: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_encoding: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                strEncoding: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                strEncoding: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_byteOrderMark: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fWriteByteOrderMark: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fWriteByteOrderMark: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_byteOrderMark: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fWriteByteOrderMark: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fWriteByteOrderMark: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_indent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fIndentMode: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fIndentMode: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_indent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fIndentMode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fIndentMode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_standalone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_standalone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_omitXMLDeclaration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_omitXMLDeclaration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                strVersion: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                strVersion: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                strVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                strVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_disableOutputEscaping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disableOutputEscaping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXWriter,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXWriter,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_output(self: *const T, varDestination: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_output(@as(*const IMXWriter, @ptrCast(self)), varDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_output(self: *const T, varDestination: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_output(@as(*const IMXWriter, @ptrCast(self)), varDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_encoding(self: *const T, strEncoding: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_encoding(@as(*const IMXWriter, @ptrCast(self)), strEncoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_encoding(self: *const T, strEncoding: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_encoding(@as(*const IMXWriter, @ptrCast(self)), strEncoding);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_byteOrderMark(self: *const T, fWriteByteOrderMark: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_byteOrderMark(@as(*const IMXWriter, @ptrCast(self)), fWriteByteOrderMark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_byteOrderMark(self: *const T, fWriteByteOrderMark: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_byteOrderMark(@as(*const IMXWriter, @ptrCast(self)), fWriteByteOrderMark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_indent(self: *const T, fIndentMode: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_indent(@as(*const IMXWriter, @ptrCast(self)), fIndentMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_indent(self: *const T, fIndentMode: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_indent(@as(*const IMXWriter, @ptrCast(self)), fIndentMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_standalone(self: *const T, fValue: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_standalone(@as(*const IMXWriter, @ptrCast(self)), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_standalone(self: *const T, fValue: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_standalone(@as(*const IMXWriter, @ptrCast(self)), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_omitXMLDeclaration(self: *const T, fValue: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_omitXMLDeclaration(@as(*const IMXWriter, @ptrCast(self)), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_omitXMLDeclaration(self: *const T, fValue: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_omitXMLDeclaration(@as(*const IMXWriter, @ptrCast(self)), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_version(self: *const T, strVersion: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_version(@as(*const IMXWriter, @ptrCast(self)), strVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_version(self: *const T, strVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_version(@as(*const IMXWriter, @ptrCast(self)), strVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_put_disableOutputEscaping(self: *const T, fValue: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).put_disableOutputEscaping(@as(*const IMXWriter, @ptrCast(self)), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_get_disableOutputEscaping(self: *const T, fValue: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).get_disableOutputEscaping(@as(*const IMXWriter, @ptrCast(self)), fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXWriter_flush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXWriter.VTable, @ptrCast(self.vtable)).flush(@as(*const IMXWriter, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXAttributes_Value = Guid.initString("f10d27cc-3ec0-415c-8ed8-77ab1c5e7262");
pub const IID_IMXAttributes = &IID_IMXAttributes_Value;
pub const IMXAttributes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strQName: ?BSTR,
                strType: ?BSTR,
                strValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strQName: ?BSTR,
                strType: ?BSTR,
                strValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        addAttributeFromIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                varAtts: VARIANT,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                varAtts: VARIANT,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strQName: ?BSTR,
                strType: ?BSTR,
                strValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strURI: ?BSTR,
                strLocalName: ?BSTR,
                strQName: ?BSTR,
                strType: ?BSTR,
                strValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                varAtts: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                varAtts: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setLocalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strLocalName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strLocalName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strQName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strQName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setURI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXAttributes,
                nIndex: i32,
                strValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_addAttribute(self: *const T, strURI: ?BSTR, strLocalName: ?BSTR, strQName: ?BSTR, strType: ?BSTR, strValue: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).addAttribute(@as(*const IMXAttributes, @ptrCast(self)), strURI, strLocalName, strQName, strType, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_addAttributeFromIndex(self: *const T, varAtts: VARIANT, nIndex: i32) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).addAttributeFromIndex(@as(*const IMXAttributes, @ptrCast(self)), varAtts, nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_clear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).clear(@as(*const IMXAttributes, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_removeAttribute(self: *const T, nIndex: i32) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).removeAttribute(@as(*const IMXAttributes, @ptrCast(self)), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setAttribute(self: *const T, nIndex: i32, strURI: ?BSTR, strLocalName: ?BSTR, strQName: ?BSTR, strType: ?BSTR, strValue: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setAttribute(@as(*const IMXAttributes, @ptrCast(self)), nIndex, strURI, strLocalName, strQName, strType, strValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setAttributes(self: *const T, varAtts: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setAttributes(@as(*const IMXAttributes, @ptrCast(self)), varAtts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setLocalName(self: *const T, nIndex: i32, strLocalName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setLocalName(@as(*const IMXAttributes, @ptrCast(self)), nIndex, strLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setQName(self: *const T, nIndex: i32, strQName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setQName(@as(*const IMXAttributes, @ptrCast(self)), nIndex, strQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setType(self: *const T, nIndex: i32, strType: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setType(@as(*const IMXAttributes, @ptrCast(self)), nIndex, strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setURI(self: *const T, nIndex: i32, strURI: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setURI(@as(*const IMXAttributes, @ptrCast(self)), nIndex, strURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXAttributes_setValue(self: *const T, nIndex: i32, strValue: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXAttributes.VTable, @ptrCast(self.vtable)).setValue(@as(*const IMXAttributes, @ptrCast(self)), nIndex, strValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXReaderControl_Value = Guid.initString("808f4e35-8d5a-4fbe-8466-33a41279ed30");
pub const IID_IMXReaderControl = &IID_IMXReaderControl_Value;
pub const IMXReaderControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXReaderControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXReaderControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        @"resume": switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXReaderControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXReaderControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        @"suspend": switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXReaderControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXReaderControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXReaderControl_abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXReaderControl.VTable, @ptrCast(self.vtable)).abort(@as(*const IMXReaderControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXReaderControl_resume(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXReaderControl.VTable, @ptrCast(self.vtable)).@"resume"(@as(*const IMXReaderControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXReaderControl_suspend(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXReaderControl.VTable, @ptrCast(self.vtable)).@"suspend"(@as(*const IMXReaderControl, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXSchemaDeclHandler_Value = Guid.initString("fa4bb38c-faf9-4cca-9302-d1dd0fe520db");
pub const IID_IMXSchemaDeclHandler = &IID_IMXSchemaDeclHandler_Value;
pub const IMXSchemaDeclHandler = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        schemaElementDecl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXSchemaDeclHandler,
                oSchemaElement: ?*ISchemaElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXSchemaDeclHandler,
                oSchemaElement: ?*ISchemaElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXSchemaDeclHandler_schemaElementDecl(self: *const T, oSchemaElement: ?*ISchemaElement) callconv(.Inline) HRESULT {
            return @as(*const IMXSchemaDeclHandler.VTable, @ptrCast(self.vtable)).schemaElementDecl(@as(*const IMXSchemaDeclHandler, @ptrCast(self)), oSchemaElement);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXNamespacePrefixes_Value = Guid.initString("c90352f4-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IMXNamespacePrefixes = &IID_IMXNamespacePrefixes_Value;
pub const IMXNamespacePrefixes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXNamespacePrefixes,
                index: i32,
                prefix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXNamespacePrefixes,
                index: i32,
                prefix: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXNamespacePrefixes,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXNamespacePrefixes,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXNamespacePrefixes,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXNamespacePrefixes,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespacePrefixes_get_item(self: *const T, index: i32, prefix: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespacePrefixes.VTable, @ptrCast(self.vtable)).get_item(@as(*const IMXNamespacePrefixes, @ptrCast(self)), index, prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespacePrefixes_get_length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespacePrefixes.VTable, @ptrCast(self.vtable)).get_length(@as(*const IMXNamespacePrefixes, @ptrCast(self)), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespacePrefixes_get__newEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespacePrefixes.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const IMXNamespacePrefixes, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVBMXNamespaceManager_Value = Guid.initString("c90352f5-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IVBMXNamespaceManager = &IID_IVBMXNamespaceManager_Value;
pub const IVBMXNamespaceManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_allowOverride: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                fOverride: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                fOverride: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_allowOverride: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                fOverride: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                fOverride: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        pushContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        pushNodeContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                contextNode: ?*IXMLDOMNode,
                fDeep: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                contextNode: ?*IXMLDOMNode,
                fDeep: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        popContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        declarePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                prefix: ?BSTR,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                prefix: ?BSTR,
                namespaceURI: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDeclaredPrefixes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                prefixes: ?*?*IMXNamespacePrefixes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                prefixes: ?*?*IMXNamespacePrefixes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getPrefixes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                namespaceURI: ?BSTR,
                prefixes: ?*?*IMXNamespacePrefixes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                namespaceURI: ?BSTR,
                prefixes: ?*?*IMXNamespacePrefixes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getURI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                prefix: ?BSTR,
                uri: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                prefix: ?BSTR,
                uri: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getURIFromNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVBMXNamespaceManager,
                strPrefix: ?BSTR,
                contextNode: ?*IXMLDOMNode,
                uri: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVBMXNamespaceManager,
                strPrefix: ?BSTR,
                contextNode: ?*IXMLDOMNode,
                uri: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_put_allowOverride(self: *const T, fOverride: i16) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).put_allowOverride(@as(*const IVBMXNamespaceManager, @ptrCast(self)), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_get_allowOverride(self: *const T, fOverride: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).get_allowOverride(@as(*const IVBMXNamespaceManager, @ptrCast(self)), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).reset(@as(*const IVBMXNamespaceManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_pushContext(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).pushContext(@as(*const IVBMXNamespaceManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_pushNodeContext(self: *const T, contextNode: ?*IXMLDOMNode, fDeep: i16) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).pushNodeContext(@as(*const IVBMXNamespaceManager, @ptrCast(self)), contextNode, fDeep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_popContext(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).popContext(@as(*const IVBMXNamespaceManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_declarePrefix(self: *const T, prefix: ?BSTR, namespaceURI: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).declarePrefix(@as(*const IVBMXNamespaceManager, @ptrCast(self)), prefix, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getDeclaredPrefixes(self: *const T, prefixes: ?*?*IMXNamespacePrefixes) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).getDeclaredPrefixes(@as(*const IVBMXNamespaceManager, @ptrCast(self)), prefixes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getPrefixes(self: *const T, namespaceURI: ?BSTR, prefixes: ?*?*IMXNamespacePrefixes) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).getPrefixes(@as(*const IVBMXNamespaceManager, @ptrCast(self)), namespaceURI, prefixes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getURI(self: *const T, prefix: ?BSTR, uri: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).getURI(@as(*const IVBMXNamespaceManager, @ptrCast(self)), prefix, uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVBMXNamespaceManager_getURIFromNode(self: *const T, strPrefix: ?BSTR, contextNode: ?*IXMLDOMNode, uri: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IVBMXNamespaceManager.VTable, @ptrCast(self.vtable)).getURIFromNode(@as(*const IVBMXNamespaceManager, @ptrCast(self)), strPrefix, contextNode, uri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXNamespaceManager_Value = Guid.initString("c90352f6-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IMXNamespaceManager = &IID_IMXNamespaceManager_Value;
pub const IMXNamespaceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        putAllowOverride: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                fOverride: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                fOverride: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAllowOverride: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                fOverride: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                fOverride: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        pushContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        pushNodeContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                contextNode: ?*IXMLDOMNode,
                fDeep: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                contextNode: ?*IXMLDOMNode,
                fDeep: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        popContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        declarePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                prefix: ?[*:0]const u16,
                namespaceURI: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                prefix: ?[*:0]const u16,
                namespaceURI: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDeclaredPrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                nIndex: i32,
                pwchPrefix: [*:0]u16,
                pcchPrefix: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                nIndex: i32,
                pwchPrefix: [*:0]u16,
                pcchPrefix: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getPrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                pwszNamespaceURI: ?[*:0]const u16,
                nIndex: i32,
                pwchPrefix: [*:0]u16,
                pcchPrefix: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                pwszNamespaceURI: ?[*:0]const u16,
                nIndex: i32,
                pwchPrefix: [*:0]u16,
                pcchPrefix: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getURI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXNamespaceManager,
                pwchPrefix: ?[*:0]const u16,
                pContextNode: ?*IXMLDOMNode,
                pwchUri: [*:0]u16,
                pcchUri: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXNamespaceManager,
                pwchPrefix: ?[*:0]const u16,
                pContextNode: ?*IXMLDOMNode,
                pwchUri: [*:0]u16,
                pcchUri: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_putAllowOverride(self: *const T, fOverride: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).putAllowOverride(@as(*const IMXNamespaceManager, @ptrCast(self)), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getAllowOverride(self: *const T, fOverride: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).getAllowOverride(@as(*const IMXNamespaceManager, @ptrCast(self)), fOverride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).reset(@as(*const IMXNamespaceManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_pushContext(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).pushContext(@as(*const IMXNamespaceManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_pushNodeContext(self: *const T, contextNode: ?*IXMLDOMNode, fDeep: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).pushNodeContext(@as(*const IMXNamespaceManager, @ptrCast(self)), contextNode, fDeep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_popContext(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).popContext(@as(*const IMXNamespaceManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_declarePrefix(self: *const T, prefix: ?[*:0]const u16, namespaceURI: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).declarePrefix(@as(*const IMXNamespaceManager, @ptrCast(self)), prefix, namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getDeclaredPrefix(self: *const T, nIndex: i32, pwchPrefix: [*:0]u16, pcchPrefix: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).getDeclaredPrefix(@as(*const IMXNamespaceManager, @ptrCast(self)), nIndex, pwchPrefix, pcchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getPrefix(self: *const T, pwszNamespaceURI: ?[*:0]const u16, nIndex: i32, pwchPrefix: [*:0]u16, pcchPrefix: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).getPrefix(@as(*const IMXNamespaceManager, @ptrCast(self)), pwszNamespaceURI, nIndex, pwchPrefix, pcchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXNamespaceManager_getURI(self: *const T, pwchPrefix: ?[*:0]const u16, pContextNode: ?*IXMLDOMNode, pwchUri: [*:0]u16, pcchUri: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMXNamespaceManager.VTable, @ptrCast(self.vtable)).getURI(@as(*const IMXNamespaceManager, @ptrCast(self)), pwchPrefix, pContextNode, pwchUri, pcchUri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMXXMLFilter_Value = Guid.initString("c90352f7-643c-4fbc-bb23-e996eb2d51fd");
pub const IID_IMXXMLFilter = &IID_IMXXMLFilter_Value;
pub const IMXXMLFilter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                fValue: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                fValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                varValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                varValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                strName: ?BSTR,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_entityResolver: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oResolver: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXXMLFilter,
                oResolver: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_entityResolver: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oResolver: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                oResolver: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oHandler: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXXMLFilter,
                oHandler: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_contentHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                oHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dtdHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oHandler: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXXMLFilter,
                oHandler: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_dtdHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                oHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorHandler: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oHandler: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMXXMLFilter,
                oHandler: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        putref_errorHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMXXMLFilter,
                oHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMXXMLFilter,
                oHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_getFeature(self: *const T, strName: ?BSTR, fValue: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).getFeature(@as(*const IMXXMLFilter, @ptrCast(self)), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putFeature(self: *const T, strName: ?BSTR, fValue: i16) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).putFeature(@as(*const IMXXMLFilter, @ptrCast(self)), strName, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_getProperty(self: *const T, strName: ?BSTR, varValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).getProperty(@as(*const IMXXMLFilter, @ptrCast(self)), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putProperty(self: *const T, strName: ?BSTR, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).putProperty(@as(*const IMXXMLFilter, @ptrCast(self)), strName, varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_entityResolver(self: *const T, oResolver: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).get_entityResolver(@as(*const IMXXMLFilter, @ptrCast(self)), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_entityResolver(self: *const T, oResolver: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).putref_entityResolver(@as(*const IMXXMLFilter, @ptrCast(self)), oResolver);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_contentHandler(self: *const T, oHandler: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).get_contentHandler(@as(*const IMXXMLFilter, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_contentHandler(self: *const T, oHandler: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).putref_contentHandler(@as(*const IMXXMLFilter, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_dtdHandler(self: *const T, oHandler: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).get_dtdHandler(@as(*const IMXXMLFilter, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_dtdHandler(self: *const T, oHandler: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).putref_dtdHandler(@as(*const IMXXMLFilter, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_get_errorHandler(self: *const T, oHandler: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).get_errorHandler(@as(*const IMXXMLFilter, @ptrCast(self)), oHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMXXMLFilter_putref_errorHandler(self: *const T, oHandler: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMXXMLFilter.VTable, @ptrCast(self.vtable)).putref_errorHandler(@as(*const IMXXMLFilter, @ptrCast(self)), oHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SOMITEMTYPE = enum(i32) {
    SCHEMA = 4096,
    ATTRIBUTE = 4097,
    ATTRIBUTEGROUP = 4098,
    NOTATION = 4099,
    ANNOTATION = 4100,
    IDENTITYCONSTRAINT = 4352,
    KEY = 4353,
    KEYREF = 4354,
    UNIQUE = 4355,
    ANYTYPE = 8192,
    DATATYPE = 8448,
    DATATYPE_ANYTYPE = 8449,
    DATATYPE_ANYURI = 8450,
    DATATYPE_BASE64BINARY = 8451,
    DATATYPE_BOOLEAN = 8452,
    DATATYPE_BYTE = 8453,
    DATATYPE_DATE = 8454,
    DATATYPE_DATETIME = 8455,
    DATATYPE_DAY = 8456,
    DATATYPE_DECIMAL = 8457,
    DATATYPE_DOUBLE = 8458,
    DATATYPE_DURATION = 8459,
    DATATYPE_ENTITIES = 8460,
    DATATYPE_ENTITY = 8461,
    DATATYPE_FLOAT = 8462,
    DATATYPE_HEXBINARY = 8463,
    DATATYPE_ID = 8464,
    DATATYPE_IDREF = 8465,
    DATATYPE_IDREFS = 8466,
    DATATYPE_INT = 8467,
    DATATYPE_INTEGER = 8468,
    DATATYPE_LANGUAGE = 8469,
    DATATYPE_LONG = 8470,
    DATATYPE_MONTH = 8471,
    DATATYPE_MONTHDAY = 8472,
    DATATYPE_NAME = 8473,
    DATATYPE_NCNAME = 8474,
    DATATYPE_NEGATIVEINTEGER = 8475,
    DATATYPE_NMTOKEN = 8476,
    DATATYPE_NMTOKENS = 8477,
    DATATYPE_NONNEGATIVEINTEGER = 8478,
    DATATYPE_NONPOSITIVEINTEGER = 8479,
    DATATYPE_NORMALIZEDSTRING = 8480,
    DATATYPE_NOTATION = 8481,
    DATATYPE_POSITIVEINTEGER = 8482,
    DATATYPE_QNAME = 8483,
    DATATYPE_SHORT = 8484,
    DATATYPE_STRING = 8485,
    DATATYPE_TIME = 8486,
    DATATYPE_TOKEN = 8487,
    DATATYPE_UNSIGNEDBYTE = 8488,
    DATATYPE_UNSIGNEDINT = 8489,
    DATATYPE_UNSIGNEDLONG = 8490,
    DATATYPE_UNSIGNEDSHORT = 8491,
    DATATYPE_YEAR = 8492,
    DATATYPE_YEARMONTH = 8493,
    DATATYPE_ANYSIMPLETYPE = 8703,
    SIMPLETYPE = 8704,
    COMPLEXTYPE = 9216,
    PARTICLE = 16384,
    ANY = 16385,
    ANYATTRIBUTE = 16386,
    ELEMENT = 16387,
    GROUP = 16640,
    ALL = 16641,
    CHOICE = 16642,
    SEQUENCE = 16643,
    EMPTYPARTICLE = 16644,
    NULL = 2048,
    NULL_TYPE = 10240,
    NULL_ANY = 18433,
    NULL_ANYATTRIBUTE = 18434,
    NULL_ELEMENT = 18435,
};
pub const SOMITEM_SCHEMA = SOMITEMTYPE.SCHEMA;
pub const SOMITEM_ATTRIBUTE = SOMITEMTYPE.ATTRIBUTE;
pub const SOMITEM_ATTRIBUTEGROUP = SOMITEMTYPE.ATTRIBUTEGROUP;
pub const SOMITEM_NOTATION = SOMITEMTYPE.NOTATION;
pub const SOMITEM_ANNOTATION = SOMITEMTYPE.ANNOTATION;
pub const SOMITEM_IDENTITYCONSTRAINT = SOMITEMTYPE.IDENTITYCONSTRAINT;
pub const SOMITEM_KEY = SOMITEMTYPE.KEY;
pub const SOMITEM_KEYREF = SOMITEMTYPE.KEYREF;
pub const SOMITEM_UNIQUE = SOMITEMTYPE.UNIQUE;
pub const SOMITEM_ANYTYPE = SOMITEMTYPE.ANYTYPE;
pub const SOMITEM_DATATYPE = SOMITEMTYPE.DATATYPE;
pub const SOMITEM_DATATYPE_ANYTYPE = SOMITEMTYPE.DATATYPE_ANYTYPE;
pub const SOMITEM_DATATYPE_ANYURI = SOMITEMTYPE.DATATYPE_ANYURI;
pub const SOMITEM_DATATYPE_BASE64BINARY = SOMITEMTYPE.DATATYPE_BASE64BINARY;
pub const SOMITEM_DATATYPE_BOOLEAN = SOMITEMTYPE.DATATYPE_BOOLEAN;
pub const SOMITEM_DATATYPE_BYTE = SOMITEMTYPE.DATATYPE_BYTE;
pub const SOMITEM_DATATYPE_DATE = SOMITEMTYPE.DATATYPE_DATE;
pub const SOMITEM_DATATYPE_DATETIME = SOMITEMTYPE.DATATYPE_DATETIME;
pub const SOMITEM_DATATYPE_DAY = SOMITEMTYPE.DATATYPE_DAY;
pub const SOMITEM_DATATYPE_DECIMAL = SOMITEMTYPE.DATATYPE_DECIMAL;
pub const SOMITEM_DATATYPE_DOUBLE = SOMITEMTYPE.DATATYPE_DOUBLE;
pub const SOMITEM_DATATYPE_DURATION = SOMITEMTYPE.DATATYPE_DURATION;
pub const SOMITEM_DATATYPE_ENTITIES = SOMITEMTYPE.DATATYPE_ENTITIES;
pub const SOMITEM_DATATYPE_ENTITY = SOMITEMTYPE.DATATYPE_ENTITY;
pub const SOMITEM_DATATYPE_FLOAT = SOMITEMTYPE.DATATYPE_FLOAT;
pub const SOMITEM_DATATYPE_HEXBINARY = SOMITEMTYPE.DATATYPE_HEXBINARY;
pub const SOMITEM_DATATYPE_ID = SOMITEMTYPE.DATATYPE_ID;
pub const SOMITEM_DATATYPE_IDREF = SOMITEMTYPE.DATATYPE_IDREF;
pub const SOMITEM_DATATYPE_IDREFS = SOMITEMTYPE.DATATYPE_IDREFS;
pub const SOMITEM_DATATYPE_INT = SOMITEMTYPE.DATATYPE_INT;
pub const SOMITEM_DATATYPE_INTEGER = SOMITEMTYPE.DATATYPE_INTEGER;
pub const SOMITEM_DATATYPE_LANGUAGE = SOMITEMTYPE.DATATYPE_LANGUAGE;
pub const SOMITEM_DATATYPE_LONG = SOMITEMTYPE.DATATYPE_LONG;
pub const SOMITEM_DATATYPE_MONTH = SOMITEMTYPE.DATATYPE_MONTH;
pub const SOMITEM_DATATYPE_MONTHDAY = SOMITEMTYPE.DATATYPE_MONTHDAY;
pub const SOMITEM_DATATYPE_NAME = SOMITEMTYPE.DATATYPE_NAME;
pub const SOMITEM_DATATYPE_NCNAME = SOMITEMTYPE.DATATYPE_NCNAME;
pub const SOMITEM_DATATYPE_NEGATIVEINTEGER = SOMITEMTYPE.DATATYPE_NEGATIVEINTEGER;
pub const SOMITEM_DATATYPE_NMTOKEN = SOMITEMTYPE.DATATYPE_NMTOKEN;
pub const SOMITEM_DATATYPE_NMTOKENS = SOMITEMTYPE.DATATYPE_NMTOKENS;
pub const SOMITEM_DATATYPE_NONNEGATIVEINTEGER = SOMITEMTYPE.DATATYPE_NONNEGATIVEINTEGER;
pub const SOMITEM_DATATYPE_NONPOSITIVEINTEGER = SOMITEMTYPE.DATATYPE_NONPOSITIVEINTEGER;
pub const SOMITEM_DATATYPE_NORMALIZEDSTRING = SOMITEMTYPE.DATATYPE_NORMALIZEDSTRING;
pub const SOMITEM_DATATYPE_NOTATION = SOMITEMTYPE.DATATYPE_NOTATION;
pub const SOMITEM_DATATYPE_POSITIVEINTEGER = SOMITEMTYPE.DATATYPE_POSITIVEINTEGER;
pub const SOMITEM_DATATYPE_QNAME = SOMITEMTYPE.DATATYPE_QNAME;
pub const SOMITEM_DATATYPE_SHORT = SOMITEMTYPE.DATATYPE_SHORT;
pub const SOMITEM_DATATYPE_STRING = SOMITEMTYPE.DATATYPE_STRING;
pub const SOMITEM_DATATYPE_TIME = SOMITEMTYPE.DATATYPE_TIME;
pub const SOMITEM_DATATYPE_TOKEN = SOMITEMTYPE.DATATYPE_TOKEN;
pub const SOMITEM_DATATYPE_UNSIGNEDBYTE = SOMITEMTYPE.DATATYPE_UNSIGNEDBYTE;
pub const SOMITEM_DATATYPE_UNSIGNEDINT = SOMITEMTYPE.DATATYPE_UNSIGNEDINT;
pub const SOMITEM_DATATYPE_UNSIGNEDLONG = SOMITEMTYPE.DATATYPE_UNSIGNEDLONG;
pub const SOMITEM_DATATYPE_UNSIGNEDSHORT = SOMITEMTYPE.DATATYPE_UNSIGNEDSHORT;
pub const SOMITEM_DATATYPE_YEAR = SOMITEMTYPE.DATATYPE_YEAR;
pub const SOMITEM_DATATYPE_YEARMONTH = SOMITEMTYPE.DATATYPE_YEARMONTH;
pub const SOMITEM_DATATYPE_ANYSIMPLETYPE = SOMITEMTYPE.DATATYPE_ANYSIMPLETYPE;
pub const SOMITEM_SIMPLETYPE = SOMITEMTYPE.SIMPLETYPE;
pub const SOMITEM_COMPLEXTYPE = SOMITEMTYPE.COMPLEXTYPE;
pub const SOMITEM_PARTICLE = SOMITEMTYPE.PARTICLE;
pub const SOMITEM_ANY = SOMITEMTYPE.ANY;
pub const SOMITEM_ANYATTRIBUTE = SOMITEMTYPE.ANYATTRIBUTE;
pub const SOMITEM_ELEMENT = SOMITEMTYPE.ELEMENT;
pub const SOMITEM_GROUP = SOMITEMTYPE.GROUP;
pub const SOMITEM_ALL = SOMITEMTYPE.ALL;
pub const SOMITEM_CHOICE = SOMITEMTYPE.CHOICE;
pub const SOMITEM_SEQUENCE = SOMITEMTYPE.SEQUENCE;
pub const SOMITEM_EMPTYPARTICLE = SOMITEMTYPE.EMPTYPARTICLE;
pub const SOMITEM_NULL = SOMITEMTYPE.NULL;
pub const SOMITEM_NULL_TYPE = SOMITEMTYPE.NULL_TYPE;
pub const SOMITEM_NULL_ANY = SOMITEMTYPE.NULL_ANY;
pub const SOMITEM_NULL_ANYATTRIBUTE = SOMITEMTYPE.NULL_ANYATTRIBUTE;
pub const SOMITEM_NULL_ELEMENT = SOMITEMTYPE.NULL_ELEMENT;

pub const SCHEMAUSE = enum(i32) {
    OPTIONAL = 0,
    PROHIBITED = 1,
    REQUIRED = 2,
};
pub const SCHEMAUSE_OPTIONAL = SCHEMAUSE.OPTIONAL;
pub const SCHEMAUSE_PROHIBITED = SCHEMAUSE.PROHIBITED;
pub const SCHEMAUSE_REQUIRED = SCHEMAUSE.REQUIRED;

pub const SCHEMADERIVATIONMETHOD = enum(i32) {
    EMPTY = 0,
    SUBSTITUTION = 1,
    EXTENSION = 2,
    RESTRICTION = 4,
    LIST = 8,
    UNION = 16,
    ALL = 255,
    NONE = 256,
};
pub const SCHEMADERIVATIONMETHOD_EMPTY = SCHEMADERIVATIONMETHOD.EMPTY;
pub const SCHEMADERIVATIONMETHOD_SUBSTITUTION = SCHEMADERIVATIONMETHOD.SUBSTITUTION;
pub const SCHEMADERIVATIONMETHOD_EXTENSION = SCHEMADERIVATIONMETHOD.EXTENSION;
pub const SCHEMADERIVATIONMETHOD_RESTRICTION = SCHEMADERIVATIONMETHOD.RESTRICTION;
pub const SCHEMADERIVATIONMETHOD_LIST = SCHEMADERIVATIONMETHOD.LIST;
pub const SCHEMADERIVATIONMETHOD_UNION = SCHEMADERIVATIONMETHOD.UNION;
pub const SCHEMADERIVATIONMETHOD_ALL = SCHEMADERIVATIONMETHOD.ALL;
pub const SCHEMADERIVATIONMETHOD_NONE = SCHEMADERIVATIONMETHOD.NONE;

pub const SCHEMACONTENTTYPE = enum(i32) {
    EMPTY = 0,
    TEXTONLY = 1,
    ELEMENTONLY = 2,
    MIXED = 3,
};
pub const SCHEMACONTENTTYPE_EMPTY = SCHEMACONTENTTYPE.EMPTY;
pub const SCHEMACONTENTTYPE_TEXTONLY = SCHEMACONTENTTYPE.TEXTONLY;
pub const SCHEMACONTENTTYPE_ELEMENTONLY = SCHEMACONTENTTYPE.ELEMENTONLY;
pub const SCHEMACONTENTTYPE_MIXED = SCHEMACONTENTTYPE.MIXED;

pub const SCHEMAPROCESSCONTENTS = enum(i32) {
    NONE = 0,
    SKIP = 1,
    LAX = 2,
    STRICT = 3,
};
pub const SCHEMAPROCESSCONTENTS_NONE = SCHEMAPROCESSCONTENTS.NONE;
pub const SCHEMAPROCESSCONTENTS_SKIP = SCHEMAPROCESSCONTENTS.SKIP;
pub const SCHEMAPROCESSCONTENTS_LAX = SCHEMAPROCESSCONTENTS.LAX;
pub const SCHEMAPROCESSCONTENTS_STRICT = SCHEMAPROCESSCONTENTS.STRICT;

pub const SCHEMAWHITESPACE = enum(i32) {
    NONE = -1,
    PRESERVE = 0,
    REPLACE = 1,
    COLLAPSE = 2,
};
pub const SCHEMAWHITESPACE_NONE = SCHEMAWHITESPACE.NONE;
pub const SCHEMAWHITESPACE_PRESERVE = SCHEMAWHITESPACE.PRESERVE;
pub const SCHEMAWHITESPACE_REPLACE = SCHEMAWHITESPACE.REPLACE;
pub const SCHEMAWHITESPACE_COLLAPSE = SCHEMAWHITESPACE.COLLAPSE;

pub const SCHEMATYPEVARIETY = enum(i32) {
    NONE = -1,
    ATOMIC = 0,
    LIST = 1,
    UNION = 2,
};
pub const SCHEMATYPEVARIETY_NONE = SCHEMATYPEVARIETY.NONE;
pub const SCHEMATYPEVARIETY_ATOMIC = SCHEMATYPEVARIETY.ATOMIC;
pub const SCHEMATYPEVARIETY_LIST = SCHEMATYPEVARIETY.LIST;
pub const SCHEMATYPEVARIETY_UNION = SCHEMATYPEVARIETY.UNION;

const IID_IXMLDOMSchemaCollection2_Value = Guid.initString("50ea08b0-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_IXMLDOMSchemaCollection2 = &IID_IXMLDOMSchemaCollection2_Value;
pub const IXMLDOMSchemaCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMSchemaCollection.VTable,
        validate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_validateOnLoad: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection2,
                validateOnLoad: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSchemaCollection2,
                validateOnLoad: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_validateOnLoad: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection2,
                validateOnLoad: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXMLDOMSchemaCollection2,
                validateOnLoad: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getSchema: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection2,
                namespaceURI: ?BSTR,
                schema: ?*?*ISchema,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection2,
                namespaceURI: ?BSTR,
                schema: ?*?*ISchema,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDeclaration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLDOMSchemaCollection2,
                node: ?*IXMLDOMNode,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLDOMSchemaCollection2,
                node: ?*IXMLDOMNode,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMSchemaCollection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_validate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection2.VTable, @ptrCast(self.vtable)).validate(@as(*const IXMLDOMSchemaCollection2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_put_validateOnLoad(self: *const T, validateOnLoad: i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection2.VTable, @ptrCast(self.vtable)).put_validateOnLoad(@as(*const IXMLDOMSchemaCollection2, @ptrCast(self)), validateOnLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_get_validateOnLoad(self: *const T, validateOnLoad: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection2.VTable, @ptrCast(self.vtable)).get_validateOnLoad(@as(*const IXMLDOMSchemaCollection2, @ptrCast(self)), validateOnLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_getSchema(self: *const T, namespaceURI: ?BSTR, schema: ?*?*ISchema) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection2.VTable, @ptrCast(self.vtable)).getSchema(@as(*const IXMLDOMSchemaCollection2, @ptrCast(self)), namespaceURI, schema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMSchemaCollection2_getDeclaration(self: *const T, node: ?*IXMLDOMNode, item: ?*?*ISchemaItem) callconv(.Inline) HRESULT {
            return @as(*const IXMLDOMSchemaCollection2.VTable, @ptrCast(self.vtable)).getDeclaration(@as(*const IXMLDOMSchemaCollection2, @ptrCast(self)), node, item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaStringCollection_Value = Guid.initString("50ea08b1-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaStringCollection = &IID_ISchemaStringCollection_Value;
pub const ISchemaStringCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaStringCollection,
                index: i32,
                bstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaStringCollection,
                index: i32,
                bstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaStringCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaStringCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaStringCollection,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaStringCollection,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaStringCollection_get_item(self: *const T, index: i32, bstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaStringCollection.VTable, @ptrCast(self.vtable)).get_item(@as(*const ISchemaStringCollection, @ptrCast(self)), index, bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaStringCollection_get_length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISchemaStringCollection.VTable, @ptrCast(self.vtable)).get_length(@as(*const ISchemaStringCollection, @ptrCast(self)), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaStringCollection_get__newEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ISchemaStringCollection.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const ISchemaStringCollection, @ptrCast(self)), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaItemCollection_Value = Guid.initString("50ea08b2-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaItemCollection = &IID_ISchemaItemCollection_Value;
pub const ISchemaItemCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItemCollection,
                index: i32,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItemCollection,
                index: i32,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        itemByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISchemaItemCollection,
                name: ?BSTR,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISchemaItemCollection,
                name: ?BSTR,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        itemByQName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISchemaItemCollection,
                name: ?BSTR,
                namespaceURI: ?BSTR,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISchemaItemCollection,
                name: ?BSTR,
                namespaceURI: ?BSTR,
                item: ?*?*ISchemaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItemCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItemCollection,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__newEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItemCollection,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItemCollection,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_get_item(self: *const T, index: i32, item: ?*?*ISchemaItem) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItemCollection.VTable, @ptrCast(self.vtable)).get_item(@as(*const ISchemaItemCollection, @ptrCast(self)), index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_itemByName(self: *const T, name: ?BSTR, item: ?*?*ISchemaItem) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItemCollection.VTable, @ptrCast(self.vtable)).itemByName(@as(*const ISchemaItemCollection, @ptrCast(self)), name, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_itemByQName(self: *const T, name: ?BSTR, namespaceURI: ?BSTR, item: ?*?*ISchemaItem) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItemCollection.VTable, @ptrCast(self.vtable)).itemByQName(@as(*const ISchemaItemCollection, @ptrCast(self)), name, namespaceURI, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_get_length(self: *const T, length: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItemCollection.VTable, @ptrCast(self.vtable)).get_length(@as(*const ISchemaItemCollection, @ptrCast(self)), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItemCollection_get__newEnum(self: *const T, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItemCollection.VTable, @ptrCast(self.vtable)).get__newEnum(@as(*const ISchemaItemCollection, @ptrCast(self)), ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaItem_Value = Guid.initString("50ea08b3-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaItem = &IID_ISchemaItem_Value;
pub const ISchemaItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItem,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItem,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaceURI: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItem,
                namespaceURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItem,
                namespaceURI: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_schema: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItem,
                schema: ?*?*ISchema,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItem,
                schema: ?*?*ISchema,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItem,
                id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItem,
                id: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_itemType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItem,
                itemType: ?*SOMITEMTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItem,
                itemType: ?*SOMITEMTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_unhandledAttributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaItem,
                attributes: ?*?*IVBSAXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaItem,
                attributes: ?*?*IVBSAXAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        writeAnnotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISchemaItem,
                annotationSink: ?*IUnknown,
                isWritten: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISchemaItem,
                annotationSink: ?*IUnknown,
                isWritten: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_name(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).get_name(@as(*const ISchemaItem, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_namespaceURI(self: *const T, namespaceURI: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).get_namespaceURI(@as(*const ISchemaItem, @ptrCast(self)), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_schema(self: *const T, schema: ?*?*ISchema) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).get_schema(@as(*const ISchemaItem, @ptrCast(self)), schema);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_id(self: *const T, id: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).get_id(@as(*const ISchemaItem, @ptrCast(self)), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_itemType(self: *const T, itemType: ?*SOMITEMTYPE) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).get_itemType(@as(*const ISchemaItem, @ptrCast(self)), itemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_get_unhandledAttributes(self: *const T, attributes: ?*?*IVBSAXAttributes) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).get_unhandledAttributes(@as(*const ISchemaItem, @ptrCast(self)), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaItem_writeAnnotation(self: *const T, annotationSink: ?*IUnknown, isWritten: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaItem.VTable, @ptrCast(self.vtable)).writeAnnotation(@as(*const ISchemaItem, @ptrCast(self)), annotationSink, isWritten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchema_Value = Guid.initString("50ea08b4-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchema = &IID_ISchema_Value;
pub const ISchema = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_targetNamespace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                targetNamespace: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                targetNamespace: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                version: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                version: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_types: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                types: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                types: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_elements: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                elements: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                elements: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                attributes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                attributes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributeGroups: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                attributeGroups: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                attributeGroups: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_modelGroups: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                modelGroups: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                modelGroups: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_notations: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                notations: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                notations: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_schemaLocations: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchema,
                schemaLocations: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchema,
                schemaLocations: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_targetNamespace(self: *const T, targetNamespace: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_targetNamespace(@as(*const ISchema, @ptrCast(self)), targetNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_version(self: *const T, version: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_version(@as(*const ISchema, @ptrCast(self)), version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_types(self: *const T, types: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_types(@as(*const ISchema, @ptrCast(self)), types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_elements(self: *const T, elements: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_elements(@as(*const ISchema, @ptrCast(self)), elements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_attributes(self: *const T, attributes: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_attributes(@as(*const ISchema, @ptrCast(self)), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_attributeGroups(self: *const T, attributeGroups: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_attributeGroups(@as(*const ISchema, @ptrCast(self)), attributeGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_modelGroups(self: *const T, modelGroups: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_modelGroups(@as(*const ISchema, @ptrCast(self)), modelGroups);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_notations(self: *const T, notations: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_notations(@as(*const ISchema, @ptrCast(self)), notations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchema_get_schemaLocations(self: *const T, schemaLocations: ?*?*ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchema.VTable, @ptrCast(self.vtable)).get_schemaLocations(@as(*const ISchema, @ptrCast(self)), schemaLocations);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaParticle_Value = Guid.initString("50ea08b5-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaParticle = &IID_ISchemaParticle_Value;
pub const ISchemaParticle = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minOccurs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaParticle,
                minOccurs: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaParticle,
                minOccurs: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxOccurs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaParticle,
                maxOccurs: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaParticle,
                maxOccurs: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaParticle_get_minOccurs(self: *const T, minOccurs: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaParticle.VTable, @ptrCast(self.vtable)).get_minOccurs(@as(*const ISchemaParticle, @ptrCast(self)), minOccurs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaParticle_get_maxOccurs(self: *const T, maxOccurs: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaParticle.VTable, @ptrCast(self.vtable)).get_maxOccurs(@as(*const ISchemaParticle, @ptrCast(self)), maxOccurs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaAttribute_Value = Guid.initString("50ea08b6-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaAttribute = &IID_ISchemaAttribute_Value;
pub const ISchemaAttribute = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttribute,
                type: ?*?*ISchemaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttribute,
                type: ?*?*ISchemaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttribute,
                scope: ?*?*ISchemaComplexType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttribute,
                scope: ?*?*ISchemaComplexType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttribute,
                defaultValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttribute,
                defaultValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fixedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttribute,
                fixedValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttribute,
                fixedValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_use: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttribute,
                use: ?*SCHEMAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttribute,
                use: ?*SCHEMAUSE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isReference: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttribute,
                reference: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttribute,
                reference: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_type(self: *const T, type_: ?*?*ISchemaType) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttribute.VTable, @ptrCast(self.vtable)).get_type(@as(*const ISchemaAttribute, @ptrCast(self)), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_scope(self: *const T, scope: ?*?*ISchemaComplexType) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttribute.VTable, @ptrCast(self.vtable)).get_scope(@as(*const ISchemaAttribute, @ptrCast(self)), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_defaultValue(self: *const T, defaultValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttribute.VTable, @ptrCast(self.vtable)).get_defaultValue(@as(*const ISchemaAttribute, @ptrCast(self)), defaultValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_fixedValue(self: *const T, fixedValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttribute.VTable, @ptrCast(self.vtable)).get_fixedValue(@as(*const ISchemaAttribute, @ptrCast(self)), fixedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_use(self: *const T, use: ?*SCHEMAUSE) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttribute.VTable, @ptrCast(self.vtable)).get_use(@as(*const ISchemaAttribute, @ptrCast(self)), use);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttribute_get_isReference(self: *const T, reference: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttribute.VTable, @ptrCast(self.vtable)).get_isReference(@as(*const ISchemaAttribute, @ptrCast(self)), reference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaElement_Value = Guid.initString("50ea08b7-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaElement = &IID_ISchemaElement_Value;
pub const ISchemaElement = extern struct {
    pub const VTable = extern struct {
        base: ISchemaParticle.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                type: ?*?*ISchemaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                type: ?*?*ISchemaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scope: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                scope: ?*?*ISchemaComplexType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                scope: ?*?*ISchemaComplexType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                defaultValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                defaultValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fixedValue: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                fixedValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                fixedValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isNillable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                nillable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                nillable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_identityConstraints: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                constraints: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                constraints: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_substitutionGroup: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                element: ?*?*ISchemaElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                element: ?*?*ISchemaElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_substitutionGroupExclusions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                exclusions: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                exclusions: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_disallowedSubstitutions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                disallowed: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                disallowed: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAbstract: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                abstract: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                abstract: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isReference: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaElement,
                reference: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaElement,
                reference: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaParticle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_type(self: *const T, type_: ?*?*ISchemaType) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_type(@as(*const ISchemaElement, @ptrCast(self)), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_scope(self: *const T, scope: ?*?*ISchemaComplexType) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_scope(@as(*const ISchemaElement, @ptrCast(self)), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_defaultValue(self: *const T, defaultValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_defaultValue(@as(*const ISchemaElement, @ptrCast(self)), defaultValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_fixedValue(self: *const T, fixedValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_fixedValue(@as(*const ISchemaElement, @ptrCast(self)), fixedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_isNillable(self: *const T, nillable: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_isNillable(@as(*const ISchemaElement, @ptrCast(self)), nillable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_identityConstraints(self: *const T, constraints: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_identityConstraints(@as(*const ISchemaElement, @ptrCast(self)), constraints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_substitutionGroup(self: *const T, element: ?*?*ISchemaElement) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_substitutionGroup(@as(*const ISchemaElement, @ptrCast(self)), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_substitutionGroupExclusions(self: *const T, exclusions: ?*SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_substitutionGroupExclusions(@as(*const ISchemaElement, @ptrCast(self)), exclusions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_disallowedSubstitutions(self: *const T, disallowed: ?*SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_disallowedSubstitutions(@as(*const ISchemaElement, @ptrCast(self)), disallowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_isAbstract(self: *const T, abstract: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_isAbstract(@as(*const ISchemaElement, @ptrCast(self)), abstract);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaElement_get_isReference(self: *const T, reference: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaElement.VTable, @ptrCast(self.vtable)).get_isReference(@as(*const ISchemaElement, @ptrCast(self)), reference);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaType_Value = Guid.initString("50ea08b8-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaType = &IID_ISchemaType_Value;
pub const ISchemaType = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                baseTypes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                baseTypes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_final: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                final: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                final: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_variety: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                variety: ?*SCHEMATYPEVARIETY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                variety: ?*SCHEMATYPEVARIETY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_derivedBy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                derivedBy: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                derivedBy: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISchemaType,
                data: ?BSTR,
                valid: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISchemaType,
                data: ?BSTR,
                valid: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minExclusive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                minExclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                minExclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minInclusive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                minInclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                minInclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxExclusive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                maxExclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                maxExclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxInclusive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                maxInclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                maxInclusive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_totalDigits: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                totalDigits: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                totalDigits: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fractionDigits: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                fractionDigits: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                fractionDigits: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                length: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                length: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_minLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                minLength: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                minLength: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxLength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                maxLength: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                maxLength: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enumeration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                enumeration: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                enumeration: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_whitespace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                whitespace: ?*SCHEMAWHITESPACE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                whitespace: ?*SCHEMAWHITESPACE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_patterns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaType,
                patterns: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaType,
                patterns: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_baseTypes(self: *const T, baseTypes: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_baseTypes(@as(*const ISchemaType, @ptrCast(self)), baseTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_final(self: *const T, final: ?*SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_final(@as(*const ISchemaType, @ptrCast(self)), final);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_variety(self: *const T, variety: ?*SCHEMATYPEVARIETY) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_variety(@as(*const ISchemaType, @ptrCast(self)), variety);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_derivedBy(self: *const T, derivedBy: ?*SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_derivedBy(@as(*const ISchemaType, @ptrCast(self)), derivedBy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_isValid(self: *const T, data: ?BSTR, valid: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).isValid(@as(*const ISchemaType, @ptrCast(self)), data, valid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_minExclusive(self: *const T, minExclusive: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_minExclusive(@as(*const ISchemaType, @ptrCast(self)), minExclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_minInclusive(self: *const T, minInclusive: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_minInclusive(@as(*const ISchemaType, @ptrCast(self)), minInclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_maxExclusive(self: *const T, maxExclusive: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_maxExclusive(@as(*const ISchemaType, @ptrCast(self)), maxExclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_maxInclusive(self: *const T, maxInclusive: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_maxInclusive(@as(*const ISchemaType, @ptrCast(self)), maxInclusive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_totalDigits(self: *const T, totalDigits: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_totalDigits(@as(*const ISchemaType, @ptrCast(self)), totalDigits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_fractionDigits(self: *const T, fractionDigits: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_fractionDigits(@as(*const ISchemaType, @ptrCast(self)), fractionDigits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_length(self: *const T, length: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_length(@as(*const ISchemaType, @ptrCast(self)), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_minLength(self: *const T, minLength: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_minLength(@as(*const ISchemaType, @ptrCast(self)), minLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_maxLength(self: *const T, maxLength: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_maxLength(@as(*const ISchemaType, @ptrCast(self)), maxLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_enumeration(self: *const T, enumeration: ?*?*ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_enumeration(@as(*const ISchemaType, @ptrCast(self)), enumeration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_whitespace(self: *const T, whitespace: ?*SCHEMAWHITESPACE) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_whitespace(@as(*const ISchemaType, @ptrCast(self)), whitespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaType_get_patterns(self: *const T, patterns: ?*?*ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaType.VTable, @ptrCast(self.vtable)).get_patterns(@as(*const ISchemaType, @ptrCast(self)), patterns);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaComplexType_Value = Guid.initString("50ea08b9-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaComplexType = &IID_ISchemaComplexType_Value;
pub const ISchemaComplexType = extern struct {
    pub const VTable = extern struct {
        base: ISchemaType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAbstract: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaComplexType,
                abstract: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaComplexType,
                abstract: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anyAttribute: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaComplexType,
                anyAttribute: ?*?*ISchemaAny,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaComplexType,
                anyAttribute: ?*?*ISchemaAny,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaComplexType,
                attributes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaComplexType,
                attributes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaComplexType,
                contentType: ?*SCHEMACONTENTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaComplexType,
                contentType: ?*SCHEMACONTENTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentModel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaComplexType,
                contentModel: ?*?*ISchemaModelGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaComplexType,
                contentModel: ?*?*ISchemaModelGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_prohibitedSubstitutions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaComplexType,
                prohibited: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaComplexType,
                prohibited: ?*SCHEMADERIVATIONMETHOD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_isAbstract(self: *const T, abstract: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const ISchemaComplexType.VTable, @ptrCast(self.vtable)).get_isAbstract(@as(*const ISchemaComplexType, @ptrCast(self)), abstract);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_anyAttribute(self: *const T, anyAttribute: ?*?*ISchemaAny) callconv(.Inline) HRESULT {
            return @as(*const ISchemaComplexType.VTable, @ptrCast(self.vtable)).get_anyAttribute(@as(*const ISchemaComplexType, @ptrCast(self)), anyAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_attributes(self: *const T, attributes: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaComplexType.VTable, @ptrCast(self.vtable)).get_attributes(@as(*const ISchemaComplexType, @ptrCast(self)), attributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_contentType(self: *const T, contentType: ?*SCHEMACONTENTTYPE) callconv(.Inline) HRESULT {
            return @as(*const ISchemaComplexType.VTable, @ptrCast(self.vtable)).get_contentType(@as(*const ISchemaComplexType, @ptrCast(self)), contentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_contentModel(self: *const T, contentModel: ?*?*ISchemaModelGroup) callconv(.Inline) HRESULT {
            return @as(*const ISchemaComplexType.VTable, @ptrCast(self.vtable)).get_contentModel(@as(*const ISchemaComplexType, @ptrCast(self)), contentModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaComplexType_get_prohibitedSubstitutions(self: *const T, prohibited: ?*SCHEMADERIVATIONMETHOD) callconv(.Inline) HRESULT {
            return @as(*const ISchemaComplexType.VTable, @ptrCast(self.vtable)).get_prohibitedSubstitutions(@as(*const ISchemaComplexType, @ptrCast(self)), prohibited);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaAttributeGroup_Value = Guid.initString("50ea08ba-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaAttributeGroup = &IID_ISchemaAttributeGroup_Value;
pub const ISchemaAttributeGroup = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_anyAttribute: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttributeGroup,
                anyAttribute: ?*?*ISchemaAny,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttributeGroup,
                anyAttribute: ?*?*ISchemaAny,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAttributeGroup,
                attributes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAttributeGroup,
                attributes: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttributeGroup_get_anyAttribute(self: *const T, anyAttribute: ?*?*ISchemaAny) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttributeGroup.VTable, @ptrCast(self.vtable)).get_anyAttribute(@as(*const ISchemaAttributeGroup, @ptrCast(self)), anyAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAttributeGroup_get_attributes(self: *const T, attributes: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAttributeGroup.VTable, @ptrCast(self.vtable)).get_attributes(@as(*const ISchemaAttributeGroup, @ptrCast(self)), attributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaModelGroup_Value = Guid.initString("50ea08bb-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaModelGroup = &IID_ISchemaModelGroup_Value;
pub const ISchemaModelGroup = extern struct {
    pub const VTable = extern struct {
        base: ISchemaParticle.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_particles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaModelGroup,
                particles: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaModelGroup,
                particles: ?*?*ISchemaItemCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaParticle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaModelGroup_get_particles(self: *const T, particles: ?*?*ISchemaItemCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaModelGroup.VTable, @ptrCast(self.vtable)).get_particles(@as(*const ISchemaModelGroup, @ptrCast(self)), particles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaAny_Value = Guid.initString("50ea08bc-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaAny = &IID_ISchemaAny_Value;
pub const ISchemaAny = extern struct {
    pub const VTable = extern struct {
        base: ISchemaParticle.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_namespaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAny,
                namespaces: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAny,
                namespaces: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_processContents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaAny,
                processContents: ?*SCHEMAPROCESSCONTENTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaAny,
                processContents: ?*SCHEMAPROCESSCONTENTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaParticle.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAny_get_namespaces(self: *const T, namespaces: ?*?*ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAny.VTable, @ptrCast(self.vtable)).get_namespaces(@as(*const ISchemaAny, @ptrCast(self)), namespaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaAny_get_processContents(self: *const T, processContents: ?*SCHEMAPROCESSCONTENTS) callconv(.Inline) HRESULT {
            return @as(*const ISchemaAny.VTable, @ptrCast(self.vtable)).get_processContents(@as(*const ISchemaAny, @ptrCast(self)), processContents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaIdentityConstraint_Value = Guid.initString("50ea08bd-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaIdentityConstraint = &IID_ISchemaIdentityConstraint_Value;
pub const ISchemaIdentityConstraint = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_selector: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaIdentityConstraint,
                selector: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaIdentityConstraint,
                selector: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fields: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaIdentityConstraint,
                fields: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaIdentityConstraint,
                fields: ?*?*ISchemaStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_referencedKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaIdentityConstraint,
                key: ?*?*ISchemaIdentityConstraint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaIdentityConstraint,
                key: ?*?*ISchemaIdentityConstraint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaIdentityConstraint_get_selector(self: *const T, selector: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaIdentityConstraint.VTable, @ptrCast(self.vtable)).get_selector(@as(*const ISchemaIdentityConstraint, @ptrCast(self)), selector);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaIdentityConstraint_get_fields(self: *const T, fields: ?*?*ISchemaStringCollection) callconv(.Inline) HRESULT {
            return @as(*const ISchemaIdentityConstraint.VTable, @ptrCast(self.vtable)).get_fields(@as(*const ISchemaIdentityConstraint, @ptrCast(self)), fields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaIdentityConstraint_get_referencedKey(self: *const T, key: ?*?*ISchemaIdentityConstraint) callconv(.Inline) HRESULT {
            return @as(*const ISchemaIdentityConstraint.VTable, @ptrCast(self.vtable)).get_referencedKey(@as(*const ISchemaIdentityConstraint, @ptrCast(self)), key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaNotation_Value = Guid.initString("50ea08be-dd1b-4664-9a50-c2f40f4bd79a");
pub const IID_ISchemaNotation = &IID_ISchemaNotation_Value;
pub const ISchemaNotation = extern struct {
    pub const VTable = extern struct {
        base: ISchemaItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_systemIdentifier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaNotation,
                uri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaNotation,
                uri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_publicIdentifier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISchemaNotation,
                uri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISchemaNotation,
                uri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISchemaItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaNotation_get_systemIdentifier(self: *const T, uri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaNotation.VTable, @ptrCast(self.vtable)).get_systemIdentifier(@as(*const ISchemaNotation, @ptrCast(self)), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaNotation_get_publicIdentifier(self: *const T, uri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISchemaNotation.VTable, @ptrCast(self.vtable)).get_publicIdentifier(@as(*const ISchemaNotation, @ptrCast(self)), uri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __msxml6_ReferenceRemainingTypes__ = extern struct {
    __tagDomNodeType__: DOMNodeType,
    __domNodeType__: DOMNodeType,
    __serverXmlHttpOptionEnum__: SERVERXMLHTTP_OPTION,
    __serverXmlHttpOption__: SERVERXMLHTTP_OPTION,
    __serverCertOptionEnum__: SXH_SERVER_CERT_OPTION,
    __serverCertOption__: SXH_SERVER_CERT_OPTION,
    __proxySettingEnum__: SXH_PROXY_SETTING,
    __proxySetting__: SXH_PROXY_SETTING,
    __somItemTypeEnum__: SOMITEMTYPE,
    __somItemType__: SOMITEMTYPE,
    __schemaUseEnum__: SCHEMAUSE,
    __schemaUse__: SCHEMAUSE,
    __schemaDerivationMethodEnum__: SCHEMADERIVATIONMETHOD,
    __schemaDerivationMethod__: SCHEMADERIVATIONMETHOD,
    __schemaContentTypeEnum__: SCHEMACONTENTTYPE,
    __schemaContentType__: SCHEMACONTENTTYPE,
    __schemaProcessContentsEnum__: SCHEMAPROCESSCONTENTS,
    __schemaProcessContents__: SCHEMAPROCESSCONTENTS,
    __schemaWhitespaceEnum__: SCHEMAWHITESPACE,
    __schemaWhitespace__: SCHEMAWHITESPACE,
    __schemaTypeVarietyEnum__: SCHEMATYPEVARIETY,
    __schemaTypeVariety__: SCHEMATYPEVARIETY,
};

pub const XHR_COOKIE_STATE = enum(i32) {
    UNKNOWN = 0,
    ACCEPT = 1,
    PROMPT = 2,
    LEASH = 3,
    DOWNGRADE = 4,
    REJECT = 5,
};
pub const XHR_COOKIE_STATE_UNKNOWN = XHR_COOKIE_STATE.UNKNOWN;
pub const XHR_COOKIE_STATE_ACCEPT = XHR_COOKIE_STATE.ACCEPT;
pub const XHR_COOKIE_STATE_PROMPT = XHR_COOKIE_STATE.PROMPT;
pub const XHR_COOKIE_STATE_LEASH = XHR_COOKIE_STATE.LEASH;
pub const XHR_COOKIE_STATE_DOWNGRADE = XHR_COOKIE_STATE.DOWNGRADE;
pub const XHR_COOKIE_STATE_REJECT = XHR_COOKIE_STATE.REJECT;

pub const XHR_COOKIE_FLAG = enum(i32) {
    IS_SECURE = 1,
    IS_SESSION = 2,
    THIRD_PARTY = 16,
    PROMPT_REQUIRED = 32,
    EVALUATE_P3P = 64,
    APPLY_P3P = 128,
    P3P_ENABLED = 256,
    IS_RESTRICTED = 512,
    IE6 = 1024,
    IS_LEGACY = 2048,
    NON_SCRIPT = 4096,
    HTTPONLY = 8192,
};
pub const XHR_COOKIE_IS_SECURE = XHR_COOKIE_FLAG.IS_SECURE;
pub const XHR_COOKIE_IS_SESSION = XHR_COOKIE_FLAG.IS_SESSION;
pub const XHR_COOKIE_THIRD_PARTY = XHR_COOKIE_FLAG.THIRD_PARTY;
pub const XHR_COOKIE_PROMPT_REQUIRED = XHR_COOKIE_FLAG.PROMPT_REQUIRED;
pub const XHR_COOKIE_EVALUATE_P3P = XHR_COOKIE_FLAG.EVALUATE_P3P;
pub const XHR_COOKIE_APPLY_P3P = XHR_COOKIE_FLAG.APPLY_P3P;
pub const XHR_COOKIE_P3P_ENABLED = XHR_COOKIE_FLAG.P3P_ENABLED;
pub const XHR_COOKIE_IS_RESTRICTED = XHR_COOKIE_FLAG.IS_RESTRICTED;
pub const XHR_COOKIE_IE6 = XHR_COOKIE_FLAG.IE6;
pub const XHR_COOKIE_IS_LEGACY = XHR_COOKIE_FLAG.IS_LEGACY;
pub const XHR_COOKIE_NON_SCRIPT = XHR_COOKIE_FLAG.NON_SCRIPT;
pub const XHR_COOKIE_HTTPONLY = XHR_COOKIE_FLAG.HTTPONLY;

pub const XHR_CRED_PROMPT = enum(i32) {
    ALL = 0,
    NONE = 1,
    PROXY = 2,
};
pub const XHR_CRED_PROMPT_ALL = XHR_CRED_PROMPT.ALL;
pub const XHR_CRED_PROMPT_NONE = XHR_CRED_PROMPT.NONE;
pub const XHR_CRED_PROMPT_PROXY = XHR_CRED_PROMPT.PROXY;

pub const XHR_AUTH = enum(i32) {
    ALL = 0,
    NONE = 1,
    PROXY = 2,
};
pub const XHR_AUTH_ALL = XHR_AUTH.ALL;
pub const XHR_AUTH_NONE = XHR_AUTH.NONE;
pub const XHR_AUTH_PROXY = XHR_AUTH.PROXY;

pub const XHR_PROPERTY = enum(i32) {
    NO_CRED_PROMPT = 0,
    NO_AUTH = 1,
    TIMEOUT = 2,
    NO_DEFAULT_HEADERS = 3,
    REPORT_REDIRECT_STATUS = 4,
    NO_CACHE = 5,
    EXTENDED_ERROR = 6,
    QUERY_STRING_UTF8 = 7,
    IGNORE_CERT_ERRORS = 8,
    ONDATA_THRESHOLD = 9,
    SET_ENTERPRISEID = 10,
    MAX_CONNECTIONS = 11,
};
pub const XHR_PROP_NO_CRED_PROMPT = XHR_PROPERTY.NO_CRED_PROMPT;
pub const XHR_PROP_NO_AUTH = XHR_PROPERTY.NO_AUTH;
pub const XHR_PROP_TIMEOUT = XHR_PROPERTY.TIMEOUT;
pub const XHR_PROP_NO_DEFAULT_HEADERS = XHR_PROPERTY.NO_DEFAULT_HEADERS;
pub const XHR_PROP_REPORT_REDIRECT_STATUS = XHR_PROPERTY.REPORT_REDIRECT_STATUS;
pub const XHR_PROP_NO_CACHE = XHR_PROPERTY.NO_CACHE;
pub const XHR_PROP_EXTENDED_ERROR = XHR_PROPERTY.EXTENDED_ERROR;
pub const XHR_PROP_QUERY_STRING_UTF8 = XHR_PROPERTY.QUERY_STRING_UTF8;
pub const XHR_PROP_IGNORE_CERT_ERRORS = XHR_PROPERTY.IGNORE_CERT_ERRORS;
pub const XHR_PROP_ONDATA_THRESHOLD = XHR_PROPERTY.ONDATA_THRESHOLD;
pub const XHR_PROP_SET_ENTERPRISEID = XHR_PROPERTY.SET_ENTERPRISEID;
pub const XHR_PROP_MAX_CONNECTIONS = XHR_PROPERTY.MAX_CONNECTIONS;

pub const XHR_CERT_IGNORE_FLAG = enum(u32) {
    REVOCATION_FAILED = 128,
    UNKNOWN_CA = 256,
    CERT_CN_INVALID = 4096,
    CERT_DATE_INVALID = 8192,
    ALL_SERVER_ERRORS = 12672,
};
pub const XHR_CERT_IGNORE_REVOCATION_FAILED = XHR_CERT_IGNORE_FLAG.REVOCATION_FAILED;
pub const XHR_CERT_IGNORE_UNKNOWN_CA = XHR_CERT_IGNORE_FLAG.UNKNOWN_CA;
pub const XHR_CERT_IGNORE_CERT_CN_INVALID = XHR_CERT_IGNORE_FLAG.CERT_CN_INVALID;
pub const XHR_CERT_IGNORE_CERT_DATE_INVALID = XHR_CERT_IGNORE_FLAG.CERT_DATE_INVALID;
pub const XHR_CERT_IGNORE_ALL_SERVER_ERRORS = XHR_CERT_IGNORE_FLAG.ALL_SERVER_ERRORS;

pub const XHR_CERT_ERROR_FLAG = enum(u32) {
    REVOCATION_FAILED = 8388608,
    UNKNOWN_CA = 16777216,
    CERT_CN_INVALID = 33554432,
    CERT_DATE_INVALID = 67108864,
    ALL_SERVER_ERRORS = 125829120,
};
pub const XHR_CERT_ERROR_REVOCATION_FAILED = XHR_CERT_ERROR_FLAG.REVOCATION_FAILED;
pub const XHR_CERT_ERROR_UNKNOWN_CA = XHR_CERT_ERROR_FLAG.UNKNOWN_CA;
pub const XHR_CERT_ERROR_CERT_CN_INVALID = XHR_CERT_ERROR_FLAG.CERT_CN_INVALID;
pub const XHR_CERT_ERROR_CERT_DATE_INVALID = XHR_CERT_ERROR_FLAG.CERT_DATE_INVALID;
pub const XHR_CERT_ERROR_ALL_SERVER_ERRORS = XHR_CERT_ERROR_FLAG.ALL_SERVER_ERRORS;

pub const XHR_COOKIE = extern struct {
    pwszUrl: ?PWSTR,
    pwszName: ?PWSTR,
    pwszValue: ?PWSTR,
    pwszP3PPolicy: ?PWSTR,
    ftExpires: FILETIME,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IXMLHTTPRequest2Callback_Value = Guid.initString("a44a9299-e321-40de-8866-341b41669162");
pub const IID_IXMLHTTPRequest2Callback = &IID_IXMLHTTPRequest2Callback_Value;
pub const IXMLHTTPRequest2Callback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRedirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                pwszRedirectUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                pwszRedirectUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnHeadersAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                dwStatus: u32,
                pwszStatus: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                dwStatus: u32,
                pwszStatus: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDataAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                pResponseStream: ?*ISequentialStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                pResponseStream: ?*ISequentialStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnResponseReceived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                pResponseStream: ?*ISequentialStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                pResponseStream: ?*ISequentialStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2Callback,
                pXHR: ?*IXMLHTTPRequest2,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnRedirect(self: *const T, pXHR: ?*IXMLHTTPRequest2, pwszRedirectUrl: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2Callback.VTable, @ptrCast(self.vtable)).OnRedirect(@as(*const IXMLHTTPRequest2Callback, @ptrCast(self)), pXHR, pwszRedirectUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnHeadersAvailable(self: *const T, pXHR: ?*IXMLHTTPRequest2, dwStatus: u32, pwszStatus: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2Callback.VTable, @ptrCast(self.vtable)).OnHeadersAvailable(@as(*const IXMLHTTPRequest2Callback, @ptrCast(self)), pXHR, dwStatus, pwszStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnDataAvailable(self: *const T, pXHR: ?*IXMLHTTPRequest2, pResponseStream: ?*ISequentialStream) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2Callback.VTable, @ptrCast(self.vtable)).OnDataAvailable(@as(*const IXMLHTTPRequest2Callback, @ptrCast(self)), pXHR, pResponseStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnResponseReceived(self: *const T, pXHR: ?*IXMLHTTPRequest2, pResponseStream: ?*ISequentialStream) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2Callback.VTable, @ptrCast(self.vtable)).OnResponseReceived(@as(*const IXMLHTTPRequest2Callback, @ptrCast(self)), pXHR, pResponseStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2Callback_OnError(self: *const T, pXHR: ?*IXMLHTTPRequest2, hrError: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2Callback.VTable, @ptrCast(self.vtable)).OnError(@as(*const IXMLHTTPRequest2Callback, @ptrCast(self)), pXHR, hrError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IXMLHTTPRequest2_Value = Guid.initString("e5d37dc0-552a-4d52-9cc0-a14d546fbd04");
pub const IID_IXMLHTTPRequest2 = &IID_IXMLHTTPRequest2_Value;
pub const IXMLHTTPRequest2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pwszMethod: ?[*:0]const u16,
                pwszUrl: ?[*:0]const u16,
                pStatusCallback: ?*IXMLHTTPRequest2Callback,
                pwszUserName: ?[*:0]const u16,
                pwszPassword: ?[*:0]const u16,
                pwszProxyUserName: ?[*:0]const u16,
                pwszProxyPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pwszMethod: ?[*:0]const u16,
                pwszUrl: ?[*:0]const u16,
                pStatusCallback: ?*IXMLHTTPRequest2Callback,
                pwszUserName: ?[*:0]const u16,
                pwszPassword: ?[*:0]const u16,
                pwszProxyUserName: ?[*:0]const u16,
                pwszProxyPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Send: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pBody: ?*ISequentialStream,
                cbBody: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pBody: ?*ISequentialStream,
                cbBody: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pCookie: ?*const XHR_COOKIE,
                pdwCookieState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pCookie: ?*const XHR_COOKIE,
                pdwCookieState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustomResponseStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pSequentialStream: ?*ISequentialStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pSequentialStream: ?*ISequentialStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                eProperty: XHR_PROPERTY,
                ullValue: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                eProperty: XHR_PROPERTY,
                ullValue: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRequestHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pwszHeader: ?[*:0]const u16,
                pwszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pwszHeader: ?[*:0]const u16,
                pwszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllResponseHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                ppwszHeaders: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                ppwszHeaders: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pwszUrl: ?[*:0]const u16,
                pwszName: ?[*:0]const u16,
                dwFlags: u32,
                pcCookies: ?*u32,
                ppCookies: [*]?*XHR_COOKIE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pwszUrl: ?[*:0]const u16,
                pwszName: ?[*:0]const u16,
                dwFlags: u32,
                pcCookies: ?*u32,
                ppCookies: [*]?*XHR_COOKIE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResponseHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest2,
                pwszHeader: ?[*:0]const u16,
                ppwszValue: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest2,
                pwszHeader: ?[*:0]const u16,
                ppwszValue: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_Open(self: *const T, pwszMethod: ?[*:0]const u16, pwszUrl: ?[*:0]const u16, pStatusCallback: ?*IXMLHTTPRequest2Callback, pwszUserName: ?[*:0]const u16, pwszPassword: ?[*:0]const u16, pwszProxyUserName: ?[*:0]const u16, pwszProxyPassword: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).Open(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pwszMethod, pwszUrl, pStatusCallback, pwszUserName, pwszPassword, pwszProxyUserName, pwszProxyPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_Send(self: *const T, pBody: ?*ISequentialStream, cbBody: u64) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).Send(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pBody, cbBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).Abort(@as(*const IXMLHTTPRequest2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetCookie(self: *const T, pCookie: ?*const XHR_COOKIE, pdwCookieState: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).SetCookie(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pCookie, pdwCookieState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetCustomResponseStream(self: *const T, pSequentialStream: ?*ISequentialStream) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).SetCustomResponseStream(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pSequentialStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetProperty(self: *const T, eProperty: XHR_PROPERTY, ullValue: u64) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IXMLHTTPRequest2, @ptrCast(self)), eProperty, ullValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_SetRequestHeader(self: *const T, pwszHeader: ?[*:0]const u16, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).SetRequestHeader(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pwszHeader, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_GetAllResponseHeaders(self: *const T, ppwszHeaders: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).GetAllResponseHeaders(@as(*const IXMLHTTPRequest2, @ptrCast(self)), ppwszHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_GetCookie(self: *const T, pwszUrl: ?[*:0]const u16, pwszName: ?[*:0]const u16, dwFlags: u32, pcCookies: ?*u32, ppCookies: [*]?*XHR_COOKIE) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pwszUrl, pwszName, dwFlags, pcCookies, ppCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest2_GetResponseHeader(self: *const T, pwszHeader: ?[*:0]const u16, ppwszValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest2.VTable, @ptrCast(self.vtable)).GetResponseHeader(@as(*const IXMLHTTPRequest2, @ptrCast(self)), pwszHeader, ppwszValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const XHR_CERT = extern struct {
    cbCert: u32,
    pbCert: ?*u8,
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IXMLHTTPRequest3Callback_Value = Guid.initString("b9e57830-8c6c-4a6f-9c13-47772bb047bb");
pub const IID_IXMLHTTPRequest3Callback = &IID_IXMLHTTPRequest3Callback_Value;
pub const IXMLHTTPRequest3Callback = extern struct {
    pub const VTable = extern struct {
        base: IXMLHTTPRequest2Callback.VTable,
        OnServerCertificateReceived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest3Callback,
                pXHR: ?*IXMLHTTPRequest3,
                dwCertificateErrors: u32,
                cServerCertificateChain: u32,
                rgServerCertificateChain: [*]const XHR_CERT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest3Callback,
                pXHR: ?*IXMLHTTPRequest3,
                dwCertificateErrors: u32,
                cServerCertificateChain: u32,
                rgServerCertificateChain: [*]const XHR_CERT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClientCertificateRequested: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest3Callback,
                pXHR: ?*IXMLHTTPRequest3,
                cIssuerList: u32,
                rgpwszIssuerList: [*]const ?*const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest3Callback,
                pXHR: ?*IXMLHTTPRequest3,
                cIssuerList: u32,
                rgpwszIssuerList: [*]const ?*const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLHTTPRequest2Callback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest3Callback_OnServerCertificateReceived(self: *const T, pXHR: ?*IXMLHTTPRequest3, dwCertificateErrors: u32, cServerCertificateChain: u32, rgServerCertificateChain: [*]const XHR_CERT) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest3Callback.VTable, @ptrCast(self.vtable)).OnServerCertificateReceived(@as(*const IXMLHTTPRequest3Callback, @ptrCast(self)), pXHR, dwCertificateErrors, cServerCertificateChain, rgServerCertificateChain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest3Callback_OnClientCertificateRequested(self: *const T, pXHR: ?*IXMLHTTPRequest3, cIssuerList: u32, rgpwszIssuerList: [*]const ?*const u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest3Callback.VTable, @ptrCast(self.vtable)).OnClientCertificateRequested(@as(*const IXMLHTTPRequest3Callback, @ptrCast(self)), pXHR, cIssuerList, rgpwszIssuerList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IXMLHTTPRequest3_Value = Guid.initString("a1c9feee-0617-4f23-9d58-8961ea43567c");
pub const IID_IXMLHTTPRequest3 = &IID_IXMLHTTPRequest3_Value;
pub const IXMLHTTPRequest3 = extern struct {
    pub const VTable = extern struct {
        base: IXMLHTTPRequest2.VTable,
        SetClientCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXMLHTTPRequest3,
                cbClientCertificateHash: u32,
                pbClientCertificateHash: [*:0]const u8,
                pwszPin: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXMLHTTPRequest3,
                cbClientCertificateHash: u32,
                pbClientCertificateHash: [*:0]const u8,
                pwszPin: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLHTTPRequest2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHTTPRequest3_SetClientCertificate(self: *const T, cbClientCertificateHash: u32, pbClientCertificateHash: [*:0]const u8, pwszPin: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IXMLHTTPRequest3.VTable, @ptrCast(self.vtable)).SetClientCertificate(@as(*const IXMLHTTPRequest3, @ptrCast(self)), cbClientCertificateHash, pbClientCertificateHash, pwszPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (10)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BSTR = @import("../../foundation.zig").BSTR;
const FILETIME = @import("../../foundation.zig").FILETIME;
const HRESULT = @import("../../foundation.zig").HRESULT;
const IDispatch = @import("../../system/com.zig").IDispatch;
const ISequentialStream = @import("../../system/com.zig").ISequentialStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const PWSTR = @import("../../foundation.zig").PWSTR;
const VARIANT = @import("../../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
