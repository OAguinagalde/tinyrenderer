//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (274)
//--------------------------------------------------------------------------------
pub const HH_DISPLAY_TOPIC = @as(u32, 0);
pub const HH_HELP_FINDER = @as(u32, 0);
pub const HH_DISPLAY_TOC = @as(u32, 1);
pub const HH_DISPLAY_INDEX = @as(u32, 2);
pub const HH_DISPLAY_SEARCH = @as(u32, 3);
pub const HH_SET_WIN_TYPE = @as(u32, 4);
pub const HH_GET_WIN_TYPE = @as(u32, 5);
pub const HH_GET_WIN_HANDLE = @as(u32, 6);
pub const HH_ENUM_INFO_TYPE = @as(u32, 7);
pub const HH_SET_INFO_TYPE = @as(u32, 8);
pub const HH_SYNC = @as(u32, 9);
pub const HH_RESERVED1 = @as(u32, 10);
pub const HH_RESERVED2 = @as(u32, 11);
pub const HH_RESERVED3 = @as(u32, 12);
pub const HH_KEYWORD_LOOKUP = @as(u32, 13);
pub const HH_DISPLAY_TEXT_POPUP = @as(u32, 14);
pub const HH_HELP_CONTEXT = @as(u32, 15);
pub const HH_TP_HELP_CONTEXTMENU = @as(u32, 16);
pub const HH_TP_HELP_WM_HELP = @as(u32, 17);
pub const HH_CLOSE_ALL = @as(u32, 18);
pub const HH_ALINK_LOOKUP = @as(u32, 19);
pub const HH_GET_LAST_ERROR = @as(u32, 20);
pub const HH_ENUM_CATEGORY = @as(u32, 21);
pub const HH_ENUM_CATEGORY_IT = @as(u32, 22);
pub const HH_RESET_IT_FILTER = @as(u32, 23);
pub const HH_SET_INCLUSIVE_FILTER = @as(u32, 24);
pub const HH_SET_EXCLUSIVE_FILTER = @as(u32, 25);
pub const HH_INITIALIZE = @as(u32, 28);
pub const HH_UNINITIALIZE = @as(u32, 29);
pub const HH_SET_QUERYSERVICE = @as(u32, 30);
pub const HH_PRETRANSLATEMESSAGE = @as(u32, 253);
pub const HH_SET_GLOBAL_PROPERTY = @as(u32, 252);
pub const HH_SAFE_DISPLAY_TOPIC = @as(u32, 32);
pub const HHWIN_PROP_TAB_AUTOHIDESHOW = @as(u32, 1);
pub const HHWIN_PROP_ONTOP = @as(u32, 2);
pub const HHWIN_PROP_NOTITLEBAR = @as(u32, 4);
pub const HHWIN_PROP_NODEF_STYLES = @as(u32, 8);
pub const HHWIN_PROP_NODEF_EXSTYLES = @as(u32, 16);
pub const HHWIN_PROP_TRI_PANE = @as(u32, 32);
pub const HHWIN_PROP_NOTB_TEXT = @as(u32, 64);
pub const HHWIN_PROP_POST_QUIT = @as(u32, 128);
pub const HHWIN_PROP_AUTO_SYNC = @as(u32, 256);
pub const HHWIN_PROP_TRACKING = @as(u32, 512);
pub const HHWIN_PROP_TAB_SEARCH = @as(u32, 1024);
pub const HHWIN_PROP_TAB_HISTORY = @as(u32, 2048);
pub const HHWIN_PROP_TAB_FAVORITES = @as(u32, 4096);
pub const HHWIN_PROP_CHANGE_TITLE = @as(u32, 8192);
pub const HHWIN_PROP_NAV_ONLY_WIN = @as(u32, 16384);
pub const HHWIN_PROP_NO_TOOLBAR = @as(u32, 32768);
pub const HHWIN_PROP_MENU = @as(u32, 65536);
pub const HHWIN_PROP_TAB_ADVSEARCH = @as(u32, 131072);
pub const HHWIN_PROP_USER_POS = @as(u32, 262144);
pub const HHWIN_PROP_TAB_CUSTOM1 = @as(u32, 524288);
pub const HHWIN_PROP_TAB_CUSTOM2 = @as(u32, 1048576);
pub const HHWIN_PROP_TAB_CUSTOM3 = @as(u32, 2097152);
pub const HHWIN_PROP_TAB_CUSTOM4 = @as(u32, 4194304);
pub const HHWIN_PROP_TAB_CUSTOM5 = @as(u32, 8388608);
pub const HHWIN_PROP_TAB_CUSTOM6 = @as(u32, 16777216);
pub const HHWIN_PROP_TAB_CUSTOM7 = @as(u32, 33554432);
pub const HHWIN_PROP_TAB_CUSTOM8 = @as(u32, 67108864);
pub const HHWIN_PROP_TAB_CUSTOM9 = @as(u32, 134217728);
pub const HHWIN_TB_MARGIN = @as(u32, 268435456);
pub const HHWIN_PARAM_PROPERTIES = @as(u32, 2);
pub const HHWIN_PARAM_STYLES = @as(u32, 4);
pub const HHWIN_PARAM_EXSTYLES = @as(u32, 8);
pub const HHWIN_PARAM_RECT = @as(u32, 16);
pub const HHWIN_PARAM_NAV_WIDTH = @as(u32, 32);
pub const HHWIN_PARAM_SHOWSTATE = @as(u32, 64);
pub const HHWIN_PARAM_INFOTYPES = @as(u32, 128);
pub const HHWIN_PARAM_TB_FLAGS = @as(u32, 256);
pub const HHWIN_PARAM_EXPANSION = @as(u32, 512);
pub const HHWIN_PARAM_TABPOS = @as(u32, 1024);
pub const HHWIN_PARAM_TABORDER = @as(u32, 2048);
pub const HHWIN_PARAM_HISTORY_COUNT = @as(u32, 4096);
pub const HHWIN_PARAM_CUR_TAB = @as(u32, 8192);
pub const HHWIN_BUTTON_EXPAND = @as(u32, 2);
pub const HHWIN_BUTTON_BACK = @as(u32, 4);
pub const HHWIN_BUTTON_FORWARD = @as(u32, 8);
pub const HHWIN_BUTTON_STOP = @as(u32, 16);
pub const HHWIN_BUTTON_REFRESH = @as(u32, 32);
pub const HHWIN_BUTTON_HOME = @as(u32, 64);
pub const HHWIN_BUTTON_BROWSE_FWD = @as(u32, 128);
pub const HHWIN_BUTTON_BROWSE_BCK = @as(u32, 256);
pub const HHWIN_BUTTON_NOTES = @as(u32, 512);
pub const HHWIN_BUTTON_CONTENTS = @as(u32, 1024);
pub const HHWIN_BUTTON_SYNC = @as(u32, 2048);
pub const HHWIN_BUTTON_OPTIONS = @as(u32, 4096);
pub const HHWIN_BUTTON_PRINT = @as(u32, 8192);
pub const HHWIN_BUTTON_INDEX = @as(u32, 16384);
pub const HHWIN_BUTTON_SEARCH = @as(u32, 32768);
pub const HHWIN_BUTTON_HISTORY = @as(u32, 65536);
pub const HHWIN_BUTTON_FAVORITES = @as(u32, 131072);
pub const HHWIN_BUTTON_JUMP1 = @as(u32, 262144);
pub const HHWIN_BUTTON_JUMP2 = @as(u32, 524288);
pub const HHWIN_BUTTON_ZOOM = @as(u32, 1048576);
pub const HHWIN_BUTTON_TOC_NEXT = @as(u32, 2097152);
pub const HHWIN_BUTTON_TOC_PREV = @as(u32, 4194304);
pub const IDTB_EXPAND = @as(u32, 200);
pub const IDTB_CONTRACT = @as(u32, 201);
pub const IDTB_STOP = @as(u32, 202);
pub const IDTB_REFRESH = @as(u32, 203);
pub const IDTB_BACK = @as(u32, 204);
pub const IDTB_HOME = @as(u32, 205);
pub const IDTB_SYNC = @as(u32, 206);
pub const IDTB_PRINT = @as(u32, 207);
pub const IDTB_OPTIONS = @as(u32, 208);
pub const IDTB_FORWARD = @as(u32, 209);
pub const IDTB_NOTES = @as(u32, 210);
pub const IDTB_BROWSE_FWD = @as(u32, 211);
pub const IDTB_BROWSE_BACK = @as(u32, 212);
pub const IDTB_CONTENTS = @as(u32, 213);
pub const IDTB_INDEX = @as(u32, 214);
pub const IDTB_SEARCH = @as(u32, 215);
pub const IDTB_HISTORY = @as(u32, 216);
pub const IDTB_FAVORITES = @as(u32, 217);
pub const IDTB_JUMP1 = @as(u32, 218);
pub const IDTB_JUMP2 = @as(u32, 219);
pub const IDTB_CUSTOMIZE = @as(u32, 221);
pub const IDTB_ZOOM = @as(u32, 222);
pub const IDTB_TOC_NEXT = @as(u32, 223);
pub const IDTB_TOC_PREV = @as(u32, 224);
pub const HH_MAX_TABS = @as(u32, 19);
pub const HH_FTS_DEFAULT_PROXIMITY = @as(i32, -1);
pub const CLSID_IITPropList = Guid.initString("4662daae-d393-11d0-9a56-00c04fb68bf7");
pub const PROP_ADD = @as(u32, 0);
pub const PROP_DELETE = @as(u32, 1);
pub const PROP_UPDATE = @as(u32, 2);
pub const TYPE_VALUE = @as(u32, 0);
pub const TYPE_POINTER = @as(u32, 1);
pub const TYPE_STRING = @as(u32, 2);
pub const CLSID_IITDatabase = Guid.initString("66673452-8c23-11d0-a84e-00aa006c7d01");
pub const CLSID_IITDatabaseLocal = Guid.initString("4662daa9-d393-11d0-9a56-00c04fb68bf7");
pub const STDPROP_UID = @as(u32, 1);
pub const STDPROP_TITLE = @as(u32, 2);
pub const STDPROP_USERDATA = @as(u32, 3);
pub const STDPROP_KEY = @as(u32, 4);
pub const STDPROP_SORTKEY = @as(u32, 100);
pub const STDPROP_DISPLAYKEY = @as(u32, 101);
pub const STDPROP_SORTORDINAL = @as(u32, 102);
pub const STDPROP_INDEX_TEXT = @as(u32, 200);
pub const STDPROP_INDEX_VFLD = @as(u32, 201);
pub const STDPROP_INDEX_DTYPE = @as(u32, 202);
pub const STDPROP_INDEX_LENGTH = @as(u32, 203);
pub const STDPROP_INDEX_BREAK = @as(u32, 204);
pub const STDPROP_INDEX_TERM = @as(u32, 210);
pub const STDPROP_INDEX_TERM_RAW_LENGTH = @as(u32, 211);
pub const STDPROP_USERPROP_BASE = @as(u32, 65536);
pub const STDPROP_USERPROP_MAX = @as(u32, 2147483647);
pub const SZ_WWDEST_GLOBAL = "GLOBAL";
pub const SZ_WWDEST_KEY = "KEY";
pub const SZ_WWDEST_OCC = "OCC";
pub const CLSID_IITCmdInt = Guid.initString("4662daa2-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITSvMgr = Guid.initString("4662daa3-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITWordWheelUpdate = Guid.initString("4662daa5-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITGroupUpdate = Guid.initString("4662daa4-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_IITIndexBuild = Guid.initString("8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7");
pub const CLSID_IITWWFilterBuild = Guid.initString("8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7");
pub const CLSID_IITWordWheel = Guid.initString("d73725c2-8c12-11d0-a84e-00aa006c7d01");
pub const CLSID_IITWordWheelLocal = Guid.initString("4662daa8-d393-11d0-9a56-00c04fb68bf7");
pub const ITWW_OPEN_NOCONNECT = @as(u32, 1);
pub const ITWW_CBKEY_MAX = @as(u32, 1024);
pub const IITWBC_BREAK_ACCEPT_WILDCARDS = @as(u32, 1);
pub const IITWBC_BREAK_AND_STEM = @as(u32, 2);
pub const E_NOTEXIST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479552));
pub const E_DUPLICATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479551));
pub const E_BADVERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479550));
pub const E_BADFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479549));
pub const E_BADFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479548));
pub const E_NOPERMISSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479547));
pub const E_ASSERT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479546));
pub const E_INTERRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479545));
pub const E_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479544));
pub const E_OUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479543));
pub const E_GROUPIDTOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479542));
pub const E_TOOMANYTITLES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479541));
pub const E_NOMERGEDDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479540));
pub const E_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479539));
pub const E_CANTFINDDLL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479538));
pub const E_NOHANDLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479537));
pub const E_GETLASTERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479536));
pub const E_BADPARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479535));
pub const E_INVALIDSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479534));
pub const E_NOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479533));
pub const E_ALREADYOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479533));
pub const E_UNKNOWN_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479530));
pub const E_UNSUPPORTED_TRANSPORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479529));
pub const E_BADFILTERSIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479528));
pub const E_TOOMANYOBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479527));
pub const E_NAMETOOLONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479520));
pub const E_FILECREATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479504));
pub const E_FILECLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479503));
pub const E_FILEREAD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479502));
pub const E_FILESEEK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479501));
pub const E_FILEWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479500));
pub const E_FILEDELETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479499));
pub const E_FILEINVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479498));
pub const E_FILENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479497));
pub const E_DISKFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479496));
pub const E_TOOMANYTOPICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479472));
pub const E_TOOMANYDUPS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479471));
pub const E_TREETOOBIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479470));
pub const E_BADBREAKER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479469));
pub const E_BADVALUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479468));
pub const E_ALL_WILD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479467));
pub const E_TOODEEP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479466));
pub const E_EXPECTEDTERM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479465));
pub const E_MISSLPAREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479464));
pub const E_MISSRPAREN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479463));
pub const E_MISSQUOTE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479462));
pub const E_NULLQUERY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479461));
pub const E_STOPWORD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479460));
pub const E_BADRANGEOP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479459));
pub const E_UNMATCHEDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479458));
pub const E_WORDTOOLONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479457));
pub const E_BADINDEXFLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479456));
pub const E_WILD_IN_DTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479455));
pub const E_NOSTEMMER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479454));
pub const E_MISSINGPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479424));
pub const E_PROPLISTNOTEMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479423));
pub const E_PROPLISTEMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479422));
pub const E_ALREADYINIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479421));
pub const E_NOTINIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479420));
pub const E_RESULTSETEMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479419));
pub const E_TOOMANYCOLUMNS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479418));
pub const E_NOKEYPROP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147479417));
pub const CLSID_IITResultSet = Guid.initString("4662daa7-d393-11d0-9a56-00c04fb68bf7");
pub const MAX_COLUMNS = @as(u32, 256);
pub const CLSID_ITStdBreaker = Guid.initString("4662daaf-d393-11d0-9a56-00c04fb68bf7");
pub const CLSID_ITEngStemmer = Guid.initString("8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7");
pub const HHWIN_NAVTYPE_TOC = @as(i32, 0);
pub const HHWIN_NAVTYPE_INDEX = @as(i32, 1);
pub const HHWIN_NAVTYPE_SEARCH = @as(i32, 2);
pub const HHWIN_NAVTYPE_FAVORITES = @as(i32, 3);
pub const HHWIN_NAVTYPE_HISTORY = @as(i32, 4);
pub const HHWIN_NAVTYPE_AUTHOR = @as(i32, 5);
pub const HHWIN_NAVTYPE_CUSTOM_FIRST = @as(i32, 11);
pub const IT_INCLUSIVE = @as(i32, 0);
pub const IT_EXCLUSIVE = @as(i32, 1);
pub const IT_HIDDEN = @as(i32, 2);
pub const HHWIN_NAVTAB_TOP = @as(i32, 0);
pub const HHWIN_NAVTAB_LEFT = @as(i32, 1);
pub const HHWIN_NAVTAB_BOTTOM = @as(i32, 2);
pub const HH_TAB_CONTENTS = @as(i32, 0);
pub const HH_TAB_INDEX = @as(i32, 1);
pub const HH_TAB_SEARCH = @as(i32, 2);
pub const HH_TAB_FAVORITES = @as(i32, 3);
pub const HH_TAB_HISTORY = @as(i32, 4);
pub const HH_TAB_AUTHOR = @as(i32, 5);
pub const HH_TAB_CUSTOM_FIRST = @as(i32, 11);
pub const HH_TAB_CUSTOM_LAST = @as(i32, 19);
pub const HHACT_TAB_CONTENTS = @as(i32, 0);
pub const HHACT_TAB_INDEX = @as(i32, 1);
pub const HHACT_TAB_SEARCH = @as(i32, 2);
pub const HHACT_TAB_HISTORY = @as(i32, 3);
pub const HHACT_TAB_FAVORITES = @as(i32, 4);
pub const HHACT_EXPAND = @as(i32, 5);
pub const HHACT_CONTRACT = @as(i32, 6);
pub const HHACT_BACK = @as(i32, 7);
pub const HHACT_FORWARD = @as(i32, 8);
pub const HHACT_STOP = @as(i32, 9);
pub const HHACT_REFRESH = @as(i32, 10);
pub const HHACT_HOME = @as(i32, 11);
pub const HHACT_SYNC = @as(i32, 12);
pub const HHACT_OPTIONS = @as(i32, 13);
pub const HHACT_PRINT = @as(i32, 14);
pub const HHACT_HIGHLIGHT = @as(i32, 15);
pub const HHACT_CUSTOMIZE = @as(i32, 16);
pub const HHACT_JUMP1 = @as(i32, 17);
pub const HHACT_JUMP2 = @as(i32, 18);
pub const HHACT_ZOOM = @as(i32, 19);
pub const HHACT_TOC_NEXT = @as(i32, 20);
pub const HHACT_TOC_PREV = @as(i32, 21);
pub const HHACT_NOTES = @as(i32, 22);
pub const HHACT_LAST_ENUM = @as(i32, 23);

//--------------------------------------------------------------------------------
// Section: Types (27)
//--------------------------------------------------------------------------------
pub const WORD_WHEEL_OPEN_FLAGS = enum(u32) {
    T = 0,
    _,
    pub fn initFlags(o: struct {
        T: u1 = 0,
    }) WORD_WHEEL_OPEN_FLAGS {
        return @as(WORD_WHEEL_OPEN_FLAGS, @enumFromInt(
              (if (o.T == 1) @intFromEnum(WORD_WHEEL_OPEN_FLAGS.T) else 0)
        ));
    }
};
pub const ITWW_OPEN_CONNECT = WORD_WHEEL_OPEN_FLAGS.T;

pub const HHN_NOTIFY = extern struct {
    hdr: NMHDR,
    pszUrl: ?[*:0]const u8,
};

pub const HH_POPUP = extern struct {
    cbStruct: i32,
    hinst: ?HINSTANCE,
    idString: u32,
    pszText: ?*i8,
    pt: POINT,
    clrForeground: u32,
    clrBackground: u32,
    rcMargins: RECT,
    pszFont: ?*i8,
};

pub const HH_AKLINK = extern struct {
    cbStruct: i32,
    fReserved: BOOL,
    pszKeywords: ?*i8,
    pszUrl: ?*i8,
    pszMsgText: ?*i8,
    pszMsgTitle: ?*i8,
    pszWindow: ?*i8,
    fIndexOnFail: BOOL,
};

pub const HH_ENUM_IT = extern struct {
    cbStruct: i32,
    iType: i32,
    pszCatName: ?[*:0]const u8,
    pszITName: ?[*:0]const u8,
    pszITDescription: ?[*:0]const u8,
};

pub const HH_ENUM_CAT = extern struct {
    cbStruct: i32,
    pszCatName: ?[*:0]const u8,
    pszCatDescription: ?[*:0]const u8,
};

pub const HH_SET_INFOTYPE = extern struct {
    cbStruct: i32,
    pszCatName: ?[*:0]const u8,
    pszInfoTypeName: ?[*:0]const u8,
};

pub const HH_FTS_QUERY = extern struct {
    cbStruct: i32,
    fUniCodeStrings: BOOL,
    pszSearchQuery: ?*i8,
    iProximity: i32,
    fStemmedSearch: BOOL,
    fTitleOnly: BOOL,
    fExecute: BOOL,
    pszWindow: ?*i8,
};

pub const HH_WINTYPE = extern struct {
    cbStruct: i32,
    fUniCodeStrings: BOOL,
    pszType: ?*i8,
    fsValidMembers: u32,
    fsWinProperties: u32,
    pszCaption: ?*i8,
    dwStyles: u32,
    dwExStyles: u32,
    rcWindowPos: RECT,
    nShowState: i32,
    hwndHelp: ?HWND,
    hwndCaller: ?HWND,
    paInfoTypes: ?*u32,
    hwndToolBar: ?HWND,
    hwndNavigation: ?HWND,
    hwndHTML: ?HWND,
    iNavWidth: i32,
    rcHTML: RECT,
    pszToc: ?*i8,
    pszIndex: ?*i8,
    pszFile: ?*i8,
    pszHome: ?*i8,
    fsToolBarFlags: u32,
    fNotExpanded: BOOL,
    curNavType: i32,
    tabpos: i32,
    idNotify: i32,
    tabOrder: [20]u8,
    cHistory: i32,
    pszJump1: ?*i8,
    pszJump2: ?*i8,
    pszUrlJump1: ?*i8,
    pszUrlJump2: ?*i8,
    rcMinSize: RECT,
    cbInfoTypes: i32,
    pszCustomTabs: ?*i8,
};

pub const HHNTRACK = extern struct {
    hdr: NMHDR,
    pszCurUrl: ?[*:0]const u8,
    idAction: i32,
    phhWinType: ?*HH_WINTYPE,
};

pub const HH_GPROPID = enum(i32) {
    SINGLETHREAD = 1,
    TOOLBAR_MARGIN = 2,
    UI_LANGUAGE = 3,
    CURRENT_SUBSET = 4,
    CONTENT_LANGUAGE = 5,
};
pub const HH_GPROPID_SINGLETHREAD = HH_GPROPID.SINGLETHREAD;
pub const HH_GPROPID_TOOLBAR_MARGIN = HH_GPROPID.TOOLBAR_MARGIN;
pub const HH_GPROPID_UI_LANGUAGE = HH_GPROPID.UI_LANGUAGE;
pub const HH_GPROPID_CURRENT_SUBSET = HH_GPROPID.CURRENT_SUBSET;
pub const HH_GPROPID_CONTENT_LANGUAGE = HH_GPROPID.CONTENT_LANGUAGE;

pub const HH_GLOBAL_PROPERTY = extern struct {
    id: HH_GPROPID,
    @"var": VARIANT,
};

pub const CProperty = extern struct {
    dwPropID: u32,
    cbData: u32,
    dwType: u32,
    Anonymous: extern union {
        lpszwData: ?PWSTR,
        lpvData: ?*anyopaque,
        dwValue: u32,
    },
    fPersist: BOOL,
};

const IID_IITPropList_Value = Guid.initString("1f403bb1-9997-11d0-a850-00aa006c7d01");
pub const IID_IITPropList = &IID_IITPropList_Value;
pub const IITPropList = extern struct {
    pub const VTable = extern struct {
        base: IPersistStreamInit.VTable,
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                PropID: u32,
                lpszwString: ?[*:0]const u16,
                dwOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                PropID: u32,
                lpszwString: ?[*:0]const u16,
                dwOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                PropID: u32,
                lpvData: ?*anyopaque,
                cbData: u32,
                dwOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                PropID: u32,
                lpvData: ?*anyopaque,
                cbData: u32,
                dwOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                PropID: u32,
                dwData: u32,
                dwOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                PropID: u32,
                dwData: u32,
                dwOperation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                Prop: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                Prop: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                PropID: u32,
                Property: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                PropID: u32,
                Property: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPersist: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                fPersist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                fPersist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPersist1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                PropID: u32,
                fPersist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                PropID: u32,
                fPersist: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirst: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                Property: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                Property: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                Property: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                Property: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                cProp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                cProp: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                lpvData: ?*anyopaque,
                dwHdrSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                lpvData: ?*anyopaque,
                dwHdrSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                lpvHeader: ?*anyopaque,
                dwHdrSize: u32,
                lpvData: ?*anyopaque,
                dwBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                lpvHeader: ?*anyopaque,
                dwHdrSize: u32,
                lpvData: ?*anyopaque,
                dwBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHeaderSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                dwHdrSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                dwHdrSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                lpvHeader: ?*anyopaque,
                dwHdrSize: u32,
                dwDataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                lpvHeader: ?*anyopaque,
                dwHdrSize: u32,
                dwDataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveDataToStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                lpvHeader: ?*anyopaque,
                dwHdrSize: u32,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                lpvHeader: ?*anyopaque,
                dwHdrSize: u32,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadFromMem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                lpvData: ?*anyopaque,
                dwBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                lpvData: ?*anyopaque,
                dwBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveToMem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITPropList,
                lpvData: ?*anyopaque,
                dwBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITPropList,
                lpvData: ?*anyopaque,
                dwBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistStreamInit.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Set(self: *const T, PropID: u32, lpszwString: ?[*:0]const u16, dwOperation: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Set(@as(*const IITPropList, @ptrCast(self)), PropID, lpszwString, dwOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Set1(self: *const T, PropID: u32, lpvData: ?*anyopaque, cbData: u32, dwOperation: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Set(@as(*const IITPropList, @ptrCast(self)), PropID, lpvData, cbData, dwOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Set2(self: *const T, PropID: u32, dwData: u32, dwOperation: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Set(@as(*const IITPropList, @ptrCast(self)), PropID, dwData, dwOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Add(self: *const T, Prop: ?*CProperty) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Add(@as(*const IITPropList, @ptrCast(self)), Prop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Get(self: *const T, PropID: u32, Property: ?*CProperty) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Get(@as(*const IITPropList, @ptrCast(self)), PropID, Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).Clear(@as(*const IITPropList, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SetPersist(self: *const T, fPersist: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SetPersist(@as(*const IITPropList, @ptrCast(self)), fPersist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SetPersist1(self: *const T, PropID: u32, fPersist: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SetPersist(@as(*const IITPropList, @ptrCast(self)), PropID, fPersist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetFirst(self: *const T, Property: ?*CProperty) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetFirst(@as(*const IITPropList, @ptrCast(self)), Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetNext(self: *const T, Property: ?*CProperty) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IITPropList, @ptrCast(self)), Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetPropCount(self: *const T, cProp: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetPropCount(@as(*const IITPropList, @ptrCast(self)), cProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveHeader(self: *const T, lpvData: ?*anyopaque, dwHdrSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveHeader(@as(*const IITPropList, @ptrCast(self)), lpvData, dwHdrSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveData(self: *const T, lpvHeader: ?*anyopaque, dwHdrSize: u32, lpvData: ?*anyopaque, dwBufSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveData(@as(*const IITPropList, @ptrCast(self)), lpvHeader, dwHdrSize, lpvData, dwBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetHeaderSize(self: *const T, dwHdrSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetHeaderSize(@as(*const IITPropList, @ptrCast(self)), dwHdrSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetDataSize(self: *const T, lpvHeader: ?*anyopaque, dwHdrSize: u32, dwDataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).GetDataSize(@as(*const IITPropList, @ptrCast(self)), lpvHeader, dwHdrSize, dwDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveDataToStream(self: *const T, lpvHeader: ?*anyopaque, dwHdrSize: u32, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveDataToStream(@as(*const IITPropList, @ptrCast(self)), lpvHeader, dwHdrSize, pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_LoadFromMem(self: *const T, lpvData: ?*anyopaque, dwBufSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).LoadFromMem(@as(*const IITPropList, @ptrCast(self)), lpvData, dwBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveToMem(self: *const T, lpvData: ?*anyopaque, dwBufSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IITPropList.VTable, @ptrCast(self.vtable)).SaveToMem(@as(*const IITPropList, @ptrCast(self)), lpvData, dwBufSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IITDatabase_Value = Guid.initString("8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IITDatabase = &IID_IITDatabase_Value;
pub const IITDatabase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITDatabase,
                lpszHost: ?[*:0]const u16,
                lpszMoniker: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITDatabase,
                lpszHost: ?[*:0]const u16,
                lpszMoniker: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITDatabase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITDatabase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITDatabase,
                rclsid: ?*const Guid,
                pdwObjInstance: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITDatabase,
                rclsid: ?*const Guid,
                pdwObjInstance: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITDatabase,
                dwObjInstance: u32,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITDatabase,
                dwObjInstance: u32,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectPersistence: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITDatabase,
                lpwszObject: ?[*:0]const u16,
                dwObjInstance: u32,
                ppvPersistence: ?*?*anyopaque,
                fStream: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITDatabase,
                lpwszObject: ?[*:0]const u16,
                dwObjInstance: u32,
                ppvPersistence: ?*?*anyopaque,
                fStream: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_Open(self: *const T, lpszHost: ?[*:0]const u16, lpszMoniker: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).Open(@as(*const IITDatabase, @ptrCast(self)), lpszHost, lpszMoniker, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).Close(@as(*const IITDatabase, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_CreateObject(self: *const T, rclsid: ?*const Guid, pdwObjInstance: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).CreateObject(@as(*const IITDatabase, @ptrCast(self)), rclsid, pdwObjInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_GetObject(self: *const T, dwObjInstance: u32, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IITDatabase, @ptrCast(self)), dwObjInstance, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_GetObjectPersistence(self: *const T, lpwszObject: ?[*:0]const u16, dwObjInstance: u32, ppvPersistence: ?*?*anyopaque, fStream: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IITDatabase.VTable, @ptrCast(self.vtable)).GetObjectPersistence(@as(*const IITDatabase, @ptrCast(self)), lpwszObject, dwObjInstance, ppvPersistence, fStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IITGroup = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const IITQuery = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IITWordWheel_Value = Guid.initString("8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IITWordWheel = &IID_IITWordWheel_Value;
pub const IITWordWheel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                lpITDB: ?*IITDatabase,
                lpszMoniker: ?[*:0]const u16,
                dwFlags: WORD_WHEEL_OPEN_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                lpITDB: ?*IITDatabase,
                lpszMoniker: ?[*:0]const u16,
                dwFlags: WORD_WHEEL_OPEN_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocaleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                pdwCodePageID: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                pdwCodePageID: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSorterInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                pdwObjInstance: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                pdwObjInstance: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Count: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                pcEntries: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                pcEntries: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Lookup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                lpcvPrefix: ?*const anyopaque,
                fExactMatch: BOOL,
                plEntry: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                lpcvPrefix: ?*const anyopaque,
                fExactMatch: BOOL,
                plEntry: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Lookup1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                lEntry: i32,
                lpITResult: ?*IITResultSet,
                cEntries: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                lEntry: i32,
                lpITResult: ?*IITResultSet,
                cEntries: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Lookup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                lEntry: i32,
                lpvKeyBuf: ?*anyopaque,
                cbKeyBuf: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                lEntry: i32,
                lpvKeyBuf: ?*anyopaque,
                cbKeyBuf: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                piitGroup: ?*IITGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                piitGroup: ?*IITGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                ppiitGroup: ?*?*IITGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                ppiitGroup: ?*?*IITGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                lEntry: i32,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                lEntry: i32,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                lEntry: i32,
                lpITResult: ?*IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                lEntry: i32,
                lpITResult: ?*IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITWordWheel,
                pRS: ?*IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITWordWheel,
                pRS: ?*IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Open(self: *const T, lpITDB: ?*IITDatabase, lpszMoniker: ?[*:0]const u16, dwFlags: WORD_WHEEL_OPEN_FLAGS) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Open(@as(*const IITWordWheel, @ptrCast(self)), lpITDB, lpszMoniker, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Close(@as(*const IITWordWheel, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetLocaleInfo(self: *const T, pdwCodePageID: ?*u32, plcid: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetLocaleInfo(@as(*const IITWordWheel, @ptrCast(self)), pdwCodePageID, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetSorterInstance(self: *const T, pdwObjInstance: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetSorterInstance(@as(*const IITWordWheel, @ptrCast(self)), pdwObjInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Count(self: *const T, pcEntries: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Count(@as(*const IITWordWheel, @ptrCast(self)), pcEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Lookup(self: *const T, lpcvPrefix: ?*const anyopaque, fExactMatch: BOOL, plEntry: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Lookup(@as(*const IITWordWheel, @ptrCast(self)), lpcvPrefix, fExactMatch, plEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Lookup1(self: *const T, lEntry: i32, lpITResult: ?*IITResultSet, cEntries: i32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Lookup(@as(*const IITWordWheel, @ptrCast(self)), lEntry, lpITResult, cEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Lookup2(self: *const T, lEntry: i32, lpvKeyBuf: ?*anyopaque, cbKeyBuf: u32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).Lookup(@as(*const IITWordWheel, @ptrCast(self)), lEntry, lpvKeyBuf, cbKeyBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_SetGroup(self: *const T, piitGroup: ?*IITGroup) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).SetGroup(@as(*const IITWordWheel, @ptrCast(self)), piitGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetGroup(self: *const T, ppiitGroup: ?*?*IITGroup) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetGroup(@as(*const IITWordWheel, @ptrCast(self)), ppiitGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetDataCount(self: *const T, lEntry: i32, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetDataCount(@as(*const IITWordWheel, @ptrCast(self)), lEntry, pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetData(self: *const T, lEntry: i32, lpITResult: ?*IITResultSet) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetData(@as(*const IITWordWheel, @ptrCast(self)), lEntry, lpITResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetDataColumns(self: *const T, pRS: ?*IITResultSet) callconv(.Inline) HRESULT {
            return @as(*const IITWordWheel.VTable, @ptrCast(self.vtable)).GetDataColumns(@as(*const IITWordWheel, @ptrCast(self)), pRS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStemSink_Value = Guid.initString("fe77c330-7f42-11ce-be57-00aa0051fe20");
pub const IID_IStemSink = &IID_IStemSink_Value;
pub const IStemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutWord: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemSink,
                pwcInBuf: ?[*:0]const u16,
                cwc: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemSink_PutAltWord(self: *const T, pwcInBuf: ?[*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
            return @as(*const IStemSink.VTable, @ptrCast(self.vtable)).PutAltWord(@as(*const IStemSink, @ptrCast(self)), pwcInBuf, cwc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemSink_PutWord(self: *const T, pwcInBuf: ?[*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
            return @as(*const IStemSink.VTable, @ptrCast(self.vtable)).PutWord(@as(*const IStemSink, @ptrCast(self)), pwcInBuf, cwc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStemmerConfig_Value = Guid.initString("8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IStemmerConfig = &IID_IStemmerConfig_Value;
pub const IStemmerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocaleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemmerConfig,
                dwCodePageID: u32,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemmerConfig,
                dwCodePageID: u32,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocaleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemmerConfig,
                pdwCodePageID: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemmerConfig,
                pdwCodePageID: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemmerConfig,
                grfStemFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemmerConfig,
                grfStemFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemmerConfig,
                pgrfStemFlags: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemmerConfig,
                pgrfStemFlags: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadExternalStemmerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStemmerConfig,
                pStream: ?*IStream,
                dwExtDataType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStemmerConfig,
                pStream: ?*IStream,
                dwExtDataType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_SetLocaleInfo(self: *const T, dwCodePageID: u32, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).SetLocaleInfo(@as(*const IStemmerConfig, @ptrCast(self)), dwCodePageID, lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_GetLocaleInfo(self: *const T, pdwCodePageID: ?*u32, plcid: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).GetLocaleInfo(@as(*const IStemmerConfig, @ptrCast(self)), pdwCodePageID, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_SetControlInfo(self: *const T, grfStemFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).SetControlInfo(@as(*const IStemmerConfig, @ptrCast(self)), grfStemFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_GetControlInfo(self: *const T, pgrfStemFlags: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).GetControlInfo(@as(*const IStemmerConfig, @ptrCast(self)), pgrfStemFlags, pdwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_LoadExternalStemmerData(self: *const T, pStream: ?*IStream, dwExtDataType: u32) callconv(.Inline) HRESULT {
            return @as(*const IStemmerConfig.VTable, @ptrCast(self.vtable)).LoadExternalStemmerData(@as(*const IStemmerConfig, @ptrCast(self)), pStream, dwExtDataType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IITStopWordList = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IWordBreakerConfig_Value = Guid.initString("8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7");
pub const IID_IWordBreakerConfig = &IID_IWordBreakerConfig_Value;
pub const IWordBreakerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocaleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                dwCodePageID: u32,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                dwCodePageID: u32,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocaleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                pdwCodePageID: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                pdwCodePageID: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakWordType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                dwBreakWordType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                dwBreakWordType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakWordType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                pdwBreakWordType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                pdwBreakWordType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetControlInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                grfBreakFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                grfBreakFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                pgrfBreakFlags: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                pgrfBreakFlags: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadExternalBreakerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                pStream: ?*IStream,
                dwExtDataType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                pStream: ?*IStream,
                dwExtDataType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWordStemmer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                rclsid: ?*const Guid,
                pStemmer: ?*IStemmer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                rclsid: ?*const Guid,
                pStemmer: ?*IStemmer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWordStemmer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWordBreakerConfig,
                ppStemmer: ?*?*IStemmer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWordBreakerConfig,
                ppStemmer: ?*?*IStemmer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetLocaleInfo(self: *const T, dwCodePageID: u32, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetLocaleInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), dwCodePageID, lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetLocaleInfo(self: *const T, pdwCodePageID: ?*u32, plcid: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetLocaleInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), pdwCodePageID, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetBreakWordType(self: *const T, dwBreakWordType: u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetBreakWordType(@as(*const IWordBreakerConfig, @ptrCast(self)), dwBreakWordType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetBreakWordType(self: *const T, pdwBreakWordType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetBreakWordType(@as(*const IWordBreakerConfig, @ptrCast(self)), pdwBreakWordType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetControlInfo(self: *const T, grfBreakFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetControlInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), grfBreakFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetControlInfo(self: *const T, pgrfBreakFlags: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetControlInfo(@as(*const IWordBreakerConfig, @ptrCast(self)), pgrfBreakFlags, pdwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_LoadExternalBreakerData(self: *const T, pStream: ?*IStream, dwExtDataType: u32) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).LoadExternalBreakerData(@as(*const IWordBreakerConfig, @ptrCast(self)), pStream, dwExtDataType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetWordStemmer(self: *const T, rclsid: ?*const Guid, pStemmer: ?*IStemmer) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).SetWordStemmer(@as(*const IWordBreakerConfig, @ptrCast(self)), rclsid, pStemmer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetWordStemmer(self: *const T, ppStemmer: ?*?*IStemmer) callconv(.Inline) HRESULT {
            return @as(*const IWordBreakerConfig.VTable, @ptrCast(self.vtable)).GetWordStemmer(@as(*const IWordBreakerConfig, @ptrCast(self)), ppStemmer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITY = enum(i32) {
    LOW = 0,
    NORMAL = 1,
    HIGH = 2,
};
pub const PRIORITY_LOW = PRIORITY.LOW;
pub const PRIORITY_NORMAL = PRIORITY.NORMAL;
pub const PRIORITY_HIGH = PRIORITY.HIGH;

pub const ROWSTATUS = extern struct {
    lRowFirst: i32,
    cRows: i32,
    cProperties: i32,
    cRowsTotal: i32,
};

pub const COLUMNSTATUS = extern struct {
    cPropCount: i32,
    cPropsLoaded: i32,
};

pub const PFNCOLHEAPFREE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        param0: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

const IID_IITResultSet_Value = Guid.initString("3bb91d41-998b-11d0-a850-00aa006c7d01");
pub const IID_IITResultSet = &IID_IITResultSet_Value;
pub const IITResultSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                ColumnPriority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                ColumnPriority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumnHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                lpvHeap: ?*anyopaque,
                pfnColHeapFree: ?PFNCOLHEAPFREE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                lpvHeap: ?*anyopaque,
                pfnColHeapFree: ?PFNCOLHEAPFREE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                PropID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                PropID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                PropID: u32,
                dwDefaultData: u32,
                Priority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                PropID: u32,
                dwDefaultData: u32,
                Priority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                PropID: u32,
                lpszwDefault: ?[*:0]const u16,
                Priority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                PropID: u32,
                lpszwDefault: ?[*:0]const u16,
                Priority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                PropID: u32,
                lpvDefaultData: ?*anyopaque,
                cbData: u32,
                Priority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                PropID: u32,
                lpvDefaultData: ?*anyopaque,
                cbData: u32,
                Priority: PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lpvHdr: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lpvHdr: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Append: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lpvHdr: ?*anyopaque,
                lpvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lpvHdr: ?*anyopaque,
                lpvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                lpvData: ?*anyopaque,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                lpvData: ?*anyopaque,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                lpwStr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                lpwStr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                dwData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                dwData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lpvHdr: ?*anyopaque,
                lpvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lpvHdr: ?*anyopaque,
                lpvData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Copy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                pRSCopy: ?*IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                pRSCopy: ?*IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                pResSrc: ?*IITResultSet,
                lRowSrcFirst: i32,
                cSrcRows: i32,
                lRowFirstDest: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                pResSrc: ?*IITResultSet,
                lRowSrcFirst: i32,
                cSrcRows: i32,
                lRowFirstDest: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                Prop: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lRowIndex: i32,
                lColumnIndex: i32,
                Prop: ?*CProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                KeyPropID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                KeyPropID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                ColumnPriority: ?*PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                ColumnPriority: ?*PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lNumberOfRows: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lNumberOfRows: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lNumberOfColumns: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lNumberOfColumns: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                PropID: ?*u32,
                dwType: ?*u32,
                lpvDefaultValue: ?*?*anyopaque,
                cbSize: ?*u32,
                ColumnPriority: ?*PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                PropID: ?*u32,
                dwType: ?*u32,
                lpvDefaultValue: ?*?*anyopaque,
                cbSize: ?*u32,
                ColumnPriority: ?*PRIORITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumn1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                PropID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lColumnIndex: i32,
                PropID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnFromPropID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                PropID: u32,
                lColumnIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                PropID: u32,
                lColumnIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Free: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                fPause: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                fPause: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lRowFirst: i32,
                cRows: i32,
                lpRowStatus: ?*ROWSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lRowFirst: i32,
                cRows: i32,
                lpRowStatus: ?*ROWSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IITResultSet,
                lpColStatus: ?*COLUMNSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IITResultSet,
                lpColStatus: ?*COLUMNSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_SetColumnPriority(self: *const T, lColumnIndex: i32, ColumnPriority: PRIORITY) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).SetColumnPriority(@as(*const IITResultSet, @ptrCast(self)), lColumnIndex, ColumnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_SetColumnHeap(self: *const T, lColumnIndex: i32, lpvHeap: ?*anyopaque, pfnColHeapFree: ?PFNCOLHEAPFREE) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).SetColumnHeap(@as(*const IITResultSet, @ptrCast(self)), lColumnIndex, lpvHeap, pfnColHeapFree);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_SetKeyProp(self: *const T, PropID: u32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).SetKeyProp(@as(*const IITResultSet, @ptrCast(self)), PropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add(self: *const T, PropID: u32, dwDefaultData: u32, Priority: PRIORITY) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), PropID, dwDefaultData, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add1(self: *const T, PropID: u32, lpszwDefault: ?[*:0]const u16, Priority: PRIORITY) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), PropID, lpszwDefault, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add2(self: *const T, PropID: u32, lpvDefaultData: ?*anyopaque, cbData: u32, Priority: PRIORITY) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), PropID, lpvDefaultData, cbData, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add3(self: *const T, lpvHdr: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Add(@as(*const IITResultSet, @ptrCast(self)), lpvHdr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Append(self: *const T, lpvHdr: ?*anyopaque, lpvData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Append(@as(*const IITResultSet, @ptrCast(self)), lpvHdr, lpvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set(self: *const T, lRowIndex: i32, lColumnIndex: i32, lpvData: ?*anyopaque, cbData: u32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), lRowIndex, lColumnIndex, lpvData, cbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set1(self: *const T, lRowIndex: i32, lColumnIndex: i32, lpwStr: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), lRowIndex, lColumnIndex, lpwStr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set2(self: *const T, lRowIndex: i32, lColumnIndex: i32, dwData: usize) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), lRowIndex, lColumnIndex, dwData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set3(self: *const T, lRowIndex: i32, lpvHdr: ?*anyopaque, lpvData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Set(@as(*const IITResultSet, @ptrCast(self)), lRowIndex, lpvHdr, lpvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Copy(self: *const T, pRSCopy: ?*IITResultSet) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Copy(@as(*const IITResultSet, @ptrCast(self)), pRSCopy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_AppendRows(self: *const T, pResSrc: ?*IITResultSet, lRowSrcFirst: i32, cSrcRows: i32, lRowFirstDest: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).AppendRows(@as(*const IITResultSet, @ptrCast(self)), pResSrc, lRowSrcFirst, cSrcRows, lRowFirstDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Get(self: *const T, lRowIndex: i32, lColumnIndex: i32, Prop: ?*CProperty) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Get(@as(*const IITResultSet, @ptrCast(self)), lRowIndex, lColumnIndex, Prop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetKeyProp(self: *const T, KeyPropID: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetKeyProp(@as(*const IITResultSet, @ptrCast(self)), KeyPropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnPriority(self: *const T, lColumnIndex: i32, ColumnPriority: ?*PRIORITY) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnPriority(@as(*const IITResultSet, @ptrCast(self)), lColumnIndex, ColumnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetRowCount(self: *const T, lNumberOfRows: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetRowCount(@as(*const IITResultSet, @ptrCast(self)), lNumberOfRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnCount(self: *const T, lNumberOfColumns: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnCount(@as(*const IITResultSet, @ptrCast(self)), lNumberOfColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumn(self: *const T, lColumnIndex: i32, PropID: ?*u32, dwType: ?*u32, lpvDefaultValue: ?*?*anyopaque, cbSize: ?*u32, ColumnPriority: ?*PRIORITY) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const IITResultSet, @ptrCast(self)), lColumnIndex, PropID, dwType, lpvDefaultValue, cbSize, ColumnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumn1(self: *const T, lColumnIndex: i32, PropID: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const IITResultSet, @ptrCast(self)), lColumnIndex, PropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnFromPropID(self: *const T, PropID: u32, lColumnIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnFromPropID(@as(*const IITResultSet, @ptrCast(self)), PropID, lColumnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Clear(@as(*const IITResultSet, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_ClearRows(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).ClearRows(@as(*const IITResultSet, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Free(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Free(@as(*const IITResultSet, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_IsCompleted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).IsCompleted(@as(*const IITResultSet, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IITResultSet, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Pause(self: *const T, fPause: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).Pause(@as(*const IITResultSet, @ptrCast(self)), fPause);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetRowStatus(self: *const T, lRowFirst: i32, cRows: i32, lpRowStatus: ?*ROWSTATUS) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetRowStatus(@as(*const IITResultSet, @ptrCast(self)), lRowFirst, cRows, lpRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnStatus(self: *const T, lpColStatus: ?*COLUMNSTATUS) callconv(.Inline) HRESULT {
            return @as(*const IITResultSet.VTable, @ptrCast(self.vtable)).GetColumnStatus(@as(*const IITResultSet, @ptrCast(self)), lpColStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (15)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IPersistStreamInit = @import("../system/com.zig").IPersistStreamInit;
const IStemmer = @import("../system/search.zig").IStemmer;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const NMHDR = @import("../ui/controls.zig").NMHDR;
const POINT = @import("../foundation.zig").POINT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFNCOLHEAPFREE")) { _ = PFNCOLHEAPFREE; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
