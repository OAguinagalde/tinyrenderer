//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (287)
//--------------------------------------------------------------------------------
pub const IMAPI_SECTOR_SIZE = @as(u32, 2048);
pub const IMAPI2_DEFAULT_COMMAND_TIMEOUT = @as(u32, 10);
pub const DISPID_DDISCMASTER2EVENTS_DEVICEADDED = @as(u32, 256);
pub const DISPID_DDISCMASTER2EVENTS_DEVICEREMOVED = @as(u32, 257);
pub const DISPID_IDISCRECORDER2_EJECTMEDIA = @as(u32, 256);
pub const DISPID_IDISCRECORDER2_CLOSETRAY = @as(u32, 257);
pub const DISPID_IDISCRECORDER2_ACQUIREEXCLUSIVEACCESS = @as(u32, 258);
pub const DISPID_IDISCRECORDER2_RELEASEEXCLUSIVEACCESS = @as(u32, 259);
pub const DISPID_IDISCRECORDER2_DISABLEMCN = @as(u32, 260);
pub const DISPID_IDISCRECORDER2_ENABLEMCN = @as(u32, 261);
pub const DISPID_IDISCRECORDER2_INITIALIZEDISCRECORDER = @as(u32, 262);
pub const DISPID_IDISCRECORDER2_ACTIVEDISCRECORDER = @as(u32, 0);
pub const DISPID_IDISCRECORDER2_VENDORID = @as(u32, 513);
pub const DISPID_IDISCRECORDER2_PRODUCTID = @as(u32, 514);
pub const DISPID_IDISCRECORDER2_PRODUCTREVISION = @as(u32, 515);
pub const DISPID_IDISCRECORDER2_VOLUMENAME = @as(u32, 516);
pub const DISPID_IDISCRECORDER2_VOLUMEPATHNAMES = @as(u32, 517);
pub const DISPID_IDISCRECORDER2_DEVICECANLOADMEDIA = @as(u32, 518);
pub const DISPID_IDISCRECORDER2_LEGACYDEVICENUMBER = @as(u32, 519);
pub const DISPID_IDISCRECORDER2_SUPPORTEDFEATUREPAGES = @as(u32, 520);
pub const DISPID_IDISCRECORDER2_CURRENTFEATUREPAGES = @as(u32, 521);
pub const DISPID_IDISCRECORDER2_SUPPORTEDPROFILES = @as(u32, 522);
pub const DISPID_IDISCRECORDER2_CURRENTPROFILES = @as(u32, 523);
pub const DISPID_IDISCRECORDER2_SUPPORTEDMODEPAGES = @as(u32, 524);
pub const DISPID_IDISCRECORDER2_EXCLUSIVEACCESSOWNER = @as(u32, 525);
pub const DISPID_IWRITEENGINE2_WRITESECTION = @as(u32, 512);
pub const DISPID_IWRITEENGINE2_CANCELWRITE = @as(u32, 513);
pub const DISPID_IWRITEENGINE2_DISCRECORDER = @as(u32, 256);
pub const DISPID_IWRITEENGINE2_USESTREAMINGWRITE12 = @as(u32, 257);
pub const DISPID_IWRITEENGINE2_STARTINGSECTORSPERSECOND = @as(u32, 258);
pub const DISPID_IWRITEENGINE2_ENDINGSECTORSPERSECOND = @as(u32, 259);
pub const DISPID_IWRITEENGINE2_BYTESPERSECTOR = @as(u32, 260);
pub const DISPID_IWRITEENGINE2_WRITEINPROGRESS = @as(u32, 261);
pub const DISPID_IWRITEENGINE2EVENTARGS_STARTLBA = @as(u32, 256);
pub const DISPID_IWRITEENGINE2EVENTARGS_SECTORCOUNT = @as(u32, 257);
pub const DISPID_IWRITEENGINE2EVENTARGS_LASTREADLBA = @as(u32, 258);
pub const DISPID_IWRITEENGINE2EVENTARGS_LASTWRITTENLBA = @as(u32, 259);
pub const DISPID_IWRITEENGINE2EVENTARGS_TOTALDEVICEBUFFER = @as(u32, 260);
pub const DISPID_IWRITEENGINE2EVENTARGS_USEDDEVICEBUFFER = @as(u32, 261);
pub const DISPID_IWRITEENGINE2EVENTARGS_TOTALSYSTEMBUFFER = @as(u32, 262);
pub const DISPID_IWRITEENGINE2EVENTARGS_USEDSYSTEMBUFFER = @as(u32, 263);
pub const DISPID_IWRITEENGINE2EVENTARGS_FREESYSTEMBUFFER = @as(u32, 264);
pub const DISPID_DWRITEENGINE2EVENTS_UPDATE = @as(u32, 256);
pub const DISPID_IDISCFORMAT2_RECORDERSUPPORTED = @as(u32, 2048);
pub const DISPID_IDISCFORMAT2_MEDIASUPPORTED = @as(u32, 2049);
pub const DISPID_IDISCFORMAT2_MEDIAPHYSICALLYBLANK = @as(u32, 1792);
pub const DISPID_IDISCFORMAT2_MEDIAHEURISTICALLYBLANK = @as(u32, 1793);
pub const DISPID_IDISCFORMAT2_SUPPORTEDMEDIATYPES = @as(u32, 1794);
pub const DISPID_IDISCFORMAT2ERASE_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2ERASE_FULLERASE = @as(u32, 257);
pub const DISPID_IDISCFORMAT2ERASE_MEDIATYPE = @as(u32, 258);
pub const DISPID_IDISCFORMAT2ERASE_CLIENTNAME = @as(u32, 259);
pub const DISPID_IDISCFORMAT2ERASE_ERASEMEDIA = @as(u32, 513);
pub const DISPID_IDISCFORMAT2ERASEEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATA_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2DATA_BUFFERUNDERRUNFREEDISABLED = @as(u32, 257);
pub const DISPID_IDISCFORMAT2DATA_POSTGAPALREADYINIMAGE = @as(u32, 260);
pub const DISPID_IDISCFORMAT2DATA_CURRENTMEDIASTATUS = @as(u32, 262);
pub const DISPID_IDISCFORMAT2DATA_WRITEPROTECTSTATUS = @as(u32, 263);
pub const DISPID_IDISCFORMAT2DATA_TOTALSECTORS = @as(u32, 264);
pub const DISPID_IDISCFORMAT2DATA_FREESECTORS = @as(u32, 265);
pub const DISPID_IDISCFORMAT2DATA_NEXTWRITABLEADDRESS = @as(u32, 266);
pub const DISPID_IDISCFORMAT2DATA_STARTSECTOROFPREVIOUSSESSION = @as(u32, 267);
pub const DISPID_IDISCFORMAT2DATA_LASTSECTOROFPREVIOUSSESSION = @as(u32, 268);
pub const DISPID_IDISCFORMAT2DATA_FORCEMEDIATOBECLOSED = @as(u32, 269);
pub const DISPID_IDISCFORMAT2DATA_DISABLEDVDCOMPATIBILITYMODE = @as(u32, 270);
pub const DISPID_IDISCFORMAT2DATA_CURRENTMEDIATYPE = @as(u32, 271);
pub const DISPID_IDISCFORMAT2DATA_CLIENTNAME = @as(u32, 272);
pub const DISPID_IDISCFORMAT2DATA_REQUESTEDWRITESPEED = @as(u32, 273);
pub const DISPID_IDISCFORMAT2DATA_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 274);
pub const DISPID_IDISCFORMAT2DATA_CURRENTWRITESPEED = @as(u32, 275);
pub const DISPID_IDISCFORMAT2DATA_CURRENTROTATIONTYPEISPURECAV = @as(u32, 276);
pub const DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDS = @as(u32, 277);
pub const DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 278);
pub const DISPID_IDISCFORMAT2DATA_FORCEOVERWRITE = @as(u32, 279);
pub const DISPID_IDISCFORMAT2DATA_MUTLISESSIONINTERFACES = @as(u32, 280);
pub const DISPID_IDISCFORMAT2DATA_WRITE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATA_CANCELWRITE = @as(u32, 513);
pub const DISPID_IDISCFORMAT2DATA_SETWRITESPEED = @as(u32, 514);
pub const DISPID_DDISCFORMAT2DATAEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ELAPSEDTIME = @as(u32, 768);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 769);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 770);
pub const DISPID_IDISCFORMAT2DATAEVENTARGS_CURRENTACTION = @as(u32, 771);
pub const DISPID_IDISCFORMAT2TAO_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2TAO_BUFFERUNDERRUNFREEDISABLED = @as(u32, 258);
pub const DISPID_IDISCFORMAT2TAO_NUMBEROFEXISTINGTRACKS = @as(u32, 259);
pub const DISPID_IDISCFORMAT2TAO_TOTALSECTORSONMEDIA = @as(u32, 260);
pub const DISPID_IDISCFORMAT2TAO_FREESECTORSONMEDIA = @as(u32, 261);
pub const DISPID_IDISCFORMAT2TAO_USEDSECTORSONMEDIA = @as(u32, 262);
pub const DISPID_IDISCFORMAT2TAO_DONOTFINALIZEMEDIA = @as(u32, 263);
pub const DISPID_IDISCFORMAT2TAO_EXPECTEDTABLEOFCONTENTS = @as(u32, 266);
pub const DISPID_IDISCFORMAT2TAO_CURRENTMEDIATYPE = @as(u32, 267);
pub const DISPID_IDISCFORMAT2TAO_CLIENTNAME = @as(u32, 270);
pub const DISPID_IDISCFORMAT2TAO_REQUESTEDWRITESPEED = @as(u32, 271);
pub const DISPID_IDISCFORMAT2TAO_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 272);
pub const DISPID_IDISCFORMAT2TAO_CURRENTWRITESPEED = @as(u32, 273);
pub const DISPID_IDISCFORMAT2TAO_CURRENTROTATIONTYPEISPURECAV = @as(u32, 274);
pub const DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDS = @as(u32, 275);
pub const DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 276);
pub const DISPID_IDISCFORMAT2TAO_PREPAREMEDIA = @as(u32, 512);
pub const DISPID_IDISCFORMAT2TAO_ADDAUDIOTRACK = @as(u32, 513);
pub const DISPID_IDISCFORMAT2TAO_CANCELADDTRACK = @as(u32, 514);
pub const DISPID_IDISCFORMAT2TAO_FINISHMEDIA = @as(u32, 515);
pub const DISPID_IDISCFORMAT2TAO_SETWRITESPEED = @as(u32, 516);
pub const DISPID_DDISCFORMAT2TAOEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTTRACKNUMBER = @as(u32, 768);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTACTION = @as(u32, 769);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ELAPSEDTIME = @as(u32, 770);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 771);
pub const DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 772);
pub const DISPID_IDISCFORMAT2RAWCD_RECORDER = @as(u32, 256);
pub const DISPID_IDISCFORMAT2RAWCD_BUFFERUNDERRUNFREEDISABLED = @as(u32, 258);
pub const DISPID_IDISCFORMAT2RAWCD_STARTOFNEXTSESSION = @as(u32, 259);
pub const DISPID_IDISCFORMAT2RAWCD_LASTPOSSIBLESTARTOFLEADOUT = @as(u32, 260);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTMEDIATYPE = @as(u32, 261);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDDATASECTORTYPES = @as(u32, 264);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDDATASECTORTYPE = @as(u32, 265);
pub const DISPID_IDISCFORMAT2RAWCD_CLIENTNAME = @as(u32, 266);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDWRITESPEED = @as(u32, 267);
pub const DISPID_IDISCFORMAT2RAWCD_REQUESTEDROTATIONTYPEISPURECAV = @as(u32, 268);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTWRITESPEED = @as(u32, 269);
pub const DISPID_IDISCFORMAT2RAWCD_CURRENTROTATIONTYPEISPURECAV = @as(u32, 270);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDS = @as(u32, 271);
pub const DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDDESCRIPTORS = @as(u32, 272);
pub const DISPID_IDISCFORMAT2RAWCD_PREPAREMEDIA = @as(u32, 512);
pub const DISPID_IDISCFORMAT2RAWCD_WRITEMEDIA = @as(u32, 513);
pub const DISPID_IDISCFORMAT2RAWCD_WRITEMEDIAWITHVALIDATION = @as(u32, 514);
pub const DISPID_IDISCFORMAT2RAWCD_CANCELWRITE = @as(u32, 515);
pub const DISPID_IDISCFORMAT2RAWCD_RELEASEMEDIA = @as(u32, 516);
pub const DISPID_IDISCFORMAT2RAWCD_SETWRITESPEED = @as(u32, 517);
pub const DISPID_DDISCFORMAT2RAWCDEVENTS_UPDATE = @as(u32, 512);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTTRACKNUMBER = @as(u32, 768);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTACTION = @as(u32, 769);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ELAPSEDTIME = @as(u32, 768);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDREMAININGTIME = @as(u32, 769);
pub const DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDTOTALTIME = @as(u32, 770);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_CD = @as(u32, 75);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_DVD = @as(u32, 680);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_BD = @as(u32, 2195);
pub const IMAPI_SECTORS_PER_SECOND_AT_1X_HD_DVD = @as(u32, 4568);
pub const DISPID_IMULTISESSION_SUPPORTEDONCURRENTMEDIA = @as(u32, 256);
pub const DISPID_IMULTISESSION_INUSE = @as(u32, 257);
pub const DISPID_IMULTISESSION_IMPORTRECORDER = @as(u32, 258);
pub const DISPID_IMULTISESSION_FIRSTDATASESSION = @as(u32, 512);
pub const DISPID_IMULTISESSION_STARTSECTOROFPREVIOUSSESSION = @as(u32, 513);
pub const DISPID_IMULTISESSION_LASTSECTOROFPREVIOUSSESSION = @as(u32, 514);
pub const DISPID_IMULTISESSION_NEXTWRITABLEADDRESS = @as(u32, 515);
pub const DISPID_IMULTISESSION_FREESECTORS = @as(u32, 516);
pub const DISPID_IMULTISESSION_WRITEUNITSIZE = @as(u32, 517);
pub const DISPID_IMULTISESSION_LASTWRITTENADDRESS = @as(u32, 518);
pub const DISPID_IMULTISESSION_SECTORSONMEDIA = @as(u32, 519);
pub const DISPID_IRAWCDIMAGECREATOR_CREATERESULTIMAGE = @as(u32, 512);
pub const DISPID_IRAWCDIMAGECREATOR_ADDTRACK = @as(u32, 513);
pub const DISPID_IRAWCDIMAGECREATOR_ADDSPECIALPREGAP = @as(u32, 514);
pub const DISPID_IRAWCDIMAGECREATOR_ADDSUBCODERWGENERATOR = @as(u32, 515);
pub const DISPID_IRAWCDIMAGECREATOR_RESULTINGIMAGETYPE = @as(u32, 256);
pub const DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUT = @as(u32, 257);
pub const DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUTLIMIT = @as(u32, 258);
pub const DISPID_IRAWCDIMAGECREATOR_DISABLEGAPLESSAUDIO = @as(u32, 259);
pub const DISPID_IRAWCDIMAGECREATOR_MEDIACATALOGNUMBER = @as(u32, 260);
pub const DISPID_IRAWCDIMAGECREATOR_STARTINGTRACKNUMBER = @as(u32, 261);
pub const DISPID_IRAWCDIMAGECREATOR_TRACKINFO = @as(u32, 262);
pub const DISPID_IRAWCDIMAGECREATOR_NUMBEROFEXISTINGTRACKS = @as(u32, 263);
pub const DISPID_IRAWCDIMAGECREATOR_USEDSECTORSONDISC = @as(u32, 264);
pub const DISPID_IRAWCDIMAGECREATOR_EXPECTEDTABLEOFCONTENTS = @as(u32, 265);
pub const DISPID_IRAWCDTRACKINFO_STARTINGLBA = @as(u32, 256);
pub const DISPID_IRAWCDTRACKINFO_SECTORCOUNT = @as(u32, 257);
pub const DISPID_IRAWCDTRACKINFO_TRACKNUMBER = @as(u32, 258);
pub const DISPID_IRAWCDTRACKINFO_SECTORTYPE = @as(u32, 259);
pub const DISPID_IRAWCDTRACKINFO_ISRC = @as(u32, 260);
pub const DISPID_IRAWCDTRACKINFO_DIGITALAUDIOCOPYSETTING = @as(u32, 261);
pub const DISPID_IRAWCDTRACKINFO_AUDIOHASPREEMPHASIS = @as(u32, 262);
pub const DISPID_IBLOCKRANGE_STARTLBA = @as(u32, 256);
pub const DISPID_IBLOCKRANGE_ENDLBA = @as(u32, 257);
pub const DISPID_IBLOCKRANGELIST_BLOCKRANGES = @as(u32, 256);
pub const IMAPILib2_MajorVersion = @as(u32, 1);
pub const IMAPILib2_MinorVersion = @as(u32, 0);
pub const IMAPI2FS_BOOT_ENTRY_COUNT_MAX = @as(u32, 32);
pub const DISPID_DFILESYSTEMIMAGEEVENTS_UPDATE = @as(u32, 256);
pub const DISPID_DFILESYSTEMIMAGEIMPORTEVENTS_UPDATEIMPORT = @as(u32, 257);
pub const IMAPI2FS_MajorVersion = @as(u32, 1);
pub const IMAPI2FS_MinorVersion = @as(u32, 0);
pub const IMAPI2FS_FullVersion_STR = "1.0";
pub const IMAPI2FS_FullVersion_WSTR = "1.0";
pub const MP_MSGCLASS_SYSTEM = @as(u32, 1);
pub const MP_MSGCLASS_REPLICATION = @as(u32, 2);
pub const MP_MSGCLASS_DELIVERY_REPORT = @as(u32, 3);
pub const MP_MSGCLASS_NONDELIVERY_REPORT = @as(u32, 4);
pub const MP_STATUS_SUCCESS = @as(u32, 0);
pub const MP_STATUS_RETRY = @as(u32, 1);
pub const MP_STATUS_ABORT_DELIVERY = @as(u32, 2);
pub const MP_STATUS_BAD_MAIL = @as(u32, 3);
pub const MP_STATUS_SUBMITTED = @as(u32, 4);
pub const MP_STATUS_CATEGORIZED = @as(u32, 5);
pub const MP_STATUS_ABANDON_DELIVERY = @as(u32, 6);
pub const RP_RECIP_FLAGS_RESERVED = @as(u32, 15);
pub const RP_DSN_NOTIFY_SUCCESS = @as(u32, 16777216);
pub const RP_DSN_NOTIFY_FAILURE = @as(u32, 33554432);
pub const RP_DSN_NOTIFY_DELAY = @as(u32, 67108864);
pub const RP_DSN_NOTIFY_NEVER = @as(u32, 134217728);
pub const RP_DSN_NOTIFY_MASK = @as(u32, 251658240);
pub const RP_HANDLED = @as(u32, 16);
pub const RP_GENERAL_FAILURE = @as(u32, 32);
pub const RP_DSN_HANDLED = @as(u32, 64);
pub const RP_DELIVERED = @as(u32, 272);
pub const RP_DSN_SENT_NDR = @as(u32, 1104);
pub const RP_FAILED = @as(u32, 2096);
pub const RP_UNRESOLVED = @as(u32, 4144);
pub const RP_ENPANDED = @as(u32, 8208);
pub const RP_EXPANDED = @as(u32, 8208);
pub const RP_DSN_SENT_DELAYED = @as(u32, 16384);
pub const RP_DSN_SENT_EXPANDED = @as(u32, 32832);
pub const RP_DSN_SENT_RELAYED = @as(u32, 65600);
pub const RP_DSN_SENT_DELIVERED = @as(u32, 131136);
pub const RP_REMOTE_MTA_NO_DSN = @as(u32, 524288);
pub const RP_ERROR_CONTEXT_STORE = @as(u32, 1048576);
pub const RP_ERROR_CONTEXT_CAT = @as(u32, 2097152);
pub const RP_ERROR_CONTEXT_MTA = @as(u32, 4194304);
pub const RP_VOLATILE_FLAGS_MASK = @as(u32, 4026531840);
pub const RP_DSN_NOTIFY_INVALID = @as(u32, 0);
pub const MPV_INBOUND_CUTOFF_EXCEEDED = @as(u32, 1);
pub const MPV_WRITE_CONTENT = @as(u32, 2);
pub const NMP_PROCESS_POST = @as(u32, 1);
pub const NMP_PROCESS_CONTROL = @as(u32, 2);
pub const NMP_PROCESS_MODERATOR = @as(u32, 4);
pub const GUID_SMTP_SOURCE_TYPE = Guid.initString("fb65c4dc-e468-11d1-aa67-00c04fa345f6");
pub const GUID_SMTPSVC_SOURCE = Guid.initString("1b3c0666-e470-11d1-aa67-00c04fa345f6");
pub const CATID_SMTP_ON_INBOUND_COMMAND = Guid.initString("f6628c8d-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SERVER_RESPONSE = Guid.initString("f6628c8e-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SESSION_START = Guid.initString("f6628c8f-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_MESSAGE_START = Guid.initString("f6628c90-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_PER_RECIPIENT = Guid.initString("f6628c91-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_BEFORE_DATA = Guid.initString("f6628c92-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_ON_SESSION_END = Guid.initString("f6628c93-0d5e-11d2-aa68-00c04fa35b82");
pub const CATID_SMTP_STORE_DRIVER = Guid.initString("59175850-e533-11d1-aa67-00c04fa345f6");
pub const CATID_SMTP_TRANSPORT_SUBMISSION = Guid.initString("ff3caa23-00b9-11d2-9dfb-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_PRECATEGORIZE = Guid.initString("a3acfb0d-83ff-11d2-9e14-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_CATEGORIZE = Guid.initString("960252a3-0a3a-11d2-9e00-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_POSTCATEGORIZE = Guid.initString("76719654-05a6-11d2-9dfd-00c04fa322ba");
pub const CATID_SMTP_TRANSPORT_ROUTER = Guid.initString("283430c9-1850-11d2-9e03-00c04fa322ba");
pub const CATID_SMTP_MSGTRACKLOG = Guid.initString("c6df52aa-7db0-11d2-94f4-00c04f79f1d6");
pub const CATID_SMTP_DNSRESOLVERRECORDSINK = Guid.initString("bd0b4366-8e03-11d2-94f6-00c04f79f1d6");
pub const CATID_SMTP_MAXMSGSIZE = Guid.initString("ebf159de-a67e-11d2-94f7-00c04f79f1d6");
pub const CATID_SMTP_LOG = Guid.initString("93d0a538-2c1e-4b68-a7c9-d73a8aa6ee97");
pub const CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS = Guid.initString("84ff368a-fab3-43d7-bcdf-692c5b46e6b1");
pub const CLSID_SmtpCat = Guid.initString("b23c35b7-9219-11d2-9e17-00c04fa322ba");
pub const CATID_SMTP_DSN = Guid.initString("22b55731-f5f8-4d23-bd8f-87b52371a73a");
pub const SZ_PROGID_SMTPCAT = "Smtp.Cat";
pub const IMAPI_S_PROPERTIESIGNORED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const IMAPI_S_BUFFER_TO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const IMAPI_E_NOTOPENED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const IMAPI_E_NOTINITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const IMAPI_E_USERABORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const IMAPI_E_GENERIC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const IMAPI_E_MEDIUM_NOTPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const IMAPI_E_MEDIUM_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const IMAPI_E_DEVICE_NOPROPERTIES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const IMAPI_E_DEVICE_NOTACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const IMAPI_E_DEVICE_NOTPRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const IMAPI_E_DEVICE_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const IMAPI_E_INITIALIZE_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const IMAPI_E_INITIALIZE_ENDWRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const IMAPI_E_FILESYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const IMAPI_E_FILEACCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const IMAPI_E_DISCINFO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const IMAPI_E_TRACKNOTOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const IMAPI_E_TRACKOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const IMAPI_E_DISCFULL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const IMAPI_E_BADJOLIETNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const IMAPI_E_INVALIDIMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220962));
pub const IMAPI_E_NOACTIVEFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220961));
pub const IMAPI_E_NOACTIVERECORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220960));
pub const IMAPI_E_WRONGFORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220959));
pub const IMAPI_E_ALREADYOPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const IMAPI_E_WRONGDISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const IMAPI_E_FILEEXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220956));
pub const IMAPI_E_STASHINUSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220955));
pub const IMAPI_E_DEVICE_STILL_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220954));
pub const IMAPI_E_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220953));
pub const IMAPI_E_COMPRESSEDSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220952));
pub const IMAPI_E_ENCRYPTEDSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220951));
pub const IMAPI_E_NOTENOUGHDISKFORSTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220950));
pub const IMAPI_E_REMOVABLESTASH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220949));
pub const IMAPI_E_CANNOT_WRITE_TO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220948));
pub const IMAPI_E_TRACK_NOT_BIG_ENOUGH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220947));
pub const IMAPI_E_BOOTIMAGE_AND_NONBLANK_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147220946));

//--------------------------------------------------------------------------------
// Section: Types (130)
//--------------------------------------------------------------------------------
pub const DISC_RECORDER_STATE_FLAGS = enum(u32) {
    BURNING = 2,
    DOING_NOTHING = 0,
    OPENED = 1,
};
pub const RECORDER_BURNING = DISC_RECORDER_STATE_FLAGS.BURNING;
pub const RECORDER_DOING_NOTHING = DISC_RECORDER_STATE_FLAGS.DOING_NOTHING;
pub const RECORDER_OPENED = DISC_RECORDER_STATE_FLAGS.OPENED;

const CLSID_MsftDiscMaster2_Value = Guid.initString("2735412e-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscMaster2 = &CLSID_MsftDiscMaster2_Value;

const CLSID_MsftDiscRecorder2_Value = Guid.initString("2735412d-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscRecorder2 = &CLSID_MsftDiscRecorder2_Value;

const CLSID_MsftWriteEngine2_Value = Guid.initString("2735412c-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftWriteEngine2 = &CLSID_MsftWriteEngine2_Value;

const CLSID_MsftDiscFormat2Erase_Value = Guid.initString("2735412b-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2Erase = &CLSID_MsftDiscFormat2Erase_Value;

const CLSID_MsftDiscFormat2Data_Value = Guid.initString("2735412a-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2Data = &CLSID_MsftDiscFormat2Data_Value;

const CLSID_MsftDiscFormat2TrackAtOnce_Value = Guid.initString("27354129-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2TrackAtOnce = &CLSID_MsftDiscFormat2TrackAtOnce_Value;

const CLSID_MsftDiscFormat2RawCD_Value = Guid.initString("27354128-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftDiscFormat2RawCD = &CLSID_MsftDiscFormat2RawCD_Value;

const CLSID_MsftStreamZero_Value = Guid.initString("27354127-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamZero = &CLSID_MsftStreamZero_Value;

const CLSID_MsftStreamPrng001_Value = Guid.initString("27354126-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamPrng001 = &CLSID_MsftStreamPrng001_Value;

const CLSID_MsftStreamConcatenate_Value = Guid.initString("27354125-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamConcatenate = &CLSID_MsftStreamConcatenate_Value;

const CLSID_MsftStreamInterleave_Value = Guid.initString("27354124-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftStreamInterleave = &CLSID_MsftStreamInterleave_Value;

const CLSID_MsftWriteSpeedDescriptor_Value = Guid.initString("27354123-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftWriteSpeedDescriptor = &CLSID_MsftWriteSpeedDescriptor_Value;

const CLSID_MsftMultisessionSequential_Value = Guid.initString("27354122-7f64-5b0f-8f00-5d77afbe261e");
pub const CLSID_MsftMultisessionSequential = &CLSID_MsftMultisessionSequential_Value;

const CLSID_MsftMultisessionRandomWrite_Value = Guid.initString("b507ca24-2204-11dd-966a-001aa01bbc58");
pub const CLSID_MsftMultisessionRandomWrite = &CLSID_MsftMultisessionRandomWrite_Value;

const CLSID_MsftRawCDImageCreator_Value = Guid.initString("25983561-9d65-49ce-b335-40630d901227");
pub const CLSID_MsftRawCDImageCreator = &CLSID_MsftRawCDImageCreator_Value;

pub const IMAPI_MEDIA_PHYSICAL_TYPE = enum(i32) {
    UNKNOWN = 0,
    CDROM = 1,
    CDR = 2,
    CDRW = 3,
    DVDROM = 4,
    DVDRAM = 5,
    DVDPLUSR = 6,
    DVDPLUSRW = 7,
    DVDPLUSR_DUALLAYER = 8,
    DVDDASHR = 9,
    DVDDASHRW = 10,
    DVDDASHR_DUALLAYER = 11,
    DISK = 12,
    DVDPLUSRW_DUALLAYER = 13,
    HDDVDROM = 14,
    HDDVDR = 15,
    HDDVDRAM = 16,
    BDROM = 17,
    BDR = 18,
    BDRE = 19,
    // MAX = 19, this enum value conflicts with BDRE
};
pub const IMAPI_MEDIA_TYPE_UNKNOWN = IMAPI_MEDIA_PHYSICAL_TYPE.UNKNOWN;
pub const IMAPI_MEDIA_TYPE_CDROM = IMAPI_MEDIA_PHYSICAL_TYPE.CDROM;
pub const IMAPI_MEDIA_TYPE_CDR = IMAPI_MEDIA_PHYSICAL_TYPE.CDR;
pub const IMAPI_MEDIA_TYPE_CDRW = IMAPI_MEDIA_PHYSICAL_TYPE.CDRW;
pub const IMAPI_MEDIA_TYPE_DVDROM = IMAPI_MEDIA_PHYSICAL_TYPE.DVDROM;
pub const IMAPI_MEDIA_TYPE_DVDRAM = IMAPI_MEDIA_PHYSICAL_TYPE.DVDRAM;
pub const IMAPI_MEDIA_TYPE_DVDPLUSR = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSR;
pub const IMAPI_MEDIA_TYPE_DVDPLUSRW = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSRW;
pub const IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSR_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_DVDDASHR = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHR;
pub const IMAPI_MEDIA_TYPE_DVDDASHRW = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHRW;
pub const IMAPI_MEDIA_TYPE_DVDDASHR_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDDASHR_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_DISK = IMAPI_MEDIA_PHYSICAL_TYPE.DISK;
pub const IMAPI_MEDIA_TYPE_DVDPLUSRW_DUALLAYER = IMAPI_MEDIA_PHYSICAL_TYPE.DVDPLUSRW_DUALLAYER;
pub const IMAPI_MEDIA_TYPE_HDDVDROM = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDROM;
pub const IMAPI_MEDIA_TYPE_HDDVDR = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDR;
pub const IMAPI_MEDIA_TYPE_HDDVDRAM = IMAPI_MEDIA_PHYSICAL_TYPE.HDDVDRAM;
pub const IMAPI_MEDIA_TYPE_BDROM = IMAPI_MEDIA_PHYSICAL_TYPE.BDROM;
pub const IMAPI_MEDIA_TYPE_BDR = IMAPI_MEDIA_PHYSICAL_TYPE.BDR;
pub const IMAPI_MEDIA_TYPE_BDRE = IMAPI_MEDIA_PHYSICAL_TYPE.BDRE;
pub const IMAPI_MEDIA_TYPE_MAX = IMAPI_MEDIA_PHYSICAL_TYPE.BDRE;

pub const IMAPI_MEDIA_WRITE_PROTECT_STATE = enum(i32) {
    UNTIL_POWERDOWN = 1,
    BY_CARTRIDGE = 2,
    BY_MEDIA_SPECIFIC_REASON = 4,
    BY_SOFTWARE_WRITE_PROTECT = 8,
    BY_DISC_CONTROL_BLOCK = 16,
    READ_ONLY_MEDIA = 16384,
};
pub const IMAPI_WRITEPROTECTED_UNTIL_POWERDOWN = IMAPI_MEDIA_WRITE_PROTECT_STATE.UNTIL_POWERDOWN;
pub const IMAPI_WRITEPROTECTED_BY_CARTRIDGE = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_CARTRIDGE;
pub const IMAPI_WRITEPROTECTED_BY_MEDIA_SPECIFIC_REASON = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_MEDIA_SPECIFIC_REASON;
pub const IMAPI_WRITEPROTECTED_BY_SOFTWARE_WRITE_PROTECT = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_SOFTWARE_WRITE_PROTECT;
pub const IMAPI_WRITEPROTECTED_BY_DISC_CONTROL_BLOCK = IMAPI_MEDIA_WRITE_PROTECT_STATE.BY_DISC_CONTROL_BLOCK;
pub const IMAPI_WRITEPROTECTED_READ_ONLY_MEDIA = IMAPI_MEDIA_WRITE_PROTECT_STATE.READ_ONLY_MEDIA;

pub const IMAPI_READ_TRACK_ADDRESS_TYPE = enum(i32) {
    LBA = 0,
    TRACK = 1,
    SESSION = 2,
};
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_LBA = IMAPI_READ_TRACK_ADDRESS_TYPE.LBA;
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_TRACK = IMAPI_READ_TRACK_ADDRESS_TYPE.TRACK;
pub const IMAPI_READ_TRACK_ADDRESS_TYPE_SESSION = IMAPI_READ_TRACK_ADDRESS_TYPE.SESSION;

pub const IMAPI_MODE_PAGE_REQUEST_TYPE = enum(i32) {
    CURRENT_VALUES = 0,
    CHANGEABLE_VALUES = 1,
    DEFAULT_VALUES = 2,
    SAVED_VALUES = 3,
};
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_CURRENT_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.CURRENT_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_CHANGEABLE_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.CHANGEABLE_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_DEFAULT_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.DEFAULT_VALUES;
pub const IMAPI_MODE_PAGE_REQUEST_TYPE_SAVED_VALUES = IMAPI_MODE_PAGE_REQUEST_TYPE.SAVED_VALUES;

pub const IMAPI_MODE_PAGE_TYPE = enum(i32) {
    READ_WRITE_ERROR_RECOVERY = 1,
    MRW = 3,
    WRITE_PARAMETERS = 5,
    CACHING = 8,
    INFORMATIONAL_EXCEPTIONS = 28,
    TIMEOUT_AND_PROTECT = 29,
    POWER_CONDITION = 26,
    LEGACY_CAPABILITIES = 42,
};
pub const IMAPI_MODE_PAGE_TYPE_READ_WRITE_ERROR_RECOVERY = IMAPI_MODE_PAGE_TYPE.READ_WRITE_ERROR_RECOVERY;
pub const IMAPI_MODE_PAGE_TYPE_MRW = IMAPI_MODE_PAGE_TYPE.MRW;
pub const IMAPI_MODE_PAGE_TYPE_WRITE_PARAMETERS = IMAPI_MODE_PAGE_TYPE.WRITE_PARAMETERS;
pub const IMAPI_MODE_PAGE_TYPE_CACHING = IMAPI_MODE_PAGE_TYPE.CACHING;
pub const IMAPI_MODE_PAGE_TYPE_INFORMATIONAL_EXCEPTIONS = IMAPI_MODE_PAGE_TYPE.INFORMATIONAL_EXCEPTIONS;
pub const IMAPI_MODE_PAGE_TYPE_TIMEOUT_AND_PROTECT = IMAPI_MODE_PAGE_TYPE.TIMEOUT_AND_PROTECT;
pub const IMAPI_MODE_PAGE_TYPE_POWER_CONDITION = IMAPI_MODE_PAGE_TYPE.POWER_CONDITION;
pub const IMAPI_MODE_PAGE_TYPE_LEGACY_CAPABILITIES = IMAPI_MODE_PAGE_TYPE.LEGACY_CAPABILITIES;

pub const IMAPI_FEATURE_PAGE_TYPE = enum(i32) {
    PROFILE_LIST = 0,
    CORE = 1,
    MORPHING = 2,
    REMOVABLE_MEDIUM = 3,
    WRITE_PROTECT = 4,
    RANDOMLY_READABLE = 16,
    CD_MULTIREAD = 29,
    CD_READ = 30,
    DVD_READ = 31,
    RANDOMLY_WRITABLE = 32,
    INCREMENTAL_STREAMING_WRITABLE = 33,
    SECTOR_ERASABLE = 34,
    FORMATTABLE = 35,
    HARDWARE_DEFECT_MANAGEMENT = 36,
    WRITE_ONCE = 37,
    RESTRICTED_OVERWRITE = 38,
    CDRW_CAV_WRITE = 39,
    MRW = 40,
    ENHANCED_DEFECT_REPORTING = 41,
    DVD_PLUS_RW = 42,
    DVD_PLUS_R = 43,
    RIGID_RESTRICTED_OVERWRITE = 44,
    CD_TRACK_AT_ONCE = 45,
    CD_MASTERING = 46,
    DVD_DASH_WRITE = 47,
    DOUBLE_DENSITY_CD_READ = 48,
    DOUBLE_DENSITY_CD_R_WRITE = 49,
    DOUBLE_DENSITY_CD_RW_WRITE = 50,
    LAYER_JUMP_RECORDING = 51,
    CD_RW_MEDIA_WRITE_SUPPORT = 55,
    BD_PSEUDO_OVERWRITE = 56,
    DVD_PLUS_R_DUAL_LAYER = 59,
    BD_READ = 64,
    BD_WRITE = 65,
    HD_DVD_READ = 80,
    HD_DVD_WRITE = 81,
    POWER_MANAGEMENT = 256,
    SMART = 257,
    EMBEDDED_CHANGER = 258,
    CD_ANALOG_PLAY = 259,
    MICROCODE_UPDATE = 260,
    TIMEOUT = 261,
    DVD_CSS = 262,
    REAL_TIME_STREAMING = 263,
    LOGICAL_UNIT_SERIAL_NUMBER = 264,
    MEDIA_SERIAL_NUMBER = 265,
    DISC_CONTROL_BLOCKS = 266,
    DVD_CPRM = 267,
    FIRMWARE_INFORMATION = 268,
    AACS = 269,
    VCPS = 272,
};
pub const IMAPI_FEATURE_PAGE_TYPE_PROFILE_LIST = IMAPI_FEATURE_PAGE_TYPE.PROFILE_LIST;
pub const IMAPI_FEATURE_PAGE_TYPE_CORE = IMAPI_FEATURE_PAGE_TYPE.CORE;
pub const IMAPI_FEATURE_PAGE_TYPE_MORPHING = IMAPI_FEATURE_PAGE_TYPE.MORPHING;
pub const IMAPI_FEATURE_PAGE_TYPE_REMOVABLE_MEDIUM = IMAPI_FEATURE_PAGE_TYPE.REMOVABLE_MEDIUM;
pub const IMAPI_FEATURE_PAGE_TYPE_WRITE_PROTECT = IMAPI_FEATURE_PAGE_TYPE.WRITE_PROTECT;
pub const IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_READABLE = IMAPI_FEATURE_PAGE_TYPE.RANDOMLY_READABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_MULTIREAD = IMAPI_FEATURE_PAGE_TYPE.CD_MULTIREAD;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_READ = IMAPI_FEATURE_PAGE_TYPE.CD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_READ = IMAPI_FEATURE_PAGE_TYPE.DVD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_WRITABLE = IMAPI_FEATURE_PAGE_TYPE.RANDOMLY_WRITABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_INCREMENTAL_STREAMING_WRITABLE = IMAPI_FEATURE_PAGE_TYPE.INCREMENTAL_STREAMING_WRITABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_SECTOR_ERASABLE = IMAPI_FEATURE_PAGE_TYPE.SECTOR_ERASABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_FORMATTABLE = IMAPI_FEATURE_PAGE_TYPE.FORMATTABLE;
pub const IMAPI_FEATURE_PAGE_TYPE_HARDWARE_DEFECT_MANAGEMENT = IMAPI_FEATURE_PAGE_TYPE.HARDWARE_DEFECT_MANAGEMENT;
pub const IMAPI_FEATURE_PAGE_TYPE_WRITE_ONCE = IMAPI_FEATURE_PAGE_TYPE.WRITE_ONCE;
pub const IMAPI_FEATURE_PAGE_TYPE_RESTRICTED_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.RESTRICTED_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_CDRW_CAV_WRITE = IMAPI_FEATURE_PAGE_TYPE.CDRW_CAV_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_MRW = IMAPI_FEATURE_PAGE_TYPE.MRW;
pub const IMAPI_FEATURE_PAGE_TYPE_ENHANCED_DEFECT_REPORTING = IMAPI_FEATURE_PAGE_TYPE.ENHANCED_DEFECT_REPORTING;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_RW = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_RW;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_R;
pub const IMAPI_FEATURE_PAGE_TYPE_RIGID_RESTRICTED_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.RIGID_RESTRICTED_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_TRACK_AT_ONCE = IMAPI_FEATURE_PAGE_TYPE.CD_TRACK_AT_ONCE;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_MASTERING = IMAPI_FEATURE_PAGE_TYPE.CD_MASTERING;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_DASH_WRITE = IMAPI_FEATURE_PAGE_TYPE.DVD_DASH_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_READ = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_R_WRITE = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_R_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_RW_WRITE = IMAPI_FEATURE_PAGE_TYPE.DOUBLE_DENSITY_CD_RW_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_LAYER_JUMP_RECORDING = IMAPI_FEATURE_PAGE_TYPE.LAYER_JUMP_RECORDING;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_RW_MEDIA_WRITE_SUPPORT = IMAPI_FEATURE_PAGE_TYPE.CD_RW_MEDIA_WRITE_SUPPORT;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_PSEUDO_OVERWRITE = IMAPI_FEATURE_PAGE_TYPE.BD_PSEUDO_OVERWRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R_DUAL_LAYER = IMAPI_FEATURE_PAGE_TYPE.DVD_PLUS_R_DUAL_LAYER;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_READ = IMAPI_FEATURE_PAGE_TYPE.BD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_BD_WRITE = IMAPI_FEATURE_PAGE_TYPE.BD_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_HD_DVD_READ = IMAPI_FEATURE_PAGE_TYPE.HD_DVD_READ;
pub const IMAPI_FEATURE_PAGE_TYPE_HD_DVD_WRITE = IMAPI_FEATURE_PAGE_TYPE.HD_DVD_WRITE;
pub const IMAPI_FEATURE_PAGE_TYPE_POWER_MANAGEMENT = IMAPI_FEATURE_PAGE_TYPE.POWER_MANAGEMENT;
pub const IMAPI_FEATURE_PAGE_TYPE_SMART = IMAPI_FEATURE_PAGE_TYPE.SMART;
pub const IMAPI_FEATURE_PAGE_TYPE_EMBEDDED_CHANGER = IMAPI_FEATURE_PAGE_TYPE.EMBEDDED_CHANGER;
pub const IMAPI_FEATURE_PAGE_TYPE_CD_ANALOG_PLAY = IMAPI_FEATURE_PAGE_TYPE.CD_ANALOG_PLAY;
pub const IMAPI_FEATURE_PAGE_TYPE_MICROCODE_UPDATE = IMAPI_FEATURE_PAGE_TYPE.MICROCODE_UPDATE;
pub const IMAPI_FEATURE_PAGE_TYPE_TIMEOUT = IMAPI_FEATURE_PAGE_TYPE.TIMEOUT;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_CSS = IMAPI_FEATURE_PAGE_TYPE.DVD_CSS;
pub const IMAPI_FEATURE_PAGE_TYPE_REAL_TIME_STREAMING = IMAPI_FEATURE_PAGE_TYPE.REAL_TIME_STREAMING;
pub const IMAPI_FEATURE_PAGE_TYPE_LOGICAL_UNIT_SERIAL_NUMBER = IMAPI_FEATURE_PAGE_TYPE.LOGICAL_UNIT_SERIAL_NUMBER;
pub const IMAPI_FEATURE_PAGE_TYPE_MEDIA_SERIAL_NUMBER = IMAPI_FEATURE_PAGE_TYPE.MEDIA_SERIAL_NUMBER;
pub const IMAPI_FEATURE_PAGE_TYPE_DISC_CONTROL_BLOCKS = IMAPI_FEATURE_PAGE_TYPE.DISC_CONTROL_BLOCKS;
pub const IMAPI_FEATURE_PAGE_TYPE_DVD_CPRM = IMAPI_FEATURE_PAGE_TYPE.DVD_CPRM;
pub const IMAPI_FEATURE_PAGE_TYPE_FIRMWARE_INFORMATION = IMAPI_FEATURE_PAGE_TYPE.FIRMWARE_INFORMATION;
pub const IMAPI_FEATURE_PAGE_TYPE_AACS = IMAPI_FEATURE_PAGE_TYPE.AACS;
pub const IMAPI_FEATURE_PAGE_TYPE_VCPS = IMAPI_FEATURE_PAGE_TYPE.VCPS;

pub const IMAPI_PROFILE_TYPE = enum(i32) {
    INVALID = 0,
    NON_REMOVABLE_DISK = 1,
    REMOVABLE_DISK = 2,
    MO_ERASABLE = 3,
    MO_WRITE_ONCE = 4,
    AS_MO = 5,
    CDROM = 8,
    CD_RECORDABLE = 9,
    CD_REWRITABLE = 10,
    DVDROM = 16,
    DVD_DASH_RECORDABLE = 17,
    DVD_RAM = 18,
    DVD_DASH_REWRITABLE = 19,
    DVD_DASH_RW_SEQUENTIAL = 20,
    DVD_DASH_R_DUAL_SEQUENTIAL = 21,
    DVD_DASH_R_DUAL_LAYER_JUMP = 22,
    DVD_PLUS_RW = 26,
    DVD_PLUS_R = 27,
    DDCDROM = 32,
    DDCD_RECORDABLE = 33,
    DDCD_REWRITABLE = 34,
    DVD_PLUS_RW_DUAL = 42,
    DVD_PLUS_R_DUAL = 43,
    BD_ROM = 64,
    BD_R_SEQUENTIAL = 65,
    BD_R_RANDOM_RECORDING = 66,
    BD_REWRITABLE = 67,
    HD_DVD_ROM = 80,
    HD_DVD_RECORDABLE = 81,
    HD_DVD_RAM = 82,
    NON_STANDARD = 65535,
};
pub const IMAPI_PROFILE_TYPE_INVALID = IMAPI_PROFILE_TYPE.INVALID;
pub const IMAPI_PROFILE_TYPE_NON_REMOVABLE_DISK = IMAPI_PROFILE_TYPE.NON_REMOVABLE_DISK;
pub const IMAPI_PROFILE_TYPE_REMOVABLE_DISK = IMAPI_PROFILE_TYPE.REMOVABLE_DISK;
pub const IMAPI_PROFILE_TYPE_MO_ERASABLE = IMAPI_PROFILE_TYPE.MO_ERASABLE;
pub const IMAPI_PROFILE_TYPE_MO_WRITE_ONCE = IMAPI_PROFILE_TYPE.MO_WRITE_ONCE;
pub const IMAPI_PROFILE_TYPE_AS_MO = IMAPI_PROFILE_TYPE.AS_MO;
pub const IMAPI_PROFILE_TYPE_CDROM = IMAPI_PROFILE_TYPE.CDROM;
pub const IMAPI_PROFILE_TYPE_CD_RECORDABLE = IMAPI_PROFILE_TYPE.CD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_CD_REWRITABLE = IMAPI_PROFILE_TYPE.CD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVDROM = IMAPI_PROFILE_TYPE.DVDROM;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_RECORDABLE = IMAPI_PROFILE_TYPE.DVD_DASH_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_DVD_RAM = IMAPI_PROFILE_TYPE.DVD_RAM;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_REWRITABLE = IMAPI_PROFILE_TYPE.DVD_DASH_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_RW_SEQUENTIAL = IMAPI_PROFILE_TYPE.DVD_DASH_RW_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_SEQUENTIAL = IMAPI_PROFILE_TYPE.DVD_DASH_R_DUAL_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_LAYER_JUMP = IMAPI_PROFILE_TYPE.DVD_DASH_R_DUAL_LAYER_JUMP;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_RW = IMAPI_PROFILE_TYPE.DVD_PLUS_RW;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_R = IMAPI_PROFILE_TYPE.DVD_PLUS_R;
pub const IMAPI_PROFILE_TYPE_DDCDROM = IMAPI_PROFILE_TYPE.DDCDROM;
pub const IMAPI_PROFILE_TYPE_DDCD_RECORDABLE = IMAPI_PROFILE_TYPE.DDCD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_DDCD_REWRITABLE = IMAPI_PROFILE_TYPE.DDCD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_RW_DUAL = IMAPI_PROFILE_TYPE.DVD_PLUS_RW_DUAL;
pub const IMAPI_PROFILE_TYPE_DVD_PLUS_R_DUAL = IMAPI_PROFILE_TYPE.DVD_PLUS_R_DUAL;
pub const IMAPI_PROFILE_TYPE_BD_ROM = IMAPI_PROFILE_TYPE.BD_ROM;
pub const IMAPI_PROFILE_TYPE_BD_R_SEQUENTIAL = IMAPI_PROFILE_TYPE.BD_R_SEQUENTIAL;
pub const IMAPI_PROFILE_TYPE_BD_R_RANDOM_RECORDING = IMAPI_PROFILE_TYPE.BD_R_RANDOM_RECORDING;
pub const IMAPI_PROFILE_TYPE_BD_REWRITABLE = IMAPI_PROFILE_TYPE.BD_REWRITABLE;
pub const IMAPI_PROFILE_TYPE_HD_DVD_ROM = IMAPI_PROFILE_TYPE.HD_DVD_ROM;
pub const IMAPI_PROFILE_TYPE_HD_DVD_RECORDABLE = IMAPI_PROFILE_TYPE.HD_DVD_RECORDABLE;
pub const IMAPI_PROFILE_TYPE_HD_DVD_RAM = IMAPI_PROFILE_TYPE.HD_DVD_RAM;
pub const IMAPI_PROFILE_TYPE_NON_STANDARD = IMAPI_PROFILE_TYPE.NON_STANDARD;

pub const IMAPI_FORMAT2_DATA_WRITE_ACTION = enum(i32) {
    VALIDATING_MEDIA = 0,
    FORMATTING_MEDIA = 1,
    INITIALIZING_HARDWARE = 2,
    CALIBRATING_POWER = 3,
    WRITING_DATA = 4,
    FINALIZATION = 5,
    COMPLETED = 6,
    VERIFYING = 7,
};
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_VALIDATING_MEDIA = IMAPI_FORMAT2_DATA_WRITE_ACTION.VALIDATING_MEDIA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_FORMATTING_MEDIA = IMAPI_FORMAT2_DATA_WRITE_ACTION.FORMATTING_MEDIA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_INITIALIZING_HARDWARE = IMAPI_FORMAT2_DATA_WRITE_ACTION.INITIALIZING_HARDWARE;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_CALIBRATING_POWER = IMAPI_FORMAT2_DATA_WRITE_ACTION.CALIBRATING_POWER;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_WRITING_DATA = IMAPI_FORMAT2_DATA_WRITE_ACTION.WRITING_DATA;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_FINALIZATION = IMAPI_FORMAT2_DATA_WRITE_ACTION.FINALIZATION;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_COMPLETED = IMAPI_FORMAT2_DATA_WRITE_ACTION.COMPLETED;
pub const IMAPI_FORMAT2_DATA_WRITE_ACTION_VERIFYING = IMAPI_FORMAT2_DATA_WRITE_ACTION.VERIFYING;

pub const IMAPI_FORMAT2_DATA_MEDIA_STATE = enum(i32) {
    UNKNOWN = 0,
    INFORMATIONAL_MASK = 15,
    UNSUPPORTED_MASK = 64512,
    OVERWRITE_ONLY = 1,
    // RANDOMLY_WRITABLE = 1, this enum value conflicts with OVERWRITE_ONLY
    BLANK = 2,
    APPENDABLE = 4,
    FINAL_SESSION = 8,
    DAMAGED = 1024,
    ERASE_REQUIRED = 2048,
    NON_EMPTY_SESSION = 4096,
    WRITE_PROTECTED = 8192,
    FINALIZED = 16384,
    UNSUPPORTED_MEDIA = 32768,
};
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNKNOWN = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNKNOWN;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_INFORMATIONAL_MASK = IMAPI_FORMAT2_DATA_MEDIA_STATE.INFORMATIONAL_MASK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MASK = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNSUPPORTED_MASK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_OVERWRITE_ONLY = IMAPI_FORMAT2_DATA_MEDIA_STATE.OVERWRITE_ONLY;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_RANDOMLY_WRITABLE = IMAPI_FORMAT2_DATA_MEDIA_STATE.OVERWRITE_ONLY;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_BLANK = IMAPI_FORMAT2_DATA_MEDIA_STATE.BLANK;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_APPENDABLE = IMAPI_FORMAT2_DATA_MEDIA_STATE.APPENDABLE;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_FINAL_SESSION = IMAPI_FORMAT2_DATA_MEDIA_STATE.FINAL_SESSION;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_DAMAGED = IMAPI_FORMAT2_DATA_MEDIA_STATE.DAMAGED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_ERASE_REQUIRED = IMAPI_FORMAT2_DATA_MEDIA_STATE.ERASE_REQUIRED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_NON_EMPTY_SESSION = IMAPI_FORMAT2_DATA_MEDIA_STATE.NON_EMPTY_SESSION;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_WRITE_PROTECTED = IMAPI_FORMAT2_DATA_MEDIA_STATE.WRITE_PROTECTED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_FINALIZED = IMAPI_FORMAT2_DATA_MEDIA_STATE.FINALIZED;
pub const IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MEDIA = IMAPI_FORMAT2_DATA_MEDIA_STATE.UNSUPPORTED_MEDIA;

pub const IMAPI_FORMAT2_TAO_WRITE_ACTION = enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    WRITING = 2,
    FINISHING = 3,
    VERIFYING = 4,
};
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_UNKNOWN = IMAPI_FORMAT2_TAO_WRITE_ACTION.UNKNOWN;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_PREPARING = IMAPI_FORMAT2_TAO_WRITE_ACTION.PREPARING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_WRITING = IMAPI_FORMAT2_TAO_WRITE_ACTION.WRITING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_FINISHING = IMAPI_FORMAT2_TAO_WRITE_ACTION.FINISHING;
pub const IMAPI_FORMAT2_TAO_WRITE_ACTION_VERIFYING = IMAPI_FORMAT2_TAO_WRITE_ACTION.VERIFYING;

pub const IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE = enum(i32) {
    PQ_ONLY = 1,
    IS_COOKED = 2,
    IS_RAW = 3,
};
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_PQ_ONLY = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.PQ_ONLY;
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_COOKED = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.IS_COOKED;
pub const IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_RAW = IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE.IS_RAW;

pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION = enum(i32) {
    UNKNOWN = 0,
    PREPARING = 1,
    WRITING = 2,
    FINISHING = 3,
};
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_UNKNOWN = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.UNKNOWN;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_PREPARING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.PREPARING;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_WRITING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.WRITING;
pub const IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_FINISHING = IMAPI_FORMAT2_RAW_CD_WRITE_ACTION.FINISHING;

pub const IMAPI_CD_SECTOR_TYPE = enum(i32) {
    AUDIO = 0,
    MODE_ZERO = 1,
    MODE1 = 2,
    MODE2FORM0 = 3,
    MODE2FORM1 = 4,
    MODE2FORM2 = 5,
    MODE1RAW = 6,
    MODE2FORM0RAW = 7,
    MODE2FORM1RAW = 8,
    MODE2FORM2RAW = 9,
};
pub const IMAPI_CD_SECTOR_AUDIO = IMAPI_CD_SECTOR_TYPE.AUDIO;
pub const IMAPI_CD_SECTOR_MODE_ZERO = IMAPI_CD_SECTOR_TYPE.MODE_ZERO;
pub const IMAPI_CD_SECTOR_MODE1 = IMAPI_CD_SECTOR_TYPE.MODE1;
pub const IMAPI_CD_SECTOR_MODE2FORM0 = IMAPI_CD_SECTOR_TYPE.MODE2FORM0;
pub const IMAPI_CD_SECTOR_MODE2FORM1 = IMAPI_CD_SECTOR_TYPE.MODE2FORM1;
pub const IMAPI_CD_SECTOR_MODE2FORM2 = IMAPI_CD_SECTOR_TYPE.MODE2FORM2;
pub const IMAPI_CD_SECTOR_MODE1RAW = IMAPI_CD_SECTOR_TYPE.MODE1RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM0RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM0RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM1RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM1RAW;
pub const IMAPI_CD_SECTOR_MODE2FORM2RAW = IMAPI_CD_SECTOR_TYPE.MODE2FORM2RAW;

pub const IMAPI_CD_TRACK_DIGITAL_COPY_SETTING = enum(i32) {
    PERMITTED = 0,
    PROHIBITED = 1,
    SCMS = 2,
};
pub const IMAPI_CD_TRACK_DIGITAL_COPY_PERMITTED = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.PERMITTED;
pub const IMAPI_CD_TRACK_DIGITAL_COPY_PROHIBITED = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.PROHIBITED;
pub const IMAPI_CD_TRACK_DIGITAL_COPY_SCMS = IMAPI_CD_TRACK_DIGITAL_COPY_SETTING.SCMS;

pub const IMAPI_BURN_VERIFICATION_LEVEL = enum(i32) {
    NONE = 0,
    QUICK = 1,
    FULL = 2,
};
pub const IMAPI_BURN_VERIFICATION_NONE = IMAPI_BURN_VERIFICATION_LEVEL.NONE;
pub const IMAPI_BURN_VERIFICATION_QUICK = IMAPI_BURN_VERIFICATION_LEVEL.QUICK;
pub const IMAPI_BURN_VERIFICATION_FULL = IMAPI_BURN_VERIFICATION_LEVEL.FULL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscMaster2_Value = Guid.initString("27354130-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscMaster2 = &IID_IDiscMaster2_Value;
pub const IDiscMaster2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscMaster2,
                ppunk: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscMaster2,
                ppunk: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscMaster2,
                index: i32,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscMaster2,
                index: i32,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscMaster2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscMaster2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSupportedEnvironment: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscMaster2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscMaster2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get__NewEnum(self: *const T, ppunk: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IDiscMaster2, @ptrCast(self)), ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get_Item(self: *const T, index: i32, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IDiscMaster2, @ptrCast(self)), index, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get_Count(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IDiscMaster2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster2_get_IsSupportedEnvironment(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster2.VTable, @ptrCast(self.vtable)).get_IsSupportedEnvironment(@as(*const IDiscMaster2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscMaster2Events_Value = Guid.initString("27354131-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscMaster2Events = &IID_DDiscMaster2Events_Value;
pub const DDiscMaster2Events = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        NotifyDeviceAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DDiscMaster2Events,
                object: ?*IDispatch,
                uniqueId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DDiscMaster2Events,
                object: ?*IDispatch,
                uniqueId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyDeviceRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DDiscMaster2Events,
                object: ?*IDispatch,
                uniqueId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DDiscMaster2Events,
                object: ?*IDispatch,
                uniqueId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscMaster2Events_NotifyDeviceAdded(self: *const T, object: ?*IDispatch, uniqueId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const DDiscMaster2Events.VTable, @ptrCast(self.vtable)).NotifyDeviceAdded(@as(*const DDiscMaster2Events, @ptrCast(self)), object, uniqueId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscMaster2Events_NotifyDeviceRemoved(self: *const T, object: ?*IDispatch, uniqueId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const DDiscMaster2Events.VTable, @ptrCast(self.vtable)).NotifyDeviceRemoved(@as(*const DDiscMaster2Events, @ptrCast(self)), object, uniqueId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscRecorder2Ex_Value = Guid.initString("27354132-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscRecorder2Ex = &IID_IDiscRecorder2Ex_Value;
pub const IDiscRecorder2Ex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendCommandNoData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                Cdb: [*:0]u8,
                CdbSize: u32,
                SenseBuffer: *[18]u8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                Cdb: [*:0]u8,
                CdbSize: u32,
                SenseBuffer: *[18]u8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendCommandSendDataToDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                Cdb: [*:0]u8,
                CdbSize: u32,
                SenseBuffer: *[18]u8,
                Timeout: u32,
                Buffer: [*:0]u8,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                Cdb: [*:0]u8,
                CdbSize: u32,
                SenseBuffer: *[18]u8,
                Timeout: u32,
                Buffer: [*:0]u8,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendCommandGetDataFromDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                Cdb: [*:0]u8,
                CdbSize: u32,
                SenseBuffer: *[18]u8,
                Timeout: u32,
                Buffer: [*:0]u8,
                BufferSize: u32,
                BufferFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                Cdb: [*:0]u8,
                CdbSize: u32,
                SenseBuffer: *[18]u8,
                Timeout: u32,
                Buffer: [*:0]u8,
                BufferSize: u32,
                BufferFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDvdStructure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                format: u32,
                address: u32,
                layer: u32,
                agid: u32,
                data: [*]?*u8,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                format: u32,
                address: u32,
                layer: u32,
                agid: u32,
                data: [*]?*u8,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendDvdStructure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                format: u32,
                data: [*:0]u8,
                count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                format: u32,
                data: [*:0]u8,
                count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdapterDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                data: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                data: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                data: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                data: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDiscInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                discInformation: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                discInformation: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTrackInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                address: u32,
                addressType: IMAPI_READ_TRACK_ADDRESS_TYPE,
                trackInformation: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                address: u32,
                addressType: IMAPI_READ_TRACK_ADDRESS_TYPE,
                trackInformation: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeaturePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                requestedFeature: IMAPI_FEATURE_PAGE_TYPE,
                currentFeatureOnly: BOOLEAN,
                featureData: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                requestedFeature: IMAPI_FEATURE_PAGE_TYPE,
                currentFeatureOnly: BOOLEAN,
                featureData: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                requestedModePage: IMAPI_MODE_PAGE_TYPE,
                requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
                modePageData: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                requestedModePage: IMAPI_MODE_PAGE_TYPE,
                requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
                modePageData: [*]?*u8,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetModePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
                data: [*:0]u8,
                byteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
                data: [*:0]u8,
                byteSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedFeaturePages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                currentFeatureOnly: BOOLEAN,
                featureData: [*]?*IMAPI_FEATURE_PAGE_TYPE,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                currentFeatureOnly: BOOLEAN,
                featureData: [*]?*IMAPI_FEATURE_PAGE_TYPE,
                byteSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProfiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                currentOnly: BOOLEAN,
                profileTypes: [*]?*IMAPI_PROFILE_TYPE,
                validProfiles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                currentOnly: BOOLEAN,
                profileTypes: [*]?*IMAPI_PROFILE_TYPE,
                validProfiles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedModePages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
                modePageTypes: [*]?*IMAPI_MODE_PAGE_TYPE,
                validPages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                requestType: IMAPI_MODE_PAGE_REQUEST_TYPE,
                modePageTypes: [*]?*IMAPI_MODE_PAGE_TYPE,
                validPages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetByteAlignmentMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumNonPageAlignedTransferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaximumPageAlignedTransferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2Ex,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2Ex,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendCommandNoData(self: *const T, Cdb: [*:0]u8, CdbSize: u32, SenseBuffer: *[18]u8, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendCommandNoData(@as(*const IDiscRecorder2Ex, @ptrCast(self)), Cdb, CdbSize, SenseBuffer, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendCommandSendDataToDevice(self: *const T, Cdb: [*:0]u8, CdbSize: u32, SenseBuffer: *[18]u8, Timeout: u32, Buffer: [*:0]u8, BufferSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendCommandSendDataToDevice(@as(*const IDiscRecorder2Ex, @ptrCast(self)), Cdb, CdbSize, SenseBuffer, Timeout, Buffer, BufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendCommandGetDataFromDevice(self: *const T, Cdb: [*:0]u8, CdbSize: u32, SenseBuffer: *[18]u8, Timeout: u32, Buffer: [*:0]u8, BufferSize: u32, BufferFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendCommandGetDataFromDevice(@as(*const IDiscRecorder2Ex, @ptrCast(self)), Cdb, CdbSize, SenseBuffer, Timeout, Buffer, BufferSize, BufferFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_ReadDvdStructure(self: *const T, format: u32, address: u32, layer: u32, agid: u32, data: [*]?*u8, count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).ReadDvdStructure(@as(*const IDiscRecorder2Ex, @ptrCast(self)), format, address, layer, agid, data, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SendDvdStructure(self: *const T, format: u32, data: [*:0]u8, count: u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SendDvdStructure(@as(*const IDiscRecorder2Ex, @ptrCast(self)), format, data, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetAdapterDescriptor(self: *const T, data: [*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetAdapterDescriptor(@as(*const IDiscRecorder2Ex, @ptrCast(self)), data, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetDeviceDescriptor(self: *const T, data: [*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetDeviceDescriptor(@as(*const IDiscRecorder2Ex, @ptrCast(self)), data, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetDiscInformation(self: *const T, discInformation: [*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetDiscInformation(@as(*const IDiscRecorder2Ex, @ptrCast(self)), discInformation, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetTrackInformation(self: *const T, address: u32, addressType: IMAPI_READ_TRACK_ADDRESS_TYPE, trackInformation: [*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetTrackInformation(@as(*const IDiscRecorder2Ex, @ptrCast(self)), address, addressType, trackInformation, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetFeaturePage(self: *const T, requestedFeature: IMAPI_FEATURE_PAGE_TYPE, currentFeatureOnly: BOOLEAN, featureData: [*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetFeaturePage(@as(*const IDiscRecorder2Ex, @ptrCast(self)), requestedFeature, currentFeatureOnly, featureData, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetModePage(self: *const T, requestedModePage: IMAPI_MODE_PAGE_TYPE, requestType: IMAPI_MODE_PAGE_REQUEST_TYPE, modePageData: [*]?*u8, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetModePage(@as(*const IDiscRecorder2Ex, @ptrCast(self)), requestedModePage, requestType, modePageData, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_SetModePage(self: *const T, requestType: IMAPI_MODE_PAGE_REQUEST_TYPE, data: [*:0]u8, byteSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).SetModePage(@as(*const IDiscRecorder2Ex, @ptrCast(self)), requestType, data, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetSupportedFeaturePages(self: *const T, currentFeatureOnly: BOOLEAN, featureData: [*]?*IMAPI_FEATURE_PAGE_TYPE, byteSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetSupportedFeaturePages(@as(*const IDiscRecorder2Ex, @ptrCast(self)), currentFeatureOnly, featureData, byteSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetSupportedProfiles(self: *const T, currentOnly: BOOLEAN, profileTypes: [*]?*IMAPI_PROFILE_TYPE, validProfiles: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetSupportedProfiles(@as(*const IDiscRecorder2Ex, @ptrCast(self)), currentOnly, profileTypes, validProfiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetSupportedModePages(self: *const T, requestType: IMAPI_MODE_PAGE_REQUEST_TYPE, modePageTypes: [*]?*IMAPI_MODE_PAGE_TYPE, validPages: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetSupportedModePages(@as(*const IDiscRecorder2Ex, @ptrCast(self)), requestType, modePageTypes, validPages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetByteAlignmentMask(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetByteAlignmentMask(@as(*const IDiscRecorder2Ex, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetMaximumNonPageAlignedTransferSize(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetMaximumNonPageAlignedTransferSize(@as(*const IDiscRecorder2Ex, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2Ex_GetMaximumPageAlignedTransferSize(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2Ex.VTable, @ptrCast(self.vtable)).GetMaximumPageAlignedTransferSize(@as(*const IDiscRecorder2Ex, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscRecorder2_Value = Guid.initString("27354133-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscRecorder2 = &IID_IDiscRecorder2_Value;
pub const IDiscRecorder2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        EjectMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseTray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcquireExclusiveAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
                force: i16,
                __MIDL__IDiscRecorder20000: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
                force: i16,
                __MIDL__IDiscRecorder20000: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseExclusiveAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableMcn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableMcn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeDiscRecorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder2,
                recorderUniqueId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder2,
                recorderUniqueId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveDiscRecorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VendorId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductRevision: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumePathNames: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeviceCanLoadMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LegacyDeviceNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                legacyDeviceNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                legacyDeviceNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedFeaturePages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentFeaturePages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedProfiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentProfiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedModePages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExclusiveAccessOwner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscRecorder2,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_EjectMedia(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).EjectMedia(@as(*const IDiscRecorder2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_CloseTray(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).CloseTray(@as(*const IDiscRecorder2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_AcquireExclusiveAccess(self: *const T, force: i16, __MIDL__IDiscRecorder20000: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).AcquireExclusiveAccess(@as(*const IDiscRecorder2, @ptrCast(self)), force, __MIDL__IDiscRecorder20000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_ReleaseExclusiveAccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).ReleaseExclusiveAccess(@as(*const IDiscRecorder2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_DisableMcn(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).DisableMcn(@as(*const IDiscRecorder2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_EnableMcn(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).EnableMcn(@as(*const IDiscRecorder2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_InitializeDiscRecorder(self: *const T, recorderUniqueId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).InitializeDiscRecorder(@as(*const IDiscRecorder2, @ptrCast(self)), recorderUniqueId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ActiveDiscRecorder(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ActiveDiscRecorder(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_VendorId(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_VendorId(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ProductId(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ProductId(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ProductRevision(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ProductRevision(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_VolumeName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_VolumeName(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_VolumePathNames(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_VolumePathNames(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_DeviceCanLoadMedia(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_DeviceCanLoadMedia(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_LegacyDeviceNumber(self: *const T, legacyDeviceNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_LegacyDeviceNumber(@as(*const IDiscRecorder2, @ptrCast(self)), legacyDeviceNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_SupportedFeaturePages(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_SupportedFeaturePages(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_CurrentFeaturePages(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_CurrentFeaturePages(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_SupportedProfiles(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_SupportedProfiles(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_CurrentProfiles(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_CurrentProfiles(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_SupportedModePages(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_SupportedModePages(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder2_get_ExclusiveAccessOwner(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder2.VTable, @ptrCast(self.vtable)).get_ExclusiveAccessOwner(@as(*const IDiscRecorder2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteEngine2_Value = Guid.initString("27354135-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteEngine2 = &IID_IWriteEngine2_Value;
pub const IWriteEngine2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        WriteSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWriteEngine2,
                data: ?*IStream,
                startingBlockAddress: i32,
                numberOfBlocks: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWriteEngine2,
                data: ?*IStream,
                startingBlockAddress: i32,
                numberOfBlocks: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelWrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWriteEngine2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWriteEngine2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*IDiscRecorder2Ex,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*IDiscRecorder2Ex,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*?*IDiscRecorder2Ex,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*?*IDiscRecorder2Ex,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseStreamingWrite12: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseStreamingWrite12: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartingSectorsPerSecond: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingSectorsPerSecond: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EndingSectorsPerSecond: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndingSectorsPerSecond: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BytesPerSector: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BytesPerSector: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteInProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_WriteSection(self: *const T, data: ?*IStream, startingBlockAddress: i32, numberOfBlocks: i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).WriteSection(@as(*const IWriteEngine2, @ptrCast(self)), data, startingBlockAddress, numberOfBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_CancelWrite(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).CancelWrite(@as(*const IWriteEngine2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_Recorder(self: *const T, value: ?*IDiscRecorder2Ex) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2Ex) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_UseStreamingWrite12(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_UseStreamingWrite12(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_UseStreamingWrite12(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_UseStreamingWrite12(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_StartingSectorsPerSecond(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_StartingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_StartingSectorsPerSecond(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_StartingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_EndingSectorsPerSecond(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_EndingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_EndingSectorsPerSecond(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_EndingSectorsPerSecond(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_put_BytesPerSector(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).put_BytesPerSector(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_BytesPerSector(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_BytesPerSector(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2_get_WriteInProgress(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2.VTable, @ptrCast(self.vtable)).get_WriteInProgress(@as(*const IWriteEngine2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteEngine2EventArgs_Value = Guid.initString("27354136-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteEngine2EventArgs = &IID_IWriteEngine2EventArgs_Value;
pub const IWriteEngine2EventArgs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartLba: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastReadLba: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenLba: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSystemBuffer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedSystemBuffer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSystemBuffer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteEngine2EventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_StartLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_StartLba(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_SectorCount(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_SectorCount(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_LastReadLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_LastReadLba(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_LastWrittenLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_LastWrittenLba(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_TotalSystemBuffer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_TotalSystemBuffer(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_UsedSystemBuffer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_UsedSystemBuffer(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteEngine2EventArgs_get_FreeSystemBuffer(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteEngine2EventArgs.VTable, @ptrCast(self.vtable)).get_FreeSystemBuffer(@as(*const IWriteEngine2EventArgs, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DWriteEngine2Events_Value = Guid.initString("27354137-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DWriteEngine2Events = &IID_DWriteEngine2Events_Value;
pub const DWriteEngine2Events = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DWriteEngine2Events,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DWriteEngine2Events,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DWriteEngine2Events_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const DWriteEngine2Events.VTable, @ptrCast(self.vtable)).Update(@as(*const DWriteEngine2Events, @ptrCast(self)), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2_Value = Guid.initString("27354152-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2 = &IID_IDiscFormat2_Value;
pub const IDiscFormat2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        IsRecorderSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2,
                recorder: ?*IDiscRecorder2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2,
                recorder: ?*IDiscRecorder2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCurrentMediaSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2,
                recorder: ?*IDiscRecorder2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2,
                recorder: ?*IDiscRecorder2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaPhysicallyBlank: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaHeuristicallyBlank: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedMediaTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_IsRecorderSupported(self: *const T, recorder: ?*IDiscRecorder2, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).IsRecorderSupported(@as(*const IDiscFormat2, @ptrCast(self)), recorder, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_IsCurrentMediaSupported(self: *const T, recorder: ?*IDiscRecorder2, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).IsCurrentMediaSupported(@as(*const IDiscFormat2, @ptrCast(self)), recorder, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_get_MediaPhysicallyBlank(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).get_MediaPhysicallyBlank(@as(*const IDiscFormat2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_get_MediaHeuristicallyBlank(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).get_MediaHeuristicallyBlank(@as(*const IDiscFormat2, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2_get_SupportedMediaTypes(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2.VTable, @ptrCast(self.vtable)).get_SupportedMediaTypes(@as(*const IDiscFormat2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2Erase_Value = Guid.initString("27354156-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2Erase = &IID_IDiscFormat2Erase_Value;
pub const IDiscFormat2Erase = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullErase: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullErase: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Erase,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EraseMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2Erase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2Erase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_put_FullErase(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).put_FullErase(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_FullErase(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_FullErase(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2Erase, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Erase_EraseMedia(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Erase.VTable, @ptrCast(self.vtable)).EraseMedia(@as(*const IDiscFormat2Erase, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2EraseEvents_Value = Guid.initString("2735413a-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2EraseEvents = &IID_DDiscFormat2EraseEvents_Value;
pub const DDiscFormat2EraseEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DDiscFormat2EraseEvents,
                object: ?*IDispatch,
                elapsedSeconds: i32,
                estimatedTotalSeconds: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DDiscFormat2EraseEvents,
                object: ?*IDispatch,
                elapsedSeconds: i32,
                estimatedTotalSeconds: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2EraseEvents_Update(self: *const T, object: ?*IDispatch, elapsedSeconds: i32, estimatedTotalSeconds: i32) callconv(.Inline) HRESULT {
            return @as(*const DDiscFormat2EraseEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2EraseEvents, @ptrCast(self)), object, elapsedSeconds, estimatedTotalSeconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2Data_Value = Guid.initString("27354153-9f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2Data = &IID_IDiscFormat2Data_Value;
pub const IDiscFormat2Data = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PostgapAlreadyInImage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PostgapAlreadyInImage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMediaStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteProtectStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextWritableAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAddressOfPreviousSession: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddressOfPreviousSession: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceMediaToBeClosed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceMediaToBeClosed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableConsumerDvdCompatibilityMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableConsumerDvdCompatibilityMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                supportedSpeeds: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                supportedSpeeds: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                supportedSpeedDescriptors: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                supportedSpeedDescriptors: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ForceOverwrite: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ForceOverwrite: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultisessionInterfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2Data,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2Data,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelWrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWriteSpeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2Data,
                RequestedSectorsPerSecond: i32,
                RotationTypeIsPureCAV: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2Data,
                RequestedSectorsPerSecond: i32,
                RotationTypeIsPureCAV: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_BufferUnderrunFreeDisabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_BufferUnderrunFreeDisabled(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_PostgapAlreadyInImage(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_PostgapAlreadyInImage(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_PostgapAlreadyInImage(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_PostgapAlreadyInImage(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentMediaStatus(self: *const T, value: ?*IMAPI_FORMAT2_DATA_MEDIA_STATE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentMediaStatus(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_WriteProtectStatus(self: *const T, value: ?*IMAPI_MEDIA_WRITE_PROTECT_STATE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_WriteProtectStatus(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_TotalSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_TotalSectorsOnMedia(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_FreeSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_FreeSectorsOnMedia(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_NextWritableAddress(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_NextWritableAddress(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_StartAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_StartAddressOfPreviousSession(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_LastWrittenAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_LastWrittenAddressOfPreviousSession(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_ForceMediaToBeClosed(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_ForceMediaToBeClosed(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_ForceMediaToBeClosed(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_ForceMediaToBeClosed(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_DisableConsumerDvdCompatibilityMode(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_DisableConsumerDvdCompatibilityMode(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_DisableConsumerDvdCompatibilityMode(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_DisableConsumerDvdCompatibilityMode(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_RequestedWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_RequestedWriteSpeed(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_RequestedRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_RequestedRotationTypeIsPureCAV(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentWriteSpeed(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_CurrentRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_CurrentRotationTypeIsPureCAV(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_SupportedWriteSpeeds(self: *const T, supportedSpeeds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeeds(@as(*const IDiscFormat2Data, @ptrCast(self)), supportedSpeeds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_SupportedWriteSpeedDescriptors(self: *const T, supportedSpeedDescriptors: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeedDescriptors(@as(*const IDiscFormat2Data, @ptrCast(self)), supportedSpeedDescriptors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_put_ForceOverwrite(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).put_ForceOverwrite(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_ForceOverwrite(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_ForceOverwrite(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_get_MultisessionInterfaces(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).get_MultisessionInterfaces(@as(*const IDiscFormat2Data, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_Write(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).Write(@as(*const IDiscFormat2Data, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_CancelWrite(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).CancelWrite(@as(*const IDiscFormat2Data, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2Data_SetWriteSpeed(self: *const T, RequestedSectorsPerSecond: i32, RotationTypeIsPureCAV: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2Data.VTable, @ptrCast(self.vtable)).SetWriteSpeed(@as(*const IDiscFormat2Data, @ptrCast(self)), RequestedSectorsPerSecond, RotationTypeIsPureCAV);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2DataEvents_Value = Guid.initString("2735413c-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2DataEvents = &IID_DDiscFormat2DataEvents_Value;
pub const DDiscFormat2DataEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DDiscFormat2DataEvents,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DDiscFormat2DataEvents,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2DataEvents_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const DDiscFormat2DataEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2DataEvents, @ptrCast(self)), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2DataEventArgs_Value = Guid.initString("2735413d-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2DataEventArgs = &IID_IDiscFormat2DataEventArgs_Value;
pub const IDiscFormat2DataEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2DataEventArgs,
                value: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_ElapsedTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_ElapsedTime(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_RemainingTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_RemainingTime(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_TotalTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_TotalTime(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2DataEventArgs_get_CurrentAction(self: *const T, value: ?*IMAPI_FORMAT2_DATA_WRITE_ACTION) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2DataEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentAction(@as(*const IDiscFormat2DataEventArgs, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2TrackAtOnce_Value = Guid.initString("27354154-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2TrackAtOnce = &IID_IDiscFormat2TrackAtOnce_Value;
pub const IDiscFormat2TrackAtOnce = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        PrepareMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAudioTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAddTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWriteSpeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                RequestedSectorsPerSecond: i32,
                RotationTypeIsPureCAV: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                RequestedSectorsPerSecond: i32,
                RotationTypeIsPureCAV: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfExistingTracks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DoNotFinalizeMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DoNotFinalizeMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedTableOfContents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                supportedSpeeds: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                supportedSpeeds: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnce,
                supportedSpeedDescriptors: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnce,
                supportedSpeedDescriptors: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_PrepareMedia(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).PrepareMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_AddAudioTrack(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).AddAudioTrack(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_CancelAddTrack(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).CancelAddTrack(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_ReleaseMedia(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).ReleaseMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_SetWriteSpeed(self: *const T, RequestedSectorsPerSecond: i32, RotationTypeIsPureCAV: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).SetWriteSpeed(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), RequestedSectorsPerSecond, RotationTypeIsPureCAV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_BufferUnderrunFreeDisabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_BufferUnderrunFreeDisabled(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_NumberOfExistingTracks(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_NumberOfExistingTracks(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_TotalSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_TotalSectorsOnMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_FreeSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_FreeSectorsOnMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_UsedSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_UsedSectorsOnMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_DoNotFinalizeMedia(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_DoNotFinalizeMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_DoNotFinalizeMedia(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_DoNotFinalizeMedia(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_ExpectedTableOfContents(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_ExpectedTableOfContents(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_RequestedWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_RequestedWriteSpeed(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_RequestedRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_RequestedRotationTypeIsPureCAV(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_CurrentWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_CurrentWriteSpeed(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_CurrentRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_CurrentRotationTypeIsPureCAV(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_SupportedWriteSpeeds(self: *const T, supportedSpeeds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeeds(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), supportedSpeeds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnce_get_SupportedWriteSpeedDescriptors(self: *const T, supportedSpeedDescriptors: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnce.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeedDescriptors(@as(*const IDiscFormat2TrackAtOnce, @ptrCast(self)), supportedSpeedDescriptors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2TrackAtOnceEvents_Value = Guid.initString("2735413f-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2TrackAtOnceEvents = &IID_DDiscFormat2TrackAtOnceEvents_Value;
pub const DDiscFormat2TrackAtOnceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DDiscFormat2TrackAtOnceEvents,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DDiscFormat2TrackAtOnceEvents,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2TrackAtOnceEvents_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const DDiscFormat2TrackAtOnceEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2TrackAtOnceEvents, @ptrCast(self)), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2TrackAtOnceEventArgs_Value = Guid.initString("27354140-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2TrackAtOnceEventArgs = &IID_IDiscFormat2TrackAtOnceEventArgs_Value;
pub const IDiscFormat2TrackAtOnceEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTrackNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2TrackAtOnceEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_CurrentTrackNumber(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentTrackNumber(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_CurrentAction(self: *const T, value: ?*IMAPI_FORMAT2_TAO_WRITE_ACTION) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentAction(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_ElapsedTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_ElapsedTime(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2TrackAtOnceEventArgs_get_RemainingTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2TrackAtOnceEventArgs.VTable, @ptrCast(self.vtable)).get_RemainingTime(@as(*const IDiscFormat2TrackAtOnceEventArgs, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2RawCD_Value = Guid.initString("27354155-8f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2RawCD = &IID_IDiscFormat2RawCD_Value;
pub const IDiscFormat2RawCD = extern struct {
    pub const VTable = extern struct {
        base: IDiscFormat2.VTable,
        PrepareMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2RawCD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMedia2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                data: ?*IStream,
                streamLeadInSectors: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                data: ?*IStream,
                streamLeadInSectors: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelWrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2RawCD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2RawCD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWriteSpeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                RequestedSectorsPerSecond: i32,
                RotationTypeIsPureCAV: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                RequestedSectorsPerSecond: i32,
                RotationTypeIsPureCAV: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Recorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferUnderrunFreeDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferUnderrunFreeDisabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfNextSession: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastPossibleStartOfLeadout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPhysicalMediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedSectorTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RequestedSectorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedSectorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClientName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedWriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RequestedRotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentWriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentRotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeeds: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                supportedSpeeds: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                supportedSpeeds: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedWriteSpeedDescriptors: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCD,
                supportedSpeedDescriptors: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCD,
                supportedSpeedDescriptors: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDiscFormat2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_PrepareMedia(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).PrepareMedia(@as(*const IDiscFormat2RawCD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_WriteMedia(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).WriteMedia(@as(*const IDiscFormat2RawCD, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_WriteMedia2(self: *const T, data: ?*IStream, streamLeadInSectors: i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).WriteMedia2(@as(*const IDiscFormat2RawCD, @ptrCast(self)), data, streamLeadInSectors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_CancelWrite(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).CancelWrite(@as(*const IDiscFormat2RawCD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_ReleaseMedia(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).ReleaseMedia(@as(*const IDiscFormat2RawCD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_SetWriteSpeed(self: *const T, RequestedSectorsPerSecond: i32, RotationTypeIsPureCAV: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).SetWriteSpeed(@as(*const IDiscFormat2RawCD, @ptrCast(self)), RequestedSectorsPerSecond, RotationTypeIsPureCAV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_Recorder(self: *const T, value: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_Recorder(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_Recorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_Recorder(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_BufferUnderrunFreeDisabled(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_BufferUnderrunFreeDisabled(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_BufferUnderrunFreeDisabled(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_StartOfNextSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_StartOfNextSession(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_LastPossibleStartOfLeadout(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_LastPossibleStartOfLeadout(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_CurrentPhysicalMediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_CurrentPhysicalMediaType(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_SupportedSectorTypes(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_SupportedSectorTypes(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_RequestedSectorType(self: *const T, value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_RequestedSectorType(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_RequestedSectorType(self: *const T, value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_RequestedSectorType(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_put_ClientName(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).put_ClientName(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_ClientName(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_ClientName(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_RequestedWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_RequestedWriteSpeed(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_RequestedRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_RequestedRotationTypeIsPureCAV(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_CurrentWriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_CurrentWriteSpeed(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_CurrentRotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_CurrentRotationTypeIsPureCAV(@as(*const IDiscFormat2RawCD, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_SupportedWriteSpeeds(self: *const T, supportedSpeeds: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeeds(@as(*const IDiscFormat2RawCD, @ptrCast(self)), supportedSpeeds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCD_get_SupportedWriteSpeedDescriptors(self: *const T, supportedSpeedDescriptors: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCD.VTable, @ptrCast(self.vtable)).get_SupportedWriteSpeedDescriptors(@as(*const IDiscFormat2RawCD, @ptrCast(self)), supportedSpeedDescriptors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DDiscFormat2RawCDEvents_Value = Guid.initString("27354142-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_DDiscFormat2RawCDEvents = &IID_DDiscFormat2RawCDEvents_Value;
pub const DDiscFormat2RawCDEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DDiscFormat2RawCDEvents,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DDiscFormat2RawCDEvents,
                object: ?*IDispatch,
                progress: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DDiscFormat2RawCDEvents_Update(self: *const T, object: ?*IDispatch, progress: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const DDiscFormat2RawCDEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DDiscFormat2RawCDEvents, @ptrCast(self)), object, progress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDiscFormat2RawCDEventArgs_Value = Guid.initString("27354143-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IDiscFormat2RawCDEventArgs = &IID_IDiscFormat2RawCDEventArgs_Value;
pub const IDiscFormat2RawCDEventArgs = extern struct {
    pub const VTable = extern struct {
        base: IWriteEngine2EventArgs.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCDEventArgs,
                value: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCDEventArgs,
                value: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ElapsedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCDEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCDEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RemainingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDiscFormat2RawCDEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDiscFormat2RawCDEventArgs,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWriteEngine2EventArgs.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCDEventArgs_get_CurrentAction(self: *const T, value: ?*IMAPI_FORMAT2_RAW_CD_WRITE_ACTION) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCDEventArgs.VTable, @ptrCast(self.vtable)).get_CurrentAction(@as(*const IDiscFormat2RawCDEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCDEventArgs_get_ElapsedTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCDEventArgs.VTable, @ptrCast(self.vtable)).get_ElapsedTime(@as(*const IDiscFormat2RawCDEventArgs, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscFormat2RawCDEventArgs_get_RemainingTime(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscFormat2RawCDEventArgs.VTable, @ptrCast(self.vtable)).get_RemainingTime(@as(*const IDiscFormat2RawCDEventArgs, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBurnVerification_Value = Guid.initString("d2ffd834-958b-426d-8470-2a13879c6a91");
pub const IID_IBurnVerification = &IID_IBurnVerification_Value;
pub const IBurnVerification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BurnVerificationLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBurnVerification,
                value: IMAPI_BURN_VERIFICATION_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBurnVerification,
                value: IMAPI_BURN_VERIFICATION_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BurnVerificationLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBurnVerification,
                value: ?*IMAPI_BURN_VERIFICATION_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBurnVerification,
                value: ?*IMAPI_BURN_VERIFICATION_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBurnVerification_put_BurnVerificationLevel(self: *const T, value: IMAPI_BURN_VERIFICATION_LEVEL) callconv(.Inline) HRESULT {
            return @as(*const IBurnVerification.VTable, @ptrCast(self.vtable)).put_BurnVerificationLevel(@as(*const IBurnVerification, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBurnVerification_get_BurnVerificationLevel(self: *const T, value: ?*IMAPI_BURN_VERIFICATION_LEVEL) callconv(.Inline) HRESULT {
            return @as(*const IBurnVerification.VTable, @ptrCast(self.vtable)).get_BurnVerificationLevel(@as(*const IBurnVerification, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWriteSpeedDescriptor_Value = Guid.initString("27354144-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IWriteSpeedDescriptor = &IID_IWriteSpeedDescriptor_Value;
pub const IWriteSpeedDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteSpeedDescriptor,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteSpeedDescriptor,
                value: ?*IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RotationTypeIsPureCAV: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteSpeedDescriptor,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteSpeedDescriptor,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IWriteSpeedDescriptor,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IWriteSpeedDescriptor,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteSpeedDescriptor_get_MediaType(self: *const T, value: ?*IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IWriteSpeedDescriptor.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const IWriteSpeedDescriptor, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteSpeedDescriptor_get_RotationTypeIsPureCAV(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IWriteSpeedDescriptor.VTable, @ptrCast(self.vtable)).get_RotationTypeIsPureCAV(@as(*const IWriteSpeedDescriptor, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWriteSpeedDescriptor_get_WriteSpeed(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IWriteSpeedDescriptor.VTable, @ptrCast(self.vtable)).get_WriteSpeed(@as(*const IWriteSpeedDescriptor, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMultisession_Value = Guid.initString("27354150-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IMultisession = &IID_IMultisession_Value;
pub const IMultisession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSupportedOnCurrentMediaState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisession,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisession,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InUse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisession,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisession,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InUse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisession,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisession,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImportRecorder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisession,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisession,
                value: ?*?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_get_IsSupportedOnCurrentMediaState(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).get_IsSupportedOnCurrentMediaState(@as(*const IMultisession, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_put_InUse(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).put_InUse(@as(*const IMultisession, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_get_InUse(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).get_InUse(@as(*const IMultisession, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisession_get_ImportRecorder(self: *const T, value: ?*?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IMultisession.VTable, @ptrCast(self.vtable)).get_ImportRecorder(@as(*const IMultisession, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMultisessionSequential_Value = Guid.initString("27354151-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IMultisessionSequential = &IID_IMultisessionSequential_Value;
pub const IMultisessionSequential = extern struct {
    pub const VTable = extern struct {
        base: IMultisession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFirstDataSession: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionSequential,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionSequential,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAddressOfPreviousSession: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddressOfPreviousSession: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextWritableAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionSequential,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultisession.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_IsFirstDataSession(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_IsFirstDataSession(@as(*const IMultisessionSequential, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_StartAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_StartAddressOfPreviousSession(@as(*const IMultisessionSequential, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_LastWrittenAddressOfPreviousSession(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_LastWrittenAddressOfPreviousSession(@as(*const IMultisessionSequential, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_NextWritableAddress(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_NextWritableAddress(@as(*const IMultisessionSequential, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential_get_FreeSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionSequential.VTable, @ptrCast(self.vtable)).get_FreeSectorsOnMedia(@as(*const IMultisessionSequential, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMultisessionSequential2_Value = Guid.initString("b507ca22-2204-11dd-966a-001aa01bbc58");
pub const IID_IMultisessionSequential2 = &IID_IMultisessionSequential2_Value;
pub const IMultisessionSequential2 = extern struct {
    pub const VTable = extern struct {
        base: IMultisessionSequential.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteUnitSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionSequential2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionSequential2,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultisessionSequential.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionSequential2_get_WriteUnitSize(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionSequential2.VTable, @ptrCast(self.vtable)).get_WriteUnitSize(@as(*const IMultisessionSequential2, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMultisessionRandomWrite_Value = Guid.initString("b507ca23-2204-11dd-966a-001aa01bbc58");
pub const IID_IMultisessionRandomWrite = &IID_IMultisessionRandomWrite_Value;
pub const IMultisessionRandomWrite = extern struct {
    pub const VTable = extern struct {
        base: IMultisession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WriteUnitSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionRandomWrite,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionRandomWrite,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWrittenAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionRandomWrite,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionRandomWrite,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalSectorsOnMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMultisessionRandomWrite,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMultisessionRandomWrite,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultisession.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionRandomWrite_get_WriteUnitSize(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionRandomWrite.VTable, @ptrCast(self.vtable)).get_WriteUnitSize(@as(*const IMultisessionRandomWrite, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionRandomWrite_get_LastWrittenAddress(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionRandomWrite.VTable, @ptrCast(self.vtable)).get_LastWrittenAddress(@as(*const IMultisessionRandomWrite, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultisessionRandomWrite_get_TotalSectorsOnMedia(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMultisessionRandomWrite.VTable, @ptrCast(self.vtable)).get_TotalSectorsOnMedia(@as(*const IMultisessionRandomWrite, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamPseudoRandomBased_Value = Guid.initString("27354145-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamPseudoRandomBased = &IID_IStreamPseudoRandomBased_Value;
pub const IStreamPseudoRandomBased = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Seed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStreamPseudoRandomBased,
                value: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStreamPseudoRandomBased,
                value: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Seed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStreamPseudoRandomBased,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStreamPseudoRandomBased,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExtendedSeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStreamPseudoRandomBased,
                values: [*]u32,
                eCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStreamPseudoRandomBased,
                values: [*]u32,
                eCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtendedSeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IStreamPseudoRandomBased,
                values: [*]?*u32,
                eCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IStreamPseudoRandomBased,
                values: [*]?*u32,
                eCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_put_Seed(self: *const T, value: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).put_Seed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_get_Seed(self: *const T, value: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).get_Seed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_put_ExtendedSeed(self: *const T, values: [*]u32, eCount: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).put_ExtendedSeed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), values, eCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamPseudoRandomBased_get_ExtendedSeed(self: *const T, values: [*]?*u32, eCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamPseudoRandomBased.VTable, @ptrCast(self.vtable)).get_ExtendedSeed(@as(*const IStreamPseudoRandomBased, @ptrCast(self)), values, eCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamConcatenate_Value = Guid.initString("27354146-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamConcatenate = &IID_IStreamConcatenate_Value;
pub const IStreamConcatenate = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamConcatenate,
                stream1: ?*IStream,
                stream2: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamConcatenate,
                stream1: ?*IStream,
                stream2: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamConcatenate,
                streams: [*]?*IStream,
                streamCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamConcatenate,
                streams: [*]?*IStream,
                streamCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Append: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamConcatenate,
                stream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamConcatenate,
                stream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Append2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamConcatenate,
                streams: [*]?*IStream,
                streamCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamConcatenate,
                streams: [*]?*IStream,
                streamCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Initialize(self: *const T, stream1: ?*IStream, stream2: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IStreamConcatenate, @ptrCast(self)), stream1, stream2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Initialize2(self: *const T, streams: [*]?*IStream, streamCount: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Initialize2(@as(*const IStreamConcatenate, @ptrCast(self)), streams, streamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Append(self: *const T, stream: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Append(@as(*const IStreamConcatenate, @ptrCast(self)), stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamConcatenate_Append2(self: *const T, streams: [*]?*IStream, streamCount: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamConcatenate.VTable, @ptrCast(self.vtable)).Append2(@as(*const IStreamConcatenate, @ptrCast(self)), streams, streamCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamInterleave_Value = Guid.initString("27354147-7f64-5b0f-8f00-5d77afbe261e");
pub const IID_IStreamInterleave = &IID_IStreamInterleave_Value;
pub const IStreamInterleave = extern struct {
    pub const VTable = extern struct {
        base: IStream.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamInterleave,
                streams: [*]?*IStream,
                interleaveSizes: [*]u32,
                streamCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamInterleave,
                streams: [*]?*IStream,
                interleaveSizes: [*]u32,
                streamCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamInterleave_Initialize(self: *const T, streams: [*]?*IStream, interleaveSizes: [*]u32, streamCount: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamInterleave.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IStreamInterleave, @ptrCast(self)), streams, interleaveSizes, streamCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRawCDImageCreator_Value = Guid.initString("25983550-9d65-49ce-b335-40630d901227");
pub const IID_IRawCDImageCreator = &IID_IRawCDImageCreator_Value;
pub const IRawCDImageCreator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateResultImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                resultStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawCDImageCreator,
                resultStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                dataType: IMAPI_CD_SECTOR_TYPE,
                data: ?*IStream,
                trackIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawCDImageCreator,
                dataType: IMAPI_CD_SECTOR_TYPE,
                data: ?*IStream,
                trackIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSpecialPregap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawCDImageCreator,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSubcodeRWGenerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                subcode: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawCDImageCreator,
                subcode: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResultingImageType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResultingImageType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfLeadout: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartOfLeadoutLimit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartOfLeadoutLimit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisableGaplessAudio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisableGaplessAudio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaCatalogNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaCatalogNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartingTrackNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingTrackNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                trackIndex: i32,
                value: ?*?*IRawCDImageTrackInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                trackIndex: i32,
                value: ?*?*IRawCDImageTrackInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfExistingTracks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastUsedUserSectorInImage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedTableOfContents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageCreator,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageCreator,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_CreateResultImage(self: *const T, resultStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).CreateResultImage(@as(*const IRawCDImageCreator, @ptrCast(self)), resultStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_AddTrack(self: *const T, dataType: IMAPI_CD_SECTOR_TYPE, data: ?*IStream, trackIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).AddTrack(@as(*const IRawCDImageCreator, @ptrCast(self)), dataType, data, trackIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_AddSpecialPregap(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).AddSpecialPregap(@as(*const IRawCDImageCreator, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_AddSubcodeRWGenerator(self: *const T, subcode: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).AddSubcodeRWGenerator(@as(*const IRawCDImageCreator, @ptrCast(self)), subcode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_ResultingImageType(self: *const T, value: IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_ResultingImageType(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_ResultingImageType(self: *const T, value: ?*IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_ResultingImageType(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_StartOfLeadout(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_StartOfLeadout(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_StartOfLeadoutLimit(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_StartOfLeadoutLimit(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_StartOfLeadoutLimit(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_StartOfLeadoutLimit(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_DisableGaplessAudio(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_DisableGaplessAudio(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_DisableGaplessAudio(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_DisableGaplessAudio(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_MediaCatalogNumber(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_MediaCatalogNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_MediaCatalogNumber(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_MediaCatalogNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_put_StartingTrackNumber(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).put_StartingTrackNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_StartingTrackNumber(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_StartingTrackNumber(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_TrackInfo(self: *const T, trackIndex: i32, value: ?*?*IRawCDImageTrackInfo) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_TrackInfo(@as(*const IRawCDImageCreator, @ptrCast(self)), trackIndex, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_NumberOfExistingTracks(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_NumberOfExistingTracks(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_LastUsedUserSectorInImage(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_LastUsedUserSectorInImage(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageCreator_get_ExpectedTableOfContents(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageCreator.VTable, @ptrCast(self.vtable)).get_ExpectedTableOfContents(@as(*const IRawCDImageCreator, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRawCDImageTrackInfo_Value = Guid.initString("25983551-9d65-49ce-b335-40630d901227");
pub const IID_IRawCDImageTrackInfo = &IID_IRawCDImageTrackInfo_Value;
pub const IRawCDImageTrackInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartingLba: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SectorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*IMAPI_CD_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*IMAPI_CD_SECTOR_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISRC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ISRC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DigitalAudioCopySetting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DigitalAudioCopySetting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioHasPreemphasis: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioHasPreemphasis: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrackIndexes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTrackIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                lbaOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                lbaOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearTrackIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawCDImageTrackInfo,
                lbaOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawCDImageTrackInfo,
                lbaOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_StartingLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_StartingLba(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_SectorCount(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_SectorCount(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_TrackNumber(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_TrackNumber(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_SectorType(self: *const T, value: ?*IMAPI_CD_SECTOR_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_SectorType(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_ISRC(self: *const T, value: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_ISRC(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_put_ISRC(self: *const T, value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).put_ISRC(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_DigitalAudioCopySetting(self: *const T, value: ?*IMAPI_CD_TRACK_DIGITAL_COPY_SETTING) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_DigitalAudioCopySetting(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_put_DigitalAudioCopySetting(self: *const T, value: IMAPI_CD_TRACK_DIGITAL_COPY_SETTING) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).put_DigitalAudioCopySetting(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_AudioHasPreemphasis(self: *const T, value: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_AudioHasPreemphasis(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_put_AudioHasPreemphasis(self: *const T, value: i16) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).put_AudioHasPreemphasis(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_get_TrackIndexes(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).get_TrackIndexes(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_AddTrackIndex(self: *const T, lbaOffset: i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).AddTrackIndex(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), lbaOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawCDImageTrackInfo_ClearTrackIndex(self: *const T, lbaOffset: i32) callconv(.Inline) HRESULT {
            return @as(*const IRawCDImageTrackInfo.VTable, @ptrCast(self.vtable)).ClearTrackIndex(@as(*const IRawCDImageTrackInfo, @ptrCast(self)), lbaOffset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBlockRange_Value = Guid.initString("b507ca25-2204-11dd-966a-001aa01bbc58");
pub const IID_IBlockRange = &IID_IBlockRange_Value;
pub const IBlockRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartLba: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBlockRange,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBlockRange,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EndLba: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBlockRange,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBlockRange,
                value: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockRange_get_StartLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBlockRange.VTable, @ptrCast(self.vtable)).get_StartLba(@as(*const IBlockRange, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockRange_get_EndLba(self: *const T, value: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBlockRange.VTable, @ptrCast(self.vtable)).get_EndLba(@as(*const IBlockRange, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBlockRangeList_Value = Guid.initString("b507ca26-2204-11dd-966a-001aa01bbc58");
pub const IID_IBlockRangeList = &IID_IBlockRangeList_Value;
pub const IBlockRangeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockRanges: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBlockRangeList,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBlockRangeList,
                value: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockRangeList_get_BlockRanges(self: *const T, value: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IBlockRangeList.VTable, @ptrCast(self.vtable)).get_BlockRanges(@as(*const IBlockRangeList, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_BootOptions_Value = Guid.initString("2c941fce-975b-59be-a960-9a2a262853a5");
pub const CLSID_BootOptions = &CLSID_BootOptions_Value;

const CLSID_FsiStream_Value = Guid.initString("2c941fcd-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiStream = &CLSID_FsiStream_Value;

const CLSID_FileSystemImageResult_Value = Guid.initString("2c941fcc-975b-59be-a960-9a2a262853a5");
pub const CLSID_FileSystemImageResult = &CLSID_FileSystemImageResult_Value;

const CLSID_ProgressItem_Value = Guid.initString("2c941fcb-975b-59be-a960-9a2a262853a5");
pub const CLSID_ProgressItem = &CLSID_ProgressItem_Value;

const CLSID_EnumProgressItems_Value = Guid.initString("2c941fca-975b-59be-a960-9a2a262853a5");
pub const CLSID_EnumProgressItems = &CLSID_EnumProgressItems_Value;

const CLSID_ProgressItems_Value = Guid.initString("2c941fc9-975b-59be-a960-9a2a262853a5");
pub const CLSID_ProgressItems = &CLSID_ProgressItems_Value;

const CLSID_FsiDirectoryItem_Value = Guid.initString("2c941fc8-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiDirectoryItem = &CLSID_FsiDirectoryItem_Value;

const CLSID_FsiFileItem_Value = Guid.initString("2c941fc7-975b-59be-a960-9a2a262853a5");
pub const CLSID_FsiFileItem = &CLSID_FsiFileItem_Value;

const CLSID_EnumFsiItems_Value = Guid.initString("2c941fc6-975b-59be-a960-9a2a262853a5");
pub const CLSID_EnumFsiItems = &CLSID_EnumFsiItems_Value;

const CLSID_FsiNamedStreams_Value = Guid.initString("c6b6f8ed-6d19-44b4-b539-b159b793a32d");
pub const CLSID_FsiNamedStreams = &CLSID_FsiNamedStreams_Value;

const CLSID_MsftFileSystemImage_Value = Guid.initString("2c941fc5-975b-59be-a960-9a2a262853a5");
pub const CLSID_MsftFileSystemImage = &CLSID_MsftFileSystemImage_Value;

const CLSID_MsftIsoImageManager_Value = Guid.initString("ceee3b62-8f56-4056-869b-ef16917e3efc");
pub const CLSID_MsftIsoImageManager = &CLSID_MsftIsoImageManager_Value;

const CLSID_BlockRange_Value = Guid.initString("b507ca27-2204-11dd-966a-001aa01bbc58");
pub const CLSID_BlockRange = &CLSID_BlockRange_Value;

const CLSID_BlockRangeList_Value = Guid.initString("b507ca28-2204-11dd-966a-001aa01bbc58");
pub const CLSID_BlockRangeList = &CLSID_BlockRangeList_Value;

pub const FsiItemType = enum(i32) {
    NotFound = 0,
    Directory = 1,
    File = 2,
};
pub const FsiItemNotFound = FsiItemType.NotFound;
pub const FsiItemDirectory = FsiItemType.Directory;
pub const FsiItemFile = FsiItemType.File;

pub const FsiFileSystems = enum(i32) {
    None = 0,
    ISO9660 = 1,
    Joliet = 2,
    UDF = 4,
    Unknown = 1073741824,
};
pub const FsiFileSystemNone = FsiFileSystems.None;
pub const FsiFileSystemISO9660 = FsiFileSystems.ISO9660;
pub const FsiFileSystemJoliet = FsiFileSystems.Joliet;
pub const FsiFileSystemUDF = FsiFileSystems.UDF;
pub const FsiFileSystemUnknown = FsiFileSystems.Unknown;

pub const EmulationType = enum(i32) {
    None = 0,
    @"12MFloppy" = 1,
    @"144MFloppy" = 2,
    @"288MFloppy" = 3,
    HardDisk = 4,
};
pub const EmulationNone = EmulationType.None;
pub const Emulation12MFloppy = EmulationType.@"12MFloppy";
pub const Emulation144MFloppy = EmulationType.@"144MFloppy";
pub const Emulation288MFloppy = EmulationType.@"288MFloppy";
pub const EmulationHardDisk = EmulationType.HardDisk;

pub const PlatformId = enum(i32) {
    X86 = 0,
    PowerPC = 1,
    Mac = 2,
    EFI = 239,
};
pub const PlatformX86 = PlatformId.X86;
pub const PlatformPowerPC = PlatformId.PowerPC;
pub const PlatformMac = PlatformId.Mac;
pub const PlatformEFI = PlatformId.EFI;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBootOptions_Value = Guid.initString("2c941fd4-975b-59be-a960-9a2a262853a5");
pub const IID_IBootOptions = &IID_IBootOptions_Value;
pub const IBootOptions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                pVal: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                pVal: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Manufacturer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Manufacturer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlatformId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                pVal: ?*PlatformId,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                pVal: ?*PlatformId,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlatformId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                newVal: PlatformId,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                newVal: PlatformId,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Emulation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                pVal: ?*EmulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                pVal: ?*EmulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Emulation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                newVal: EmulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                newVal: EmulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBootOptions,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBootOptions,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssignBootImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBootOptions,
                newVal: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBootOptions,
                newVal: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_BootImage(self: *const T, pVal: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_BootImage(@as(*const IBootOptions, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_Manufacturer(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_Manufacturer(@as(*const IBootOptions, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_put_Manufacturer(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).put_Manufacturer(@as(*const IBootOptions, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_PlatformId(self: *const T, pVal: ?*PlatformId) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_PlatformId(@as(*const IBootOptions, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_put_PlatformId(self: *const T, newVal: PlatformId) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).put_PlatformId(@as(*const IBootOptions, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_Emulation(self: *const T, pVal: ?*EmulationType) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_Emulation(@as(*const IBootOptions, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_put_Emulation(self: *const T, newVal: EmulationType) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).put_Emulation(@as(*const IBootOptions, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_get_ImageSize(self: *const T, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).get_ImageSize(@as(*const IBootOptions, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBootOptions_AssignBootImage(self: *const T, newVal: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IBootOptions.VTable, @ptrCast(self.vtable)).AssignBootImage(@as(*const IBootOptions, @ptrCast(self)), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProgressItem_Value = Guid.initString("2c941fd5-975b-59be-a960-9a2a262853a5");
pub const IID_IProgressItem = &IID_IProgressItem_Value;
pub const IProgressItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItem,
                desc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItem,
                desc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FirstBlock: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItem,
                block: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItem,
                block: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBlock: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItem,
                block: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItem,
                block: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItem,
                blocks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItem,
                blocks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_Description(self: *const T, desc: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IProgressItem, @ptrCast(self)), desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_FirstBlock(self: *const T, block: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_FirstBlock(@as(*const IProgressItem, @ptrCast(self)), block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_LastBlock(self: *const T, block: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_LastBlock(@as(*const IProgressItem, @ptrCast(self)), block);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItem_get_BlockCount(self: *const T, blocks: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IProgressItem.VTable, @ptrCast(self.vtable)).get_BlockCount(@as(*const IProgressItem, @ptrCast(self)), blocks);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumProgressItems_Value = Guid.initString("2c941fd6-975b-59be-a960-9a2a262853a5");
pub const IID_IEnumProgressItems = &IID_IEnumProgressItems_Value;
pub const IEnumProgressItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumProgressItems,
                celt: u32,
                rgelt: [*]?*IProgressItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumProgressItems,
                celt: u32,
                rgelt: [*]?*IProgressItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumProgressItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumProgressItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumProgressItems,
                ppEnum: ?*?*IEnumProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumProgressItems,
                ppEnum: ?*?*IEnumProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Next(self: *const T, celt: u32, rgelt: [*]?*IProgressItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumProgressItems, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumProgressItems, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumProgressItems, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumProgressItems_Clone(self: *const T, ppEnum: ?*?*IEnumProgressItems) callconv(.Inline) HRESULT {
            return @as(*const IEnumProgressItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumProgressItems, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IProgressItems_Value = Guid.initString("2c941fd7-975b-59be-a960-9a2a262853a5");
pub const IID_IProgressItems = &IID_IProgressItems_Value;
pub const IProgressItems = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItems,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItems,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItems,
                Index: i32,
                item: ?*?*IProgressItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItems,
                Index: i32,
                item: ?*?*IProgressItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItems,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItems,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProgressItemFromBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProgressItems,
                block: u32,
                item: ?*?*IProgressItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProgressItems,
                block: u32,
                item: ?*?*IProgressItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProgressItemFromDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProgressItems,
                description: ?BSTR,
                item: ?*?*IProgressItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProgressItems,
                description: ?BSTR,
                item: ?*?*IProgressItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumProgressItems: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IProgressItems,
                NewEnum: ?*?*IEnumProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IProgressItems,
                NewEnum: ?*?*IEnumProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IProgressItems, @ptrCast(self)), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get_Item(self: *const T, Index: i32, item: ?*?*IProgressItem) callconv(.Inline) HRESULT {
            return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IProgressItems, @ptrCast(self)), Index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IProgressItems, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_ProgressItemFromBlock(self: *const T, block: u32, item: ?*?*IProgressItem) callconv(.Inline) HRESULT {
            return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).ProgressItemFromBlock(@as(*const IProgressItems, @ptrCast(self)), block, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_ProgressItemFromDescription(self: *const T, description: ?BSTR, item: ?*?*IProgressItem) callconv(.Inline) HRESULT {
            return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).ProgressItemFromDescription(@as(*const IProgressItems, @ptrCast(self)), description, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProgressItems_get_EnumProgressItems(self: *const T, NewEnum: ?*?*IEnumProgressItems) callconv(.Inline) HRESULT {
            return @as(*const IProgressItems.VTable, @ptrCast(self.vtable)).get_EnumProgressItems(@as(*const IProgressItems, @ptrCast(self)), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImageResult_Value = Guid.initString("2c941fd8-975b-59be-a960-9a2a262853a5");
pub const IID_IFileSystemImageResult = &IID_IFileSystemImageResult_Value;
pub const IFileSystemImageResult = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImageResult,
                pVal: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImageResult,
                pVal: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgressItems: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImageResult,
                pVal: ?*?*IProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImageResult,
                pVal: ?*?*IProgressItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalBlocks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImageResult,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImageResult,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImageResult,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImageResult,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiscId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImageResult,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImageResult,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_ImageStream(self: *const T, pVal: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_ImageStream(@as(*const IFileSystemImageResult, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_ProgressItems(self: *const T, pVal: ?*?*IProgressItems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_ProgressItems(@as(*const IFileSystemImageResult, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_TotalBlocks(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_TotalBlocks(@as(*const IFileSystemImageResult, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_BlockSize(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_BlockSize(@as(*const IFileSystemImageResult, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult_get_DiscId(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImageResult.VTable, @ptrCast(self.vtable)).get_DiscId(@as(*const IFileSystemImageResult, @ptrCast(self)), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IFileSystemImageResult2_Value = Guid.initString("b507ca29-2204-11dd-966a-001aa01bbc58");
pub const IID_IFileSystemImageResult2 = &IID_IFileSystemImageResult2_Value;
pub const IFileSystemImageResult2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImageResult.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifiedBlocks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImageResult2,
                pVal: ?*?*IBlockRangeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImageResult2,
                pVal: ?*?*IBlockRangeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemImageResult.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImageResult2_get_ModifiedBlocks(self: *const T, pVal: ?*?*IBlockRangeList) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImageResult2.VTable, @ptrCast(self.vtable)).get_ModifiedBlocks(@as(*const IFileSystemImageResult2, @ptrCast(self)), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiItem_Value = Guid.initString("2c941fd9-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiItem = &IID_IFsiItem_Value;
pub const IFsiItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullPath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                pVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                pVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreationTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                newVal: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                newVal: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastAccessedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                pVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                pVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LastAccessedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                newVal: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                newVal: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastModifiedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                pVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                pVal: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LastModifiedTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                newVal: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                newVal: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsHidden: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsHidden: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiItem,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiItem,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FileSystemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiItem,
                fileSystem: FsiFileSystems,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiItem,
                fileSystem: FsiFileSystems,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FileSystemPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiItem,
                fileSystem: FsiFileSystems,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiItem,
                fileSystem: FsiFileSystems,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_Name(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFsiItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_FullPath(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_FullPath(@as(*const IFsiItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_CreationTime(self: *const T, pVal: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_CreationTime(@as(*const IFsiItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_CreationTime(self: *const T, newVal: f64) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_CreationTime(@as(*const IFsiItem, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_LastAccessedTime(self: *const T, pVal: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_LastAccessedTime(@as(*const IFsiItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_LastAccessedTime(self: *const T, newVal: f64) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_LastAccessedTime(@as(*const IFsiItem, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_LastModifiedTime(self: *const T, pVal: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_LastModifiedTime(@as(*const IFsiItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_LastModifiedTime(self: *const T, newVal: f64) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_LastModifiedTime(@as(*const IFsiItem, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_get_IsHidden(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).get_IsHidden(@as(*const IFsiItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_put_IsHidden(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).put_IsHidden(@as(*const IFsiItem, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_FileSystemName(self: *const T, fileSystem: FsiFileSystems, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).FileSystemName(@as(*const IFsiItem, @ptrCast(self)), fileSystem, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiItem_FileSystemPath(self: *const T, fileSystem: FsiFileSystems, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiItem.VTable, @ptrCast(self.vtable)).FileSystemPath(@as(*const IFsiItem, @ptrCast(self)), fileSystem, pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumFsiItems_Value = Guid.initString("2c941fda-975b-59be-a960-9a2a262853a5");
pub const IID_IEnumFsiItems = &IID_IEnumFsiItems_Value;
pub const IEnumFsiItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFsiItems,
                celt: u32,
                rgelt: [*]?*IFsiItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFsiItems,
                celt: u32,
                rgelt: [*]?*IFsiItem,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFsiItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFsiItems,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFsiItems,
                ppEnum: ?*?*IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFsiItems,
                ppEnum: ?*?*IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Next(self: *const T, celt: u32, rgelt: [*]?*IFsiItem, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFsiItems, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFsiItems, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFsiItems, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFsiItems_Clone(self: *const T, ppEnum: ?*?*IEnumFsiItems) callconv(.Inline) HRESULT {
            return @as(*const IEnumFsiItems.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFsiItems, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiFileItem_Value = Guid.initString("2c941fdb-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiFileItem = &IID_IFsiFileItem_Value;
pub const IFsiFileItem = extern struct {
    pub const VTable = extern struct {
        base: IFsiItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem,
                pVal: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem,
                pVal: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize32BitLow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataSize32BitHigh: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem,
                pVal: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem,
                pVal: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Data: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem,
                newVal: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem,
                newVal: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_DataSize(self: *const T, pVal: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_DataSize(@as(*const IFsiFileItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_DataSize32BitLow(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_DataSize32BitLow(@as(*const IFsiFileItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_DataSize32BitHigh(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_DataSize32BitHigh(@as(*const IFsiFileItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_get_Data(self: *const T, pVal: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).get_Data(@as(*const IFsiFileItem, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem_put_Data(self: *const T, newVal: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem.VTable, @ptrCast(self.vtable)).put_Data(@as(*const IFsiFileItem, @ptrCast(self)), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiFileItem2_Value = Guid.initString("199d0c19-11e1-40eb-8ec2-c8c822a07792");
pub const IID_IFsiFileItem2 = &IID_IFsiFileItem2_Value;
pub const IFsiFileItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFsiFileItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FsiNamedStreams: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem2,
                streams: ?*?*IFsiNamedStreams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem2,
                streams: ?*?*IFsiNamedStreams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsNamedStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem2,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem2,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiFileItem2,
                name: ?BSTR,
                streamData: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiFileItem2,
                name: ?BSTR,
                streamData: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiFileItem2,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiFileItem2,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRealTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem2,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem2,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsRealTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiFileItem2,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiFileItem2,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiFileItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_get_FsiNamedStreams(self: *const T, streams: ?*?*IFsiNamedStreams) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).get_FsiNamedStreams(@as(*const IFsiFileItem2, @ptrCast(self)), streams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_get_IsNamedStream(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).get_IsNamedStream(@as(*const IFsiFileItem2, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_AddStream(self: *const T, name: ?BSTR, streamData: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IFsiFileItem2, @ptrCast(self)), name, streamData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_RemoveStream(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IFsiFileItem2, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_get_IsRealTime(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).get_IsRealTime(@as(*const IFsiFileItem2, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiFileItem2_put_IsRealTime(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiFileItem2.VTable, @ptrCast(self.vtable)).put_IsRealTime(@as(*const IFsiFileItem2, @ptrCast(self)), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiNamedStreams_Value = Guid.initString("ed79ba56-5294-4250-8d46-f9aecee23459");
pub const IID_IFsiNamedStreams = &IID_IFsiNamedStreams_Value;
pub const IFsiNamedStreams = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiNamedStreams,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiNamedStreams,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiNamedStreams,
                index: i32,
                item: ?*?*IFsiFileItem2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiNamedStreams,
                index: i32,
                item: ?*?*IFsiFileItem2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiNamedStreams,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiNamedStreams,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumNamedStreams: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiNamedStreams,
                NewEnum: ?*?*IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiNamedStreams,
                NewEnum: ?*?*IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IFsiNamedStreams, @ptrCast(self)), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get_Item(self: *const T, index: i32, item: ?*?*IFsiFileItem2) callconv(.Inline) HRESULT {
            return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IFsiNamedStreams, @ptrCast(self)), index, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get_Count(self: *const T, count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IFsiNamedStreams, @ptrCast(self)), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiNamedStreams_get_EnumNamedStreams(self: *const T, NewEnum: ?*?*IEnumFsiItems) callconv(.Inline) HRESULT {
            return @as(*const IFsiNamedStreams.VTable, @ptrCast(self.vtable)).get_EnumNamedStreams(@as(*const IFsiNamedStreams, @ptrCast(self)), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiDirectoryItem_Value = Guid.initString("2c941fdc-975b-59be-a960-9a2a262853a5");
pub const IID_IFsiDirectoryItem = &IID_IFsiDirectoryItem_Value;
pub const IFsiDirectoryItem = extern struct {
    pub const VTable = extern struct {
        base: IFsiItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiDirectoryItem,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
                item: ?*?*IFsiItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
                item: ?*?*IFsiItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiDirectoryItem,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumFsiItems: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                NewEnum: ?*?*IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFsiDirectoryItem,
                NewEnum: ?*?*IEnumFsiItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
                fileData: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
                fileData: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTree: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                sourceDirectory: ?BSTR,
                includeBaseDirectory: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem,
                sourceDirectory: ?BSTR,
                includeBaseDirectory: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                item: ?*IFsiItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem,
                item: ?*IFsiItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTree: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IFsiDirectoryItem, @ptrCast(self)), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get_Item(self: *const T, path: ?BSTR, item: ?*?*IFsiItem) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IFsiDirectoryItem, @ptrCast(self)), path, item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IFsiDirectoryItem, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_get_EnumFsiItems(self: *const T, NewEnum: ?*?*IEnumFsiItems) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).get_EnumFsiItems(@as(*const IFsiDirectoryItem, @ptrCast(self)), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_AddDirectory(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).AddDirectory(@as(*const IFsiDirectoryItem, @ptrCast(self)), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_AddFile(self: *const T, path: ?BSTR, fileData: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).AddFile(@as(*const IFsiDirectoryItem, @ptrCast(self)), path, fileData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_AddTree(self: *const T, sourceDirectory: ?BSTR, includeBaseDirectory: i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).AddTree(@as(*const IFsiDirectoryItem, @ptrCast(self)), sourceDirectory, includeBaseDirectory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_Add(self: *const T, item: ?*IFsiItem) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).Add(@as(*const IFsiDirectoryItem, @ptrCast(self)), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_Remove(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).Remove(@as(*const IFsiDirectoryItem, @ptrCast(self)), path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem_RemoveTree(self: *const T, path: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem.VTable, @ptrCast(self.vtable)).RemoveTree(@as(*const IFsiDirectoryItem, @ptrCast(self)), path);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFsiDirectoryItem2_Value = Guid.initString("f7fb4b9b-6d96-4d7b-9115-201b144811ef");
pub const IID_IFsiDirectoryItem2 = &IID_IFsiDirectoryItem2_Value;
pub const IFsiDirectoryItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFsiDirectoryItem.VTable,
        AddTreeWithNamedStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFsiDirectoryItem2,
                sourceDirectory: ?BSTR,
                includeBaseDirectory: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFsiDirectoryItem2,
                sourceDirectory: ?BSTR,
                includeBaseDirectory: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFsiDirectoryItem.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFsiDirectoryItem2_AddTreeWithNamedStreams(self: *const T, sourceDirectory: ?BSTR, includeBaseDirectory: i16) callconv(.Inline) HRESULT {
            return @as(*const IFsiDirectoryItem2.VTable, @ptrCast(self.vtable)).AddTreeWithNamedStreams(@as(*const IFsiDirectoryItem2, @ptrCast(self)), sourceDirectory, includeBaseDirectory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage_Value = Guid.initString("2c941fe1-975b-59be-a960-9a2a262853a5");
pub const IID_IFileSystemImage = &IID_IFileSystemImage_Value;
pub const IFileSystemImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Root: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?*IFsiDirectoryItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?*IFsiDirectoryItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionStartBlock: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SessionStartBlock: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FreeMediaBlocks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FreeMediaBlocks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxMediaBlocksFromDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                discRecorder: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                discRecorder: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsedBlocks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VolumeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImportedVolumeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImageOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?*IBootOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?*IBootOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BootImageOptions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: ?*IBootOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: ?*IBootOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DirectoryCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WorkingDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WorkingDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChangePoint: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StrictFileSystemCompliance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StrictFileSystemCompliance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseRestrictedCharacterSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseRestrictedCharacterSet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileSystemsToCreate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileSystemsToCreate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileSystemsSupported: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UDFRevision: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UDFRevision: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UDFRevisionsSupported: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChooseImageDefaults: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                discRecorder: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                discRecorder: ?*IDiscRecorder2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChooseImageDefaultsForMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                value: IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                value: IMAPI_MEDIA_PHYSICAL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ISO9660InterchangeLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISO9660InterchangeLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ISO9660InterchangeLevelsSupported: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateResultImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                resultStream: ?*?*IFileSystemImageResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                resultStream: ?*?*IFileSystemImageResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exists: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                fullPath: ?BSTR,
                itemType: ?*FsiItemType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                fullPath: ?BSTR,
                itemType: ?*FsiItemType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CalculateDiscIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                discIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                discIdentifier: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IdentifyFileSystemsOnDisc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                discRecorder: ?*IDiscRecorder2,
                fileSystems: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                discRecorder: ?*IDiscRecorder2,
                fileSystems: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultFileSystemForImport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                fileSystems: FsiFileSystems,
                importDefault: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                fileSystems: FsiFileSystems,
                importDefault: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ImportFileSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                importedFileSystem: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                importedFileSystem: ?*FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ImportSpecificFileSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                fileSystemToUse: FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                fileSystemToUse: FsiFileSystems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RollbackToChangePoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                changePoint: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                changePoint: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockInChangePoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDirectoryItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                name: ?BSTR,
                newItem: ?*?*IFsiDirectoryItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                name: ?BSTR,
                newItem: ?*?*IFsiDirectoryItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateFileItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage,
                name: ?BSTR,
                newItem: ?*?*IFsiFileItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage,
                name: ?BSTR,
                newItem: ?*?*IFsiFileItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameUDF: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameJoliet: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumeNameISO9660: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StageFiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StageFiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MultisessionInterfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MultisessionInterfaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage,
                newVal: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage,
                newVal: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_Root(self: *const T, pVal: ?*?*IFsiDirectoryItem) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_Root(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_SessionStartBlock(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_SessionStartBlock(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_SessionStartBlock(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_SessionStartBlock(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FreeMediaBlocks(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FreeMediaBlocks(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_FreeMediaBlocks(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_FreeMediaBlocks(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_SetMaxMediaBlocksFromDevice(self: *const T, discRecorder: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).SetMaxMediaBlocksFromDevice(@as(*const IFileSystemImage, @ptrCast(self)), discRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UsedBlocks(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UsedBlocks(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeName(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_VolumeName(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_VolumeName(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ImportedVolumeName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ImportedVolumeName(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_BootImageOptions(self: *const T, pVal: ?*?*IBootOptions) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_BootImageOptions(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_BootImageOptions(self: *const T, newVal: ?*IBootOptions) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_BootImageOptions(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FileCount(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FileCount(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_DirectoryCount(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_DirectoryCount(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_WorkingDirectory(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_WorkingDirectory(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_WorkingDirectory(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_WorkingDirectory(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ChangePoint(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ChangePoint(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_StrictFileSystemCompliance(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_StrictFileSystemCompliance(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_StrictFileSystemCompliance(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_StrictFileSystemCompliance(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UseRestrictedCharacterSet(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UseRestrictedCharacterSet(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_UseRestrictedCharacterSet(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_UseRestrictedCharacterSet(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FileSystemsToCreate(self: *const T, pVal: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FileSystemsToCreate(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_FileSystemsToCreate(self: *const T, newVal: FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_FileSystemsToCreate(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_FileSystemsSupported(self: *const T, pVal: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_FileSystemsSupported(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_UDFRevision(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_UDFRevision(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UDFRevision(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UDFRevision(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_UDFRevisionsSupported(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_UDFRevisionsSupported(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ChooseImageDefaults(self: *const T, discRecorder: ?*IDiscRecorder2) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ChooseImageDefaults(@as(*const IFileSystemImage, @ptrCast(self)), discRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ChooseImageDefaultsForMediaType(self: *const T, value: IMAPI_MEDIA_PHYSICAL_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ChooseImageDefaultsForMediaType(@as(*const IFileSystemImage, @ptrCast(self)), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_ISO9660InterchangeLevel(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_ISO9660InterchangeLevel(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ISO9660InterchangeLevel(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ISO9660InterchangeLevel(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_ISO9660InterchangeLevelsSupported(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_ISO9660InterchangeLevelsSupported(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CreateResultImage(self: *const T, resultStream: ?*?*IFileSystemImageResult) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CreateResultImage(@as(*const IFileSystemImage, @ptrCast(self)), resultStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_Exists(self: *const T, fullPath: ?BSTR, itemType: ?*FsiItemType) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).Exists(@as(*const IFileSystemImage, @ptrCast(self)), fullPath, itemType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CalculateDiscIdentifier(self: *const T, discIdentifier: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CalculateDiscIdentifier(@as(*const IFileSystemImage, @ptrCast(self)), discIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_IdentifyFileSystemsOnDisc(self: *const T, discRecorder: ?*IDiscRecorder2, fileSystems: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).IdentifyFileSystemsOnDisc(@as(*const IFileSystemImage, @ptrCast(self)), discRecorder, fileSystems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_GetDefaultFileSystemForImport(self: *const T, fileSystems: FsiFileSystems, importDefault: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).GetDefaultFileSystemForImport(@as(*const IFileSystemImage, @ptrCast(self)), fileSystems, importDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ImportFileSystem(self: *const T, importedFileSystem: ?*FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ImportFileSystem(@as(*const IFileSystemImage, @ptrCast(self)), importedFileSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_ImportSpecificFileSystem(self: *const T, fileSystemToUse: FsiFileSystems) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).ImportSpecificFileSystem(@as(*const IFileSystemImage, @ptrCast(self)), fileSystemToUse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_RollbackToChangePoint(self: *const T, changePoint: i32) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).RollbackToChangePoint(@as(*const IFileSystemImage, @ptrCast(self)), changePoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_LockInChangePoint(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).LockInChangePoint(@as(*const IFileSystemImage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CreateDirectoryItem(self: *const T, name: ?BSTR, newItem: ?*?*IFsiDirectoryItem) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CreateDirectoryItem(@as(*const IFileSystemImage, @ptrCast(self)), name, newItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_CreateFileItem(self: *const T, name: ?BSTR, newItem: ?*?*IFsiFileItem) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).CreateFileItem(@as(*const IFileSystemImage, @ptrCast(self)), name, newItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeNameUDF(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeNameUDF(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeNameJoliet(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeNameJoliet(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_VolumeNameISO9660(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_VolumeNameISO9660(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_StageFiles(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_StageFiles(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_StageFiles(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_StageFiles(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_get_MultisessionInterfaces(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).get_MultisessionInterfaces(@as(*const IFileSystemImage, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage_put_MultisessionInterfaces(self: *const T, newVal: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage.VTable, @ptrCast(self.vtable)).put_MultisessionInterfaces(@as(*const IFileSystemImage, @ptrCast(self)), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage2_Value = Guid.initString("d7644b2c-1537-4767-b62f-f1387b02ddfd");
pub const IID_IFileSystemImage2 = &IID_IFileSystemImage2_Value;
pub const IFileSystemImage2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImage.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BootImageOptionsArray: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage2,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage2,
                pVal: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BootImageOptionsArray: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage2,
                newVal: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage2,
                newVal: ?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemImage.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage2_get_BootImageOptionsArray(self: *const T, pVal: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage2.VTable, @ptrCast(self.vtable)).get_BootImageOptionsArray(@as(*const IFileSystemImage2, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage2_put_BootImageOptionsArray(self: *const T, newVal: ?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage2.VTable, @ptrCast(self.vtable)).put_BootImageOptionsArray(@as(*const IFileSystemImage2, @ptrCast(self)), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFileSystemImage3_Value = Guid.initString("7cff842c-7e97-4807-8304-910dd8f7c051");
pub const IID_IFileSystemImage3 = &IID_IFileSystemImage3_Value;
pub const IFileSystemImage3 = extern struct {
    pub const VTable = extern struct {
        base: IFileSystemImage2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreateRedundantUdfMetadataFiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage3,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage3,
                pVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CreateRedundantUdfMetadataFiles: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFileSystemImage3,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFileSystemImage3,
                newVal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProbeSpecificFileSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSystemImage3,
                fileSystemToProbe: FsiFileSystems,
                isAppendable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSystemImage3,
                fileSystemToProbe: FsiFileSystems,
                isAppendable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSystemImage2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage3_get_CreateRedundantUdfMetadataFiles(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage3.VTable, @ptrCast(self.vtable)).get_CreateRedundantUdfMetadataFiles(@as(*const IFileSystemImage3, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage3_put_CreateRedundantUdfMetadataFiles(self: *const T, newVal: i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage3.VTable, @ptrCast(self.vtable)).put_CreateRedundantUdfMetadataFiles(@as(*const IFileSystemImage3, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSystemImage3_ProbeSpecificFileSystem(self: *const T, fileSystemToProbe: FsiFileSystems, isAppendable: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IFileSystemImage3.VTable, @ptrCast(self.vtable)).ProbeSpecificFileSystem(@as(*const IFileSystemImage3, @ptrCast(self)), fileSystemToProbe, isAppendable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DFileSystemImageEvents_Value = Guid.initString("2c941fdf-975b-59be-a960-9a2a262853a5");
pub const IID_DFileSystemImageEvents = &IID_DFileSystemImageEvents_Value;
pub const DFileSystemImageEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DFileSystemImageEvents,
                object: ?*IDispatch,
                currentFile: ?BSTR,
                copiedSectors: i32,
                totalSectors: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DFileSystemImageEvents,
                object: ?*IDispatch,
                currentFile: ?BSTR,
                copiedSectors: i32,
                totalSectors: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DFileSystemImageEvents_Update(self: *const T, object: ?*IDispatch, currentFile: ?BSTR, copiedSectors: i32, totalSectors: i32) callconv(.Inline) HRESULT {
            return @as(*const DFileSystemImageEvents.VTable, @ptrCast(self.vtable)).Update(@as(*const DFileSystemImageEvents, @ptrCast(self)), object, currentFile, copiedSectors, totalSectors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_DFileSystemImageImportEvents_Value = Guid.initString("d25c30f9-4087-4366-9e24-e55be286424b");
pub const IID_DFileSystemImageImportEvents = &IID_DFileSystemImageImportEvents_Value;
pub const DFileSystemImageImportEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        UpdateImport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const DFileSystemImageImportEvents,
                object: ?*IDispatch,
                fileSystem: FsiFileSystems,
                currentItem: ?BSTR,
                importedDirectoryItems: i32,
                totalDirectoryItems: i32,
                importedFileItems: i32,
                totalFileItems: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const DFileSystemImageImportEvents,
                object: ?*IDispatch,
                fileSystem: FsiFileSystems,
                currentItem: ?BSTR,
                importedDirectoryItems: i32,
                totalDirectoryItems: i32,
                importedFileItems: i32,
                totalFileItems: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn DFileSystemImageImportEvents_UpdateImport(self: *const T, object: ?*IDispatch, fileSystem: FsiFileSystems, currentItem: ?BSTR, importedDirectoryItems: i32, totalDirectoryItems: i32, importedFileItems: i32, totalFileItems: i32) callconv(.Inline) HRESULT {
            return @as(*const DFileSystemImageImportEvents.VTable, @ptrCast(self.vtable)).UpdateImport(@as(*const DFileSystemImageImportEvents, @ptrCast(self)), object, fileSystem, currentItem, importedDirectoryItems, totalDirectoryItems, importedFileItems, totalFileItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IIsoImageManager_Value = Guid.initString("6ca38be5-fbbb-4800-95a1-a438865eb0d4");
pub const IID_IIsoImageManager = &IID_IIsoImageManager_Value;
pub const IIsoImageManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IIsoImageManager,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IIsoImageManager,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IIsoImageManager,
                data: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IIsoImageManager,
                data: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsoImageManager,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsoImageManager,
                Val: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsoImageManager,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsoImageManager,
                data: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Validate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsoImageManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsoImageManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_get_Path(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IIsoImageManager, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_get_Stream(self: *const T, data: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).get_Stream(@as(*const IIsoImageManager, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_SetPath(self: *const T, Val: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IIsoImageManager, @ptrCast(self)), Val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_SetStream(self: *const T, data: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).SetStream(@as(*const IIsoImageManager, @ptrCast(self)), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsoImageManager_Validate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IIsoImageManager.VTable, @ptrCast(self.vtable)).Validate(@as(*const IIsoImageManager, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSDiscRecorderObj_Value = Guid.initString("520cca61-51a5-11d3-9144-00104ba11c5e");
pub const CLSID_MSDiscRecorderObj = &CLSID_MSDiscRecorderObj_Value;

const CLSID_MSDiscMasterObj_Value = Guid.initString("520cca63-51a5-11d3-9144-00104ba11c5e");
pub const CLSID_MSDiscMasterObj = &CLSID_MSDiscMasterObj_Value;

const CLSID_MSEnumDiscRecordersObj_Value = Guid.initString("8a03567a-63cb-4ba8-baf6-52119816d1ef");
pub const CLSID_MSEnumDiscRecordersObj = &CLSID_MSEnumDiscRecordersObj_Value;

pub const MEDIA_TYPES = enum(i32) {
    CDDA_CDROM = 1,
    CD_ROM_XA = 2,
    CD_I = 3,
    CD_EXTRA = 4,
    CD_OTHER = 5,
    SPECIAL = 6,
};
pub const MEDIA_CDDA_CDROM = MEDIA_TYPES.CDDA_CDROM;
pub const MEDIA_CD_ROM_XA = MEDIA_TYPES.CD_ROM_XA;
pub const MEDIA_CD_I = MEDIA_TYPES.CD_I;
pub const MEDIA_CD_EXTRA = MEDIA_TYPES.CD_EXTRA;
pub const MEDIA_CD_OTHER = MEDIA_TYPES.CD_OTHER;
pub const MEDIA_SPECIAL = MEDIA_TYPES.SPECIAL;

pub const MEDIA_FLAGS = enum(i32) {
    BLANK = 1,
    RW = 2,
    WRITABLE = 4,
    FORMAT_UNUSABLE_BY_IMAPI = 8,
};
pub const MEDIA_BLANK = MEDIA_FLAGS.BLANK;
pub const MEDIA_RW = MEDIA_FLAGS.RW;
pub const MEDIA_WRITABLE = MEDIA_FLAGS.WRITABLE;
pub const MEDIA_FORMAT_UNUSABLE_BY_IMAPI = MEDIA_FLAGS.FORMAT_UNUSABLE_BY_IMAPI;

pub const RECORDER_TYPES = enum(i32) {
    R = 1,
    W = 2,
};
pub const RECORDER_CDR = RECORDER_TYPES.R;
pub const RECORDER_CDRW = RECORDER_TYPES.W;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscRecorder_Value = Guid.initString("85ac9776-ca88-4cf2-894e-09598c078a41");
pub const IID_IDiscRecorder = &IID_IDiscRecorder_Value;
pub const IDiscRecorder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pbyUniqueID: [*:0]u8,
                nulIDSize: u32,
                nulDriveNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pbyUniqueID: [*:0]u8,
                nulIDSize: u32,
                nulDriveNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecorderGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pbyUniqueID: ?[*:0]u8,
                ulBufferSize: u32,
                pulReturnSizeRequired: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pbyUniqueID: ?[*:0]u8,
                ulBufferSize: u32,
                pulReturnSizeRequired: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecorderType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                fTypeCode: ?*RECORDER_TYPES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                fTypeCode: ?*RECORDER_TYPES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pbstrVendorID: ?*?BSTR,
                pbstrProductID: ?*?BSTR,
                pbstrRevision: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pbstrVendorID: ?*?BSTR,
                pbstrProductID: ?*?BSTR,
                pbstrRevision: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBasePnPID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pbstrBasePnPID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pbstrBasePnPID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pbstrPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pbstrPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecorderProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                ppPropStg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                ppPropStg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecorderProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pPropStg: ?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pPropStg: ?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecorderState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pulDevStateFlags: ?*DISC_RECORDER_STATE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pulDevStateFlags: ?*DISC_RECORDER_STATE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenExclusive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                fMediaType: ?*MEDIA_TYPES,
                fMediaFlags: ?*MEDIA_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                fMediaType: ?*MEDIA_TYPES,
                fMediaFlags: ?*MEDIA_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryMediaInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                pbSessions: ?*u8,
                pbLastTrack: ?*u8,
                ulStartAddress: ?*u32,
                ulNextWritable: ?*u32,
                ulFreeBlocks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                pbSessions: ?*u8,
                pbLastTrack: ?*u8,
                ulStartAddress: ?*u32,
                ulNextWritable: ?*u32,
                ulFreeBlocks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Eject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Erase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
                bFullErase: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
                bFullErase: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Init(self: *const T, pbyUniqueID: [*:0]u8, nulIDSize: u32, nulDriveNumber: u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Init(@as(*const IDiscRecorder, @ptrCast(self)), pbyUniqueID, nulIDSize, nulDriveNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderGUID(self: *const T, pbyUniqueID: ?[*:0]u8, ulBufferSize: u32, pulReturnSizeRequired: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderGUID(@as(*const IDiscRecorder, @ptrCast(self)), pbyUniqueID, ulBufferSize, pulReturnSizeRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderType(self: *const T, fTypeCode: ?*RECORDER_TYPES) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderType(@as(*const IDiscRecorder, @ptrCast(self)), fTypeCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetDisplayNames(self: *const T, pbstrVendorID: ?*?BSTR, pbstrProductID: ?*?BSTR, pbstrRevision: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetDisplayNames(@as(*const IDiscRecorder, @ptrCast(self)), pbstrVendorID, pbstrProductID, pbstrRevision);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetBasePnPID(self: *const T, pbstrBasePnPID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetBasePnPID(@as(*const IDiscRecorder, @ptrCast(self)), pbstrBasePnPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetPath(self: *const T, pbstrPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IDiscRecorder, @ptrCast(self)), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderProperties(self: *const T, ppPropStg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderProperties(@as(*const IDiscRecorder, @ptrCast(self)), ppPropStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_SetRecorderProperties(self: *const T, pPropStg: ?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).SetRecorderProperties(@as(*const IDiscRecorder, @ptrCast(self)), pPropStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_GetRecorderState(self: *const T, pulDevStateFlags: ?*DISC_RECORDER_STATE_FLAGS) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).GetRecorderState(@as(*const IDiscRecorder, @ptrCast(self)), pulDevStateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_OpenExclusive(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).OpenExclusive(@as(*const IDiscRecorder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_QueryMediaType(self: *const T, fMediaType: ?*MEDIA_TYPES, fMediaFlags: ?*MEDIA_FLAGS) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).QueryMediaType(@as(*const IDiscRecorder, @ptrCast(self)), fMediaType, fMediaFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_QueryMediaInfo(self: *const T, pbSessions: ?*u8, pbLastTrack: ?*u8, ulStartAddress: ?*u32, ulNextWritable: ?*u32, ulFreeBlocks: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).QueryMediaInfo(@as(*const IDiscRecorder, @ptrCast(self)), pbSessions, pbLastTrack, ulStartAddress, ulNextWritable, ulFreeBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Eject(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Eject(@as(*const IDiscRecorder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Erase(self: *const T, bFullErase: u8) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Erase(@as(*const IDiscRecorder, @ptrCast(self)), bFullErase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscRecorder_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscRecorder.VTable, @ptrCast(self.vtable)).Close(@as(*const IDiscRecorder, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDiscRecorders_Value = Guid.initString("9b1921e1-54ac-11d3-9144-00104ba11c5e");
pub const IID_IEnumDiscRecorders = &IID_IEnumDiscRecorders_Value;
pub const IEnumDiscRecorders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscRecorders,
                cRecorders: u32,
                ppRecorder: [*]?*IDiscRecorder,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscRecorders,
                cRecorders: u32,
                ppRecorder: [*]?*IDiscRecorder,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscRecorders,
                cRecorders: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscRecorders,
                cRecorders: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscRecorders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscRecorders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscRecorders,
                ppEnum: ?*?*IEnumDiscRecorders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscRecorders,
                ppEnum: ?*?*IEnumDiscRecorders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Next(self: *const T, cRecorders: u32, ppRecorder: [*]?*IDiscRecorder, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDiscRecorders, @ptrCast(self)), cRecorders, ppRecorder, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Skip(self: *const T, cRecorders: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDiscRecorders, @ptrCast(self)), cRecorders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDiscRecorders, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscRecorders_Clone(self: *const T, ppEnum: ?*?*IEnumDiscRecorders) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscRecorders.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDiscRecorders, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDiscMasterFormats_Value = Guid.initString("ddf445e1-54ba-11d3-9144-00104ba11c5e");
pub const IID_IEnumDiscMasterFormats = &IID_IEnumDiscMasterFormats_Value;
pub const IEnumDiscMasterFormats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscMasterFormats,
                cFormats: u32,
                lpiidFormatID: [*]Guid,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscMasterFormats,
                cFormats: u32,
                lpiidFormatID: [*]Guid,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscMasterFormats,
                cFormats: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscMasterFormats,
                cFormats: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscMasterFormats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscMasterFormats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDiscMasterFormats,
                ppEnum: ?*?*IEnumDiscMasterFormats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDiscMasterFormats,
                ppEnum: ?*?*IEnumDiscMasterFormats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Next(self: *const T, cFormats: u32, lpiidFormatID: [*]Guid, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDiscMasterFormats, @ptrCast(self)), cFormats, lpiidFormatID, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Skip(self: *const T, cFormats: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDiscMasterFormats, @ptrCast(self)), cFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDiscMasterFormats, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDiscMasterFormats_Clone(self: *const T, ppEnum: ?*?*IEnumDiscMasterFormats) callconv(.Inline) HRESULT {
            return @as(*const IEnumDiscMasterFormats.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDiscMasterFormats, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRedbookDiscMaster_Value = Guid.initString("e3bc42cd-4e5c-11d3-9144-00104ba11c5e");
pub const IID_IRedbookDiscMaster = &IID_IRedbookDiscMaster_Value;
pub const IRedbookDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTotalAudioTracks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                pnTracks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                pnTracks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalAudioBlocks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUsedAudioBlocks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableAudioTrackBlocks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioBlockSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                pnBlockBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                pnBlockBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAudioTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                nBlocks: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                nBlocks: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAudioTrackBlocks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
                pby: [*:0]u8,
                cb: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
                pby: [*:0]u8,
                cb: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseAudioTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRedbookDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRedbookDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetTotalAudioTracks(self: *const T, pnTracks: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetTotalAudioTracks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pnTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetTotalAudioBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetTotalAudioBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetUsedAudioBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetUsedAudioBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetAvailableAudioTrackBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetAvailableAudioTrackBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_GetAudioBlockSize(self: *const T, pnBlockBytes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).GetAudioBlockSize(@as(*const IRedbookDiscMaster, @ptrCast(self)), pnBlockBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_CreateAudioTrack(self: *const T, nBlocks: i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).CreateAudioTrack(@as(*const IRedbookDiscMaster, @ptrCast(self)), nBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_AddAudioTrackBlocks(self: *const T, pby: [*:0]u8, cb: i32) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).AddAudioTrackBlocks(@as(*const IRedbookDiscMaster, @ptrCast(self)), pby, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRedbookDiscMaster_CloseAudioTrack(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRedbookDiscMaster.VTable, @ptrCast(self.vtable)).CloseAudioTrack(@as(*const IRedbookDiscMaster, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IJolietDiscMaster_Value = Guid.initString("e3bc42ce-4e5c-11d3-9144-00104ba11c5e");
pub const IID_IJolietDiscMaster = &IID_IJolietDiscMaster_Value;
pub const IJolietDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTotalDataBlocks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJolietDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJolietDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUsedDataBlocks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJolietDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJolietDiscMaster,
                pnBlocks: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataBlockSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJolietDiscMaster,
                pnBlockBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJolietDiscMaster,
                pnBlockBytes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJolietDiscMaster,
                pStorage: ?*IStorage,
                lFileOverwrite: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJolietDiscMaster,
                pStorage: ?*IStorage,
                lFileOverwrite: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetJolietProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJolietDiscMaster,
                ppPropStg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJolietDiscMaster,
                ppPropStg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetJolietProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJolietDiscMaster,
                pPropStg: ?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJolietDiscMaster,
                pPropStg: ?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetTotalDataBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetTotalDataBlocks(@as(*const IJolietDiscMaster, @ptrCast(self)), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetUsedDataBlocks(self: *const T, pnBlocks: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetUsedDataBlocks(@as(*const IJolietDiscMaster, @ptrCast(self)), pnBlocks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetDataBlockSize(self: *const T, pnBlockBytes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetDataBlockSize(@as(*const IJolietDiscMaster, @ptrCast(self)), pnBlockBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_AddData(self: *const T, pStorage: ?*IStorage, lFileOverwrite: i32) callconv(.Inline) HRESULT {
            return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).AddData(@as(*const IJolietDiscMaster, @ptrCast(self)), pStorage, lFileOverwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_GetJolietProperties(self: *const T, ppPropStg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).GetJolietProperties(@as(*const IJolietDiscMaster, @ptrCast(self)), ppPropStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJolietDiscMaster_SetJolietProperties(self: *const T, pPropStg: ?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IJolietDiscMaster.VTable, @ptrCast(self.vtable)).SetJolietProperties(@as(*const IJolietDiscMaster, @ptrCast(self)), pPropStg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscMasterProgressEvents_Value = Guid.initString("ec9e51c1-4e5d-11d3-9144-00104ba11c5e");
pub const IID_IDiscMasterProgressEvents = &IID_IDiscMasterProgressEvents_Value;
pub const IDiscMasterProgressEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                pbCancel: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                pbCancel: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyPnPActivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyAddProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                nCompletedSteps: i32,
                nTotalSteps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                nCompletedSteps: i32,
                nTotalSteps: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyBlockProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                nCompleted: i32,
                nTotal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                nCompleted: i32,
                nTotal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyTrackProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                nCurrentTrack: i32,
                nTotalTracks: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                nCurrentTrack: i32,
                nTotalTracks: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyPreparingBurn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                nEstimatedSeconds: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                nEstimatedSeconds: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyClosingDisc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                nEstimatedSeconds: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                nEstimatedSeconds: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyBurnComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                status: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                status: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyEraseComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMasterProgressEvents,
                status: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMasterProgressEvents,
                status: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_QueryCancel(self: *const T, pbCancel: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).QueryCancel(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), pbCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyPnPActivity(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyPnPActivity(@as(*const IDiscMasterProgressEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyAddProgress(self: *const T, nCompletedSteps: i32, nTotalSteps: i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyAddProgress(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), nCompletedSteps, nTotalSteps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyBlockProgress(self: *const T, nCompleted: i32, nTotal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyBlockProgress(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), nCompleted, nTotal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyTrackProgress(self: *const T, nCurrentTrack: i32, nTotalTracks: i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyTrackProgress(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), nCurrentTrack, nTotalTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyPreparingBurn(self: *const T, nEstimatedSeconds: i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyPreparingBurn(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), nEstimatedSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyClosingDisc(self: *const T, nEstimatedSeconds: i32) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyClosingDisc(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), nEstimatedSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyBurnComplete(self: *const T, status: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyBurnComplete(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMasterProgressEvents_NotifyEraseComplete(self: *const T, status: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IDiscMasterProgressEvents.VTable, @ptrCast(self.vtable)).NotifyEraseComplete(@as(*const IDiscMasterProgressEvents, @ptrCast(self)), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDiscMaster_Value = Guid.initString("520cca62-51a5-11d3-9144-00104ba11c5e");
pub const IID_IDiscMaster = &IID_IDiscMaster_Value;
pub const IDiscMaster = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDiscMasterFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                ppEnum: ?*?*IEnumDiscMasterFormats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                ppEnum: ?*?*IEnumDiscMasterFormats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveDiscMasterFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                lpiid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                lpiid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveDiscMasterFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDiscRecorders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                ppEnum: ?*?*IEnumDiscRecorders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                ppEnum: ?*?*IEnumDiscRecorders,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveDiscRecorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                ppRecorder: ?*?*IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                ppRecorder: ?*?*IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActiveDiscRecorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                pRecorder: ?*IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                pRecorder: ?*IDiscRecorder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearFormatContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProgressAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                pEvents: ?*IDiscMasterProgressEvents,
                pvCookie: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                pEvents: ?*IDiscMasterProgressEvents,
                pvCookie: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProgressUnadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                vCookie: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                vCookie: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecordDisc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
                bSimulate: u8,
                bEjectAfterBurn: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
                bSimulate: u8,
                bEjectAfterBurn: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDiscMaster,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_Open(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).Open(@as(*const IDiscMaster, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_EnumDiscMasterFormats(self: *const T, ppEnum: ?*?*IEnumDiscMasterFormats) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).EnumDiscMasterFormats(@as(*const IDiscMaster, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_GetActiveDiscMasterFormat(self: *const T, lpiid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).GetActiveDiscMasterFormat(@as(*const IDiscMaster, @ptrCast(self)), lpiid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_SetActiveDiscMasterFormat(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).SetActiveDiscMasterFormat(@as(*const IDiscMaster, @ptrCast(self)), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_EnumDiscRecorders(self: *const T, ppEnum: ?*?*IEnumDiscRecorders) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).EnumDiscRecorders(@as(*const IDiscMaster, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_GetActiveDiscRecorder(self: *const T, ppRecorder: ?*?*IDiscRecorder) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).GetActiveDiscRecorder(@as(*const IDiscMaster, @ptrCast(self)), ppRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_SetActiveDiscRecorder(self: *const T, pRecorder: ?*IDiscRecorder) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).SetActiveDiscRecorder(@as(*const IDiscMaster, @ptrCast(self)), pRecorder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_ClearFormatContent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).ClearFormatContent(@as(*const IDiscMaster, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_ProgressAdvise(self: *const T, pEvents: ?*IDiscMasterProgressEvents, pvCookie: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).ProgressAdvise(@as(*const IDiscMaster, @ptrCast(self)), pEvents, pvCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_ProgressUnadvise(self: *const T, vCookie: usize) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).ProgressUnadvise(@as(*const IDiscMaster, @ptrCast(self)), vCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_RecordDisc(self: *const T, bSimulate: u8, bEjectAfterBurn: u8) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).RecordDisc(@as(*const IDiscMaster, @ptrCast(self)), bSimulate, bEjectAfterBurn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDiscMaster_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDiscMaster.VTable, @ptrCast(self.vtable)).Close(@as(*const IDiscMaster, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _MSGSESS = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const MSGCALLRELEASE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ulCallerData: u32,
        lpMessage: ?*IMessage,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        ulCallerData: u32,
        lpMessage: ?*IMessage,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const SPropAttrArray = extern struct {
    cValues: u32,
    aPropAttr: [1]u32,
};

const CLSID_tagIMMPID_MP_STRUCT_Value = Guid.initString("13384cf0-b3c4-11d1-aa92-00aa006bc80b");
pub const CLSID_tagIMMPID_MP_STRUCT = &CLSID_tagIMMPID_MP_STRUCT_Value;

pub const IMMPID_MP_ENUM = enum(i32) {
    BEFORE__ = 4095,
    RECIPIENT_LIST = 4096,
    CONTENT_FILE_NAME = 4097,
    SENDER_ADDRESS_SMTP = 4098,
    SENDER_ADDRESS_X500 = 4099,
    SENDER_ADDRESS_X400 = 4100,
    SENDER_ADDRESS_LEGACY_EX_DN = 4101,
    DOMAIN_LIST = 4102,
    PICKUP_FILE_NAME = 4103,
    AUTHENTICATED_USER_NAME = 4104,
    CONNECTION_IP_ADDRESS = 4105,
    HELO_DOMAIN = 4106,
    EIGHTBIT_MIME_OPTION = 4107,
    CHUNKING_OPTION = 4108,
    BINARYMIME_OPTION = 4109,
    REMOTE_AUTHENTICATION_TYPE = 4110,
    ERROR_CODE = 4111,
    DSN_ENVID_VALUE = 4112,
    DSN_RET_VALUE = 4113,
    REMOTE_SERVER_DSN_CAPABLE = 4114,
    ARRIVAL_TIME = 4115,
    MESSAGE_STATUS = 4116,
    EXPIRE_DELAY = 4117,
    EXPIRE_NDR = 4118,
    LOCAL_EXPIRE_DELAY = 4119,
    LOCAL_EXPIRE_NDR = 4120,
    ARRIVAL_FILETIME = 4121,
    HR_CAT_STATUS = 4122,
    MSG_GUID = 4123,
    SUPERSEDES_MSG_GUID = 4124,
    SCANNED_FOR_CRLF_DOT_CRLF = 4125,
    FOUND_EMBEDDED_CRLF_DOT_CRLF = 4126,
    MSG_SIZE_HINT = 4127,
    RFC822_MSG_ID = 4128,
    RFC822_MSG_SUBJECT = 4129,
    RFC822_FROM_ADDRESS = 4130,
    RFC822_TO_ADDRESS = 4131,
    RFC822_CC_ADDRESS = 4132,
    RFC822_BCC_ADDRESS = 4133,
    CONNECTION_SERVER_IP_ADDRESS = 4134,
    SERVER_NAME = 4135,
    SERVER_VERSION = 4136,
    NUM_RECIPIENTS = 4137,
    X_PRIORITY = 4138,
    FROM_ADDRESS = 4139,
    SENDER_ADDRESS = 4140,
    DEFERRED_DELIVERY_FILETIME = 4141,
    SENDER_ADDRESS_OTHER = 4142,
    ORIGINAL_ARRIVAL_TIME = 4143,
    MSGCLASS = 4144,
    CONTENT_TYPE = 4145,
    ENCRYPTION_TYPE = 4146,
    CONNECTION_SERVER_PORT = 4147,
    CLIENT_AUTH_USER = 4148,
    CLIENT_AUTH_TYPE = 4149,
    CRC_GLOBAL = 4150,
    CRC_RECIPS = 4151,
    INBOUND_MAIL_FROM_AUTH = 4152,
    AFTER__ = 4153,
};
pub const IMMPID_MP_BEFORE__ = IMMPID_MP_ENUM.BEFORE__;
pub const IMMPID_MP_RECIPIENT_LIST = IMMPID_MP_ENUM.RECIPIENT_LIST;
pub const IMMPID_MP_CONTENT_FILE_NAME = IMMPID_MP_ENUM.CONTENT_FILE_NAME;
pub const IMMPID_MP_SENDER_ADDRESS_SMTP = IMMPID_MP_ENUM.SENDER_ADDRESS_SMTP;
pub const IMMPID_MP_SENDER_ADDRESS_X500 = IMMPID_MP_ENUM.SENDER_ADDRESS_X500;
pub const IMMPID_MP_SENDER_ADDRESS_X400 = IMMPID_MP_ENUM.SENDER_ADDRESS_X400;
pub const IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN = IMMPID_MP_ENUM.SENDER_ADDRESS_LEGACY_EX_DN;
pub const IMMPID_MP_DOMAIN_LIST = IMMPID_MP_ENUM.DOMAIN_LIST;
pub const IMMPID_MP_PICKUP_FILE_NAME = IMMPID_MP_ENUM.PICKUP_FILE_NAME;
pub const IMMPID_MP_AUTHENTICATED_USER_NAME = IMMPID_MP_ENUM.AUTHENTICATED_USER_NAME;
pub const IMMPID_MP_CONNECTION_IP_ADDRESS = IMMPID_MP_ENUM.CONNECTION_IP_ADDRESS;
pub const IMMPID_MP_HELO_DOMAIN = IMMPID_MP_ENUM.HELO_DOMAIN;
pub const IMMPID_MP_EIGHTBIT_MIME_OPTION = IMMPID_MP_ENUM.EIGHTBIT_MIME_OPTION;
pub const IMMPID_MP_CHUNKING_OPTION = IMMPID_MP_ENUM.CHUNKING_OPTION;
pub const IMMPID_MP_BINARYMIME_OPTION = IMMPID_MP_ENUM.BINARYMIME_OPTION;
pub const IMMPID_MP_REMOTE_AUTHENTICATION_TYPE = IMMPID_MP_ENUM.REMOTE_AUTHENTICATION_TYPE;
pub const IMMPID_MP_ERROR_CODE = IMMPID_MP_ENUM.ERROR_CODE;
pub const IMMPID_MP_DSN_ENVID_VALUE = IMMPID_MP_ENUM.DSN_ENVID_VALUE;
pub const IMMPID_MP_DSN_RET_VALUE = IMMPID_MP_ENUM.DSN_RET_VALUE;
pub const IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE = IMMPID_MP_ENUM.REMOTE_SERVER_DSN_CAPABLE;
pub const IMMPID_MP_ARRIVAL_TIME = IMMPID_MP_ENUM.ARRIVAL_TIME;
pub const IMMPID_MP_MESSAGE_STATUS = IMMPID_MP_ENUM.MESSAGE_STATUS;
pub const IMMPID_MP_EXPIRE_DELAY = IMMPID_MP_ENUM.EXPIRE_DELAY;
pub const IMMPID_MP_EXPIRE_NDR = IMMPID_MP_ENUM.EXPIRE_NDR;
pub const IMMPID_MP_LOCAL_EXPIRE_DELAY = IMMPID_MP_ENUM.LOCAL_EXPIRE_DELAY;
pub const IMMPID_MP_LOCAL_EXPIRE_NDR = IMMPID_MP_ENUM.LOCAL_EXPIRE_NDR;
pub const IMMPID_MP_ARRIVAL_FILETIME = IMMPID_MP_ENUM.ARRIVAL_FILETIME;
pub const IMMPID_MP_HR_CAT_STATUS = IMMPID_MP_ENUM.HR_CAT_STATUS;
pub const IMMPID_MP_MSG_GUID = IMMPID_MP_ENUM.MSG_GUID;
pub const IMMPID_MP_SUPERSEDES_MSG_GUID = IMMPID_MP_ENUM.SUPERSEDES_MSG_GUID;
pub const IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF = IMMPID_MP_ENUM.SCANNED_FOR_CRLF_DOT_CRLF;
pub const IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF = IMMPID_MP_ENUM.FOUND_EMBEDDED_CRLF_DOT_CRLF;
pub const IMMPID_MP_MSG_SIZE_HINT = IMMPID_MP_ENUM.MSG_SIZE_HINT;
pub const IMMPID_MP_RFC822_MSG_ID = IMMPID_MP_ENUM.RFC822_MSG_ID;
pub const IMMPID_MP_RFC822_MSG_SUBJECT = IMMPID_MP_ENUM.RFC822_MSG_SUBJECT;
pub const IMMPID_MP_RFC822_FROM_ADDRESS = IMMPID_MP_ENUM.RFC822_FROM_ADDRESS;
pub const IMMPID_MP_RFC822_TO_ADDRESS = IMMPID_MP_ENUM.RFC822_TO_ADDRESS;
pub const IMMPID_MP_RFC822_CC_ADDRESS = IMMPID_MP_ENUM.RFC822_CC_ADDRESS;
pub const IMMPID_MP_RFC822_BCC_ADDRESS = IMMPID_MP_ENUM.RFC822_BCC_ADDRESS;
pub const IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS = IMMPID_MP_ENUM.CONNECTION_SERVER_IP_ADDRESS;
pub const IMMPID_MP_SERVER_NAME = IMMPID_MP_ENUM.SERVER_NAME;
pub const IMMPID_MP_SERVER_VERSION = IMMPID_MP_ENUM.SERVER_VERSION;
pub const IMMPID_MP_NUM_RECIPIENTS = IMMPID_MP_ENUM.NUM_RECIPIENTS;
pub const IMMPID_MP_X_PRIORITY = IMMPID_MP_ENUM.X_PRIORITY;
pub const IMMPID_MP_FROM_ADDRESS = IMMPID_MP_ENUM.FROM_ADDRESS;
pub const IMMPID_MP_SENDER_ADDRESS = IMMPID_MP_ENUM.SENDER_ADDRESS;
pub const IMMPID_MP_DEFERRED_DELIVERY_FILETIME = IMMPID_MP_ENUM.DEFERRED_DELIVERY_FILETIME;
pub const IMMPID_MP_SENDER_ADDRESS_OTHER = IMMPID_MP_ENUM.SENDER_ADDRESS_OTHER;
pub const IMMPID_MP_ORIGINAL_ARRIVAL_TIME = IMMPID_MP_ENUM.ORIGINAL_ARRIVAL_TIME;
pub const IMMPID_MP_MSGCLASS = IMMPID_MP_ENUM.MSGCLASS;
pub const IMMPID_MP_CONTENT_TYPE = IMMPID_MP_ENUM.CONTENT_TYPE;
pub const IMMPID_MP_ENCRYPTION_TYPE = IMMPID_MP_ENUM.ENCRYPTION_TYPE;
pub const IMMPID_MP_CONNECTION_SERVER_PORT = IMMPID_MP_ENUM.CONNECTION_SERVER_PORT;
pub const IMMPID_MP_CLIENT_AUTH_USER = IMMPID_MP_ENUM.CLIENT_AUTH_USER;
pub const IMMPID_MP_CLIENT_AUTH_TYPE = IMMPID_MP_ENUM.CLIENT_AUTH_TYPE;
pub const IMMPID_MP_CRC_GLOBAL = IMMPID_MP_ENUM.CRC_GLOBAL;
pub const IMMPID_MP_CRC_RECIPS = IMMPID_MP_ENUM.CRC_RECIPS;
pub const IMMPID_MP_INBOUND_MAIL_FROM_AUTH = IMMPID_MP_ENUM.INBOUND_MAIL_FROM_AUTH;
pub const IMMPID_MP_AFTER__ = IMMPID_MP_ENUM.AFTER__;

const CLSID_tagIMMPID_RP_STRUCT_Value = Guid.initString("79e82048-d320-11d1-9ff4-00c04fa37348");
pub const CLSID_tagIMMPID_RP_STRUCT = &CLSID_tagIMMPID_RP_STRUCT_Value;

pub const IMMPID_RP_ENUM = enum(i32) {
    BEFORE__ = 8191,
    DSN_NOTIFY_SUCCESS = 8192,
    DSN_NOTIFY_INVALID = 8193,
    ADDRESS_TYPE = 8194,
    ADDRESS = 8195,
    ADDRESS_TYPE_SMTP = 8196,
    ERROR_CODE = 8197,
    ERROR_STRING = 8198,
    DSN_NOTIFY_VALUE = 8199,
    DSN_ORCPT_VALUE = 8200,
    ADDRESS_SMTP = 8201,
    ADDRESS_X400 = 8202,
    ADDRESS_X500 = 8203,
    LEGACY_EX_DN = 8204,
    RECIPIENT_FLAGS = 8205,
    SMTP_STATUS_STRING = 8206,
    DSN_PRE_CAT_ADDRESS = 8207,
    MDB_GUID = 8208,
    USER_GUID = 8209,
    DOMAIN = 8210,
    ADDRESS_OTHER = 8211,
    DISPLAY_NAME = 8212,
    AFTER__ = 8213,
};
pub const IMMPID_RP_BEFORE__ = IMMPID_RP_ENUM.BEFORE__;
pub const IMMPID_RP_DSN_NOTIFY_SUCCESS = IMMPID_RP_ENUM.DSN_NOTIFY_SUCCESS;
pub const IMMPID_RP_DSN_NOTIFY_INVALID = IMMPID_RP_ENUM.DSN_NOTIFY_INVALID;
pub const IMMPID_RP_ADDRESS_TYPE = IMMPID_RP_ENUM.ADDRESS_TYPE;
pub const IMMPID_RP_ADDRESS = IMMPID_RP_ENUM.ADDRESS;
pub const IMMPID_RP_ADDRESS_TYPE_SMTP = IMMPID_RP_ENUM.ADDRESS_TYPE_SMTP;
pub const IMMPID_RP_ERROR_CODE = IMMPID_RP_ENUM.ERROR_CODE;
pub const IMMPID_RP_ERROR_STRING = IMMPID_RP_ENUM.ERROR_STRING;
pub const IMMPID_RP_DSN_NOTIFY_VALUE = IMMPID_RP_ENUM.DSN_NOTIFY_VALUE;
pub const IMMPID_RP_DSN_ORCPT_VALUE = IMMPID_RP_ENUM.DSN_ORCPT_VALUE;
pub const IMMPID_RP_ADDRESS_SMTP = IMMPID_RP_ENUM.ADDRESS_SMTP;
pub const IMMPID_RP_ADDRESS_X400 = IMMPID_RP_ENUM.ADDRESS_X400;
pub const IMMPID_RP_ADDRESS_X500 = IMMPID_RP_ENUM.ADDRESS_X500;
pub const IMMPID_RP_LEGACY_EX_DN = IMMPID_RP_ENUM.LEGACY_EX_DN;
pub const IMMPID_RP_RECIPIENT_FLAGS = IMMPID_RP_ENUM.RECIPIENT_FLAGS;
pub const IMMPID_RP_SMTP_STATUS_STRING = IMMPID_RP_ENUM.SMTP_STATUS_STRING;
pub const IMMPID_RP_DSN_PRE_CAT_ADDRESS = IMMPID_RP_ENUM.DSN_PRE_CAT_ADDRESS;
pub const IMMPID_RP_MDB_GUID = IMMPID_RP_ENUM.MDB_GUID;
pub const IMMPID_RP_USER_GUID = IMMPID_RP_ENUM.USER_GUID;
pub const IMMPID_RP_DOMAIN = IMMPID_RP_ENUM.DOMAIN;
pub const IMMPID_RP_ADDRESS_OTHER = IMMPID_RP_ENUM.ADDRESS_OTHER;
pub const IMMPID_RP_DISPLAY_NAME = IMMPID_RP_ENUM.DISPLAY_NAME;
pub const IMMPID_RP_AFTER__ = IMMPID_RP_ENUM.AFTER__;

const CLSID_tagIMMPID_MPV_STRUCT_Value = Guid.initString("cbe69706-c9bd-11d1-9ff2-00c04fa37348");
pub const CLSID_tagIMMPID_MPV_STRUCT = &CLSID_tagIMMPID_MPV_STRUCT_Value;

pub const IMMPID_MPV_ENUM = enum(i32) {
    BEFORE__ = 12287,
    STORE_DRIVER_HANDLE = 12288,
    MESSAGE_CREATION_FLAGS = 12289,
    MESSAGE_OPEN_HANDLES = 12290,
    TOTAL_OPEN_HANDLES = 12291,
    TOTAL_OPEN_PROPERTY_STREAM_HANDLES = 12292,
    TOTAL_OPEN_CONTENT_HANDLES = 12293,
    AFTER__ = 12294,
};
pub const IMMPID_MPV_BEFORE__ = IMMPID_MPV_ENUM.BEFORE__;
pub const IMMPID_MPV_STORE_DRIVER_HANDLE = IMMPID_MPV_ENUM.STORE_DRIVER_HANDLE;
pub const IMMPID_MPV_MESSAGE_CREATION_FLAGS = IMMPID_MPV_ENUM.MESSAGE_CREATION_FLAGS;
pub const IMMPID_MPV_MESSAGE_OPEN_HANDLES = IMMPID_MPV_ENUM.MESSAGE_OPEN_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_PROPERTY_STREAM_HANDLES;
pub const IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES = IMMPID_MPV_ENUM.TOTAL_OPEN_CONTENT_HANDLES;
pub const IMMPID_MPV_AFTER__ = IMMPID_MPV_ENUM.AFTER__;

pub const IMMP_MPV_STORE_DRIVER_HANDLE = extern struct {
    guidSignature: Guid,
};

const CLSID_tagIMMPID_RPV_STRUCT_Value = Guid.initString("79e82049-d320-11d1-9ff4-00c04fa37348");
pub const CLSID_tagIMMPID_RPV_STRUCT = &CLSID_tagIMMPID_RPV_STRUCT_Value;

pub const IMMPID_RPV_ENUM = enum(i32) {
    BEFORE__ = 16383,
    DONT_DELIVER = 16384,
    NO_NAME_COLLISIONS = 16385,
    AFTER__ = 16386,
};
pub const IMMPID_RPV_BEFORE__ = IMMPID_RPV_ENUM.BEFORE__;
pub const IMMPID_RPV_DONT_DELIVER = IMMPID_RPV_ENUM.DONT_DELIVER;
pub const IMMPID_RPV_NO_NAME_COLLISIONS = IMMPID_RPV_ENUM.NO_NAME_COLLISIONS;
pub const IMMPID_RPV_AFTER__ = IMMPID_RPV_ENUM.AFTER__;

const CLSID_tagIMMPID_NMP_STRUCT_Value = Guid.initString("7433a9aa-20e2-11d2-94d6-00c04fa379f1");
pub const CLSID_tagIMMPID_NMP_STRUCT = &CLSID_tagIMMPID_NMP_STRUCT_Value;

pub const IMMPID_NMP_ENUM = enum(i32) {
    BEFORE__ = 24575,
    SECONDARY_GROUPS = 24576,
    SECONDARY_ARTNUM = 24577,
    PRIMARY_GROUP = 24578,
    PRIMARY_ARTID = 24579,
    POST_TOKEN = 24580,
    NEWSGROUP_LIST = 24581,
    HEADERS = 24582,
    NNTP_PROCESSING = 24583,
    NNTP_APPROVED_HEADER = 24584,
    AFTER__ = 24585,
};
pub const IMMPID_NMP_BEFORE__ = IMMPID_NMP_ENUM.BEFORE__;
pub const IMMPID_NMP_SECONDARY_GROUPS = IMMPID_NMP_ENUM.SECONDARY_GROUPS;
pub const IMMPID_NMP_SECONDARY_ARTNUM = IMMPID_NMP_ENUM.SECONDARY_ARTNUM;
pub const IMMPID_NMP_PRIMARY_GROUP = IMMPID_NMP_ENUM.PRIMARY_GROUP;
pub const IMMPID_NMP_PRIMARY_ARTID = IMMPID_NMP_ENUM.PRIMARY_ARTID;
pub const IMMPID_NMP_POST_TOKEN = IMMPID_NMP_ENUM.POST_TOKEN;
pub const IMMPID_NMP_NEWSGROUP_LIST = IMMPID_NMP_ENUM.NEWSGROUP_LIST;
pub const IMMPID_NMP_HEADERS = IMMPID_NMP_ENUM.HEADERS;
pub const IMMPID_NMP_NNTP_PROCESSING = IMMPID_NMP_ENUM.NNTP_PROCESSING;
pub const IMMPID_NMP_NNTP_APPROVED_HEADER = IMMPID_NMP_ENUM.NNTP_APPROVED_HEADER;
pub const IMMPID_NMP_AFTER__ = IMMPID_NMP_ENUM.AFTER__;

const CLSID_tagIMMPID_CPV_STRUCT_Value = Guid.initString("a2a76b2a-e52d-11d1-aa64-00c04fa35b82");
pub const CLSID_tagIMMPID_CPV_STRUCT = &CLSID_tagIMMPID_CPV_STRUCT_Value;

pub const IMMPID_CPV_ENUM = enum(i32) {
    V_BEFORE__ = 32767,
    _START = 32768,
    V_AFTER__ = 32769,
};
pub const IMMPID_CPV_BEFORE__ = IMMPID_CPV_ENUM.V_BEFORE__;
pub const IMMPID_CP_START = IMMPID_CPV_ENUM._START;
pub const IMMPID_CPV_AFTER__ = IMMPID_CPV_ENUM.V_AFTER__;

pub const tagIMMPID_GUIDLIST_ITEM = extern struct {
    pguid: ?*const Guid,
    dwStart: u32,
    dwLast: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (6)
//--------------------------------------------------------------------------------
pub extern "mapi32" fn OpenIMsgSession(
    lpMalloc: ?*IMalloc,
    ulFlags: u32,
    lppMsgSess: ?*?*_MSGSESS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn CloseIMsgSession(
    lpMsgSess: ?*_MSGSESS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn OpenIMsgOnIStg(
    lpMsgSess: ?*_MSGSESS,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpMalloc: ?*IMalloc,
    lpMapiSup: ?*anyopaque,
    lpStg: ?*IStorage,
    lpfMsgCallRelease: ?*?MSGCALLRELEASE,
    ulCallerData: u32,
    ulFlags: u32,
    lppMsg: ?*?*IMessage,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn GetAttribIMsgOnIStg(
    lpObject: ?*anyopaque,
    lpPropTagArray: ?*SPropTagArray,
    lppPropAttrArray: ?*?*SPropAttrArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn SetAttribIMsgOnIStg(
    lpObject: ?*anyopaque,
    lpPropTags: ?*SPropTagArray,
    lpPropAttrs: ?*SPropAttrArray,
    lppPropProblems: ?*?*SPropProblemArray,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn MapStorageSCode(
    StgSCode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (18)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IMalloc = @import("../system/com.zig").IMalloc;
const IMessage = @import("../system/address_book.zig").IMessage;
const IPropertyStorage = @import("../system/com/structured_storage.zig").IPropertyStorage;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPALLOCATEBUFFER = @import("../system/address_book.zig").LPALLOCATEBUFFER;
const LPALLOCATEMORE = @import("../system/address_book.zig").LPALLOCATEMORE;
const LPFREEBUFFER = @import("../system/address_book.zig").LPFREEBUFFER;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SPropProblemArray = @import("../system/address_book.zig").SPropProblemArray;
const SPropTagArray = @import("../system/address_book.zig").SPropTagArray;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "MSGCALLRELEASE")) { _ = MSGCALLRELEASE; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
